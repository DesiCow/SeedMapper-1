// Generated by jextract

package com.github.cubiomes;

import java.lang.foreign.AddressLayout;
import java.lang.foreign.Arena;
import java.lang.foreign.FunctionDescriptor;
import java.lang.foreign.GroupLayout;
import java.lang.foreign.Linker;
import java.lang.foreign.MemoryLayout;
import java.lang.foreign.MemorySegment;
import java.lang.foreign.PaddingLayout;
import java.lang.foreign.SegmentAllocator;
import java.lang.foreign.SequenceLayout;
import java.lang.foreign.StructLayout;
import java.lang.foreign.SymbolLookup;
import java.lang.foreign.ValueLayout;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.util.Arrays;
import java.util.stream.Collectors;

import static java.lang.foreign.ValueLayout.*;

public class Cubiomes_1 {

    Cubiomes_1() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }



    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfInt C_LONG = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfDouble C_LONG_DOUBLE = ValueLayout.JAVA_DOUBLE;
    private static final int _VCRT_COMPILER_PREPROCESSOR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _VCRT_COMPILER_PREPROCESSOR 1
     * }
     */
    public static int _VCRT_COMPILER_PREPROCESSOR() {
        return _VCRT_COMPILER_PREPROCESSOR;
    }
    private static final int _SAL_VERSION = (int)20L;
    /**
     * {@snippet lang=c :
     * #define _SAL_VERSION 20
     * }
     */
    public static int _SAL_VERSION() {
        return _SAL_VERSION;
    }
    private static final int __SAL_H_VERSION = (int)180000000L;
    /**
     * {@snippet lang=c :
     * #define __SAL_H_VERSION 180000000
     * }
     */
    public static int __SAL_H_VERSION() {
        return __SAL_H_VERSION;
    }
    private static final int _USE_DECLSPECS_FOR_SAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _USE_DECLSPECS_FOR_SAL 0
     * }
     */
    public static int _USE_DECLSPECS_FOR_SAL() {
        return _USE_DECLSPECS_FOR_SAL;
    }
    private static final int _USE_ATTRIBUTES_FOR_SAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _USE_ATTRIBUTES_FOR_SAL 0
     * }
     */
    public static int _USE_ATTRIBUTES_FOR_SAL() {
        return _USE_ATTRIBUTES_FOR_SAL;
    }
    private static final int _CRT_PACKING = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _CRT_PACKING 8
     * }
     */
    public static int _CRT_PACKING() {
        return _CRT_PACKING;
    }
    private static final int _HAS_EXCEPTIONS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _HAS_EXCEPTIONS 1
     * }
     */
    public static int _HAS_EXCEPTIONS() {
        return _HAS_EXCEPTIONS;
    }
    private static final int _HAS_CXX17 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_CXX17 0
     * }
     */
    public static int _HAS_CXX17() {
        return _HAS_CXX17;
    }
    private static final int _HAS_CXX20 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_CXX20 0
     * }
     */
    public static int _HAS_CXX20() {
        return _HAS_CXX20;
    }
    private static final int _HAS_NODISCARD = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_NODISCARD 0
     * }
     */
    public static int _HAS_NODISCARD() {
        return _HAS_NODISCARD;
    }
    private static final int _ARGMAX = (int)100L;
    /**
     * {@snippet lang=c :
     * #define _ARGMAX 100
     * }
     */
    public static int _ARGMAX() {
        return _ARGMAX;
    }
    private static final int _CRT_INT_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INT_MAX 2147483647
     * }
     */
    public static int _CRT_INT_MAX() {
        return _CRT_INT_MAX;
    }
    private static final int _CRT_FUNCTIONS_REQUIRED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_FUNCTIONS_REQUIRED 1
     * }
     */
    public static int _CRT_FUNCTIONS_REQUIRED() {
        return _CRT_FUNCTIONS_REQUIRED;
    }
    private static final int _CRT_HAS_CXX17 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_HAS_CXX17 0
     * }
     */
    public static int _CRT_HAS_CXX17() {
        return _CRT_HAS_CXX17;
    }
    private static final int _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE 1
     * }
     */
    public static int _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE() {
        return _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE;
    }
    private static final int _CRT_BUILD_DESKTOP_APP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_BUILD_DESKTOP_APP 1
     * }
     */
    public static int _CRT_BUILD_DESKTOP_APP() {
        return _CRT_BUILD_DESKTOP_APP;
    }
    private static final int _CRT_INTERNAL_NONSTDC_NAMES = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_NONSTDC_NAMES 1
     * }
     */
    public static int _CRT_INTERNAL_NONSTDC_NAMES() {
        return _CRT_INTERNAL_NONSTDC_NAMES;
    }
    private static final int __STDC_WANT_SECURE_LIB__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_WANT_SECURE_LIB__ 1
     * }
     */
    public static int __STDC_WANT_SECURE_LIB__() {
        return __STDC_WANT_SECURE_LIB__;
    }
    private static final int _SECURECRT_FILL_BUFFER_PATTERN = (int)254L;
    /**
     * {@snippet lang=c :
     * #define _SECURECRT_FILL_BUFFER_PATTERN 254
     * }
     */
    public static int _SECURECRT_FILL_BUFFER_PATTERN() {
        return _SECURECRT_FILL_BUFFER_PATTERN;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 0
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES() {
        return _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT 0
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT() {
        return _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES 1
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES() {
        return _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY 0
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY() {
        return _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY 0
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY() {
        return _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY;
    }
    private static final int WCHAR_MIN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MIN 0
     * }
     */
    public static int WCHAR_MIN() {
        return WCHAR_MIN;
    }
    private static final int WCHAR_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MAX 65535
     * }
     */
    public static int WCHAR_MAX() {
        return WCHAR_MAX;
    }
    private static final int WINT_MIN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINT_MIN 0
     * }
     */
    public static int WINT_MIN() {
        return WINT_MIN;
    }
    private static final int WINT_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define WINT_MAX 65535
     * }
     */
    public static int WINT_MAX() {
        return WINT_MAX;
    }
    private static final int __STDC_FORMAT_MACROS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_FORMAT_MACROS 1
     * }
     */
    public static int __STDC_FORMAT_MACROS() {
        return __STDC_FORMAT_MACROS;
    }
    private static final int CHAR_BIT = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CHAR_BIT 8
     * }
     */
    public static int CHAR_BIT() {
        return CHAR_BIT;
    }
    private static final int SCHAR_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define SCHAR_MAX 127
     * }
     */
    public static int SCHAR_MAX() {
        return SCHAR_MAX;
    }
    private static final int UCHAR_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UCHAR_MAX 255
     * }
     */
    public static int UCHAR_MAX() {
        return UCHAR_MAX;
    }
    private static final int MB_LEN_MAX = (int)5L;
    /**
     * {@snippet lang=c :
     * #define MB_LEN_MAX 5
     * }
     */
    public static int MB_LEN_MAX() {
        return MB_LEN_MAX;
    }
    private static final int SHRT_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define SHRT_MAX 32767
     * }
     */
    public static int SHRT_MAX() {
        return SHRT_MAX;
    }
    private static final int USHRT_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define USHRT_MAX 65535
     * }
     */
    public static int USHRT_MAX() {
        return USHRT_MAX;
    }
    private static final int INT_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_MAX 2147483647
     * }
     */
    public static int INT_MAX() {
        return INT_MAX;
    }
    private static final int EXIT_SUCCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define EXIT_SUCCESS 0
     * }
     */
    public static int EXIT_SUCCESS() {
        return EXIT_SUCCESS;
    }
    private static final int EXIT_FAILURE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EXIT_FAILURE 1
     * }
     */
    public static int EXIT_FAILURE() {
        return EXIT_FAILURE;
    }
    private static final int _WRITE_ABORT_MSG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _WRITE_ABORT_MSG 1
     * }
     */
    public static int _WRITE_ABORT_MSG() {
        return _WRITE_ABORT_MSG;
    }
    private static final int _CALL_REPORTFAULT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _CALL_REPORTFAULT 2
     * }
     */
    public static int _CALL_REPORTFAULT() {
        return _CALL_REPORTFAULT;
    }
    private static final int _OUT_TO_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _OUT_TO_DEFAULT 0
     * }
     */
    public static int _OUT_TO_DEFAULT() {
        return _OUT_TO_DEFAULT;
    }
    private static final int _OUT_TO_STDERR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _OUT_TO_STDERR 1
     * }
     */
    public static int _OUT_TO_STDERR() {
        return _OUT_TO_STDERR;
    }
    private static final int _OUT_TO_MSGBOX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _OUT_TO_MSGBOX 2
     * }
     */
    public static int _OUT_TO_MSGBOX() {
        return _OUT_TO_MSGBOX;
    }
    private static final int _REPORT_ERRMODE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _REPORT_ERRMODE 3
     * }
     */
    public static int _REPORT_ERRMODE() {
        return _REPORT_ERRMODE;
    }
    private static final int RAND_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define RAND_MAX 32767
     * }
     */
    public static int RAND_MAX() {
        return RAND_MAX;
    }
    private static final int _MAX_PATH = (int)260L;
    /**
     * {@snippet lang=c :
     * #define _MAX_PATH 260
     * }
     */
    public static int _MAX_PATH() {
        return _MAX_PATH;
    }
    private static final int _MAX_DRIVE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _MAX_DRIVE 3
     * }
     */
    public static int _MAX_DRIVE() {
        return _MAX_DRIVE;
    }
    private static final int _MAX_DIR = (int)256L;
    /**
     * {@snippet lang=c :
     * #define _MAX_DIR 256
     * }
     */
    public static int _MAX_DIR() {
        return _MAX_DIR;
    }
    private static final int _MAX_FNAME = (int)256L;
    /**
     * {@snippet lang=c :
     * #define _MAX_FNAME 256
     * }
     */
    public static int _MAX_FNAME() {
        return _MAX_FNAME;
    }
    private static final int _MAX_EXT = (int)256L;
    /**
     * {@snippet lang=c :
     * #define _MAX_EXT 256
     * }
     */
    public static int _MAX_EXT() {
        return _MAX_EXT;
    }
    private static final int _MAX_ENV = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define _MAX_ENV 32767
     * }
     */
    public static int _MAX_ENV() {
        return _MAX_ENV;
    }
    private static final int _DOMAIN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DOMAIN 1
     * }
     */
    public static int _DOMAIN() {
        return _DOMAIN;
    }
    private static final int _SING = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _SING 2
     * }
     */
    public static int _SING() {
        return _SING;
    }
    private static final int _OVERFLOW = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _OVERFLOW 3
     * }
     */
    public static int _OVERFLOW() {
        return _OVERFLOW;
    }
    private static final int _UNDERFLOW = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _UNDERFLOW 4
     * }
     */
    public static int _UNDERFLOW() {
        return _UNDERFLOW;
    }
    private static final int _TLOSS = (int)5L;
    /**
     * {@snippet lang=c :
     * #define _TLOSS 5
     * }
     */
    public static int _TLOSS() {
        return _TLOSS;
    }
    private static final int _PLOSS = (int)6L;
    /**
     * {@snippet lang=c :
     * #define _PLOSS 6
     * }
     */
    public static int _PLOSS() {
        return _PLOSS;
    }
    private static final int _INFCODE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _INFCODE 1
     * }
     */
    public static int _INFCODE() {
        return _INFCODE;
    }
    private static final int _NANCODE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _NANCODE 2
     * }
     */
    public static int _NANCODE() {
        return _NANCODE;
    }
    private static final int FP_ZERO = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FP_ZERO 0
     * }
     */
    public static int FP_ZERO() {
        return FP_ZERO;
    }
    private static final int _C2 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _C2 1
     * }
     */
    public static int _C2() {
        return _C2;
    }
    private static final int FP_ILOGBNAN = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define FP_ILOGBNAN 2147483647
     * }
     */
    public static int FP_ILOGBNAN() {
        return FP_ILOGBNAN;
    }
    private static final int MATH_ERRNO = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MATH_ERRNO 1
     * }
     */
    public static int MATH_ERRNO() {
        return MATH_ERRNO;
    }
    private static final int MATH_ERREXCEPT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define MATH_ERREXCEPT 2
     * }
     */
    public static int MATH_ERREXCEPT() {
        return MATH_ERREXCEPT;
    }
    private static final int _FE_DIVBYZERO = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _FE_DIVBYZERO 4
     * }
     */
    public static int _FE_DIVBYZERO() {
        return _FE_DIVBYZERO;
    }
    private static final int _FE_INEXACT = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _FE_INEXACT 32
     * }
     */
    public static int _FE_INEXACT() {
        return _FE_INEXACT;
    }
    private static final int _FE_INVALID = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _FE_INVALID 1
     * }
     */
    public static int _FE_INVALID() {
        return _FE_INVALID;
    }
    private static final int _FE_OVERFLOW = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _FE_OVERFLOW 8
     * }
     */
    public static int _FE_OVERFLOW() {
        return _FE_OVERFLOW;
    }
    private static final int _FE_UNDERFLOW = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _FE_UNDERFLOW 16
     * }
     */
    public static int _FE_UNDERFLOW() {
        return _FE_UNDERFLOW;
    }
    private static final int _D0_C = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _D0_C 3
     * }
     */
    public static int _D0_C() {
        return _D0_C;
    }
    private static final int _D1_C = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _D1_C 2
     * }
     */
    public static int _D1_C() {
        return _D1_C;
    }
    private static final int _D2_C = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _D2_C 1
     * }
     */
    public static int _D2_C() {
        return _D2_C;
    }
    private static final int _D3_C = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _D3_C 0
     * }
     */
    public static int _D3_C() {
        return _D3_C;
    }
    private static final int _DBIAS = (int)1022L;
    /**
     * {@snippet lang=c :
     * #define _DBIAS 1022
     * }
     */
    public static int _DBIAS() {
        return _DBIAS;
    }
    private static final int _DOFF = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _DOFF 4
     * }
     */
    public static int _DOFF() {
        return _DOFF;
    }
    private static final int _F0_C = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _F0_C 1
     * }
     */
    public static int _F0_C() {
        return _F0_C;
    }
    private static final int _F1_C = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _F1_C 0
     * }
     */
    public static int _F1_C() {
        return _F1_C;
    }
    private static final int _FBIAS = (int)126L;
    /**
     * {@snippet lang=c :
     * #define _FBIAS 126
     * }
     */
    public static int _FBIAS() {
        return _FBIAS;
    }
    private static final int _FOFF = (int)7L;
    /**
     * {@snippet lang=c :
     * #define _FOFF 7
     * }
     */
    public static int _FOFF() {
        return _FOFF;
    }
    private static final int _FRND = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _FRND 1
     * }
     */
    public static int _FRND() {
        return _FRND;
    }
    private static final int _L0_C = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _L0_C 3
     * }
     */
    public static int _L0_C() {
        return _L0_C;
    }
    private static final int _L1_C = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _L1_C 2
     * }
     */
    public static int _L1_C() {
        return _L1_C;
    }
    private static final int _L2_C = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _L2_C 1
     * }
     */
    public static int _L2_C() {
        return _L2_C;
    }
    private static final int _L3_C = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _L3_C 0
     * }
     */
    public static int _L3_C() {
        return _L3_C;
    }
    private static final int _LBIAS = (int)1022L;
    /**
     * {@snippet lang=c :
     * #define _LBIAS 1022
     * }
     */
    public static int _LBIAS() {
        return _LBIAS;
    }
    private static final int _LOFF = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _LOFF 4
     * }
     */
    public static int _LOFF() {
        return _LOFF;
    }
    private static final int _FP_LT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _FP_LT 1
     * }
     */
    public static int _FP_LT() {
        return _FP_LT;
    }
    private static final int _FP_EQ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _FP_EQ 2
     * }
     */
    public static int _FP_EQ() {
        return _FP_EQ;
    }
    private static final int _FP_GT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _FP_GT 4
     * }
     */
    public static int _FP_GT() {
        return _FP_GT;
    }
    private static final int BUFSIZ = (int)512L;
    /**
     * {@snippet lang=c :
     * #define BUFSIZ 512
     * }
     */
    public static int BUFSIZ() {
        return BUFSIZ;
    }
    private static final int _NSTREAM_ = (int)512L;
    /**
     * {@snippet lang=c :
     * #define _NSTREAM_ 512
     * }
     */
    public static int _NSTREAM_() {
        return _NSTREAM_;
    }
    private static final int _IOB_ENTRIES = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _IOB_ENTRIES 3
     * }
     */
    public static int _IOB_ENTRIES() {
        return _IOB_ENTRIES;
    }
    private static final int _IOFBF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _IOFBF 0
     * }
     */
    public static int _IOFBF() {
        return _IOFBF;
    }
    private static final int _IOLBF = (int)64L;
    /**
     * {@snippet lang=c :
     * #define _IOLBF 64
     * }
     */
    public static int _IOLBF() {
        return _IOLBF;
    }
    private static final int _IONBF = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _IONBF 4
     * }
     */
    public static int _IONBF() {
        return _IONBF;
    }
    private static final int L_tmpnam = (int)260L;
    /**
     * {@snippet lang=c :
     * #define L_tmpnam 260
     * }
     */
    public static int L_tmpnam() {
        return L_tmpnam;
    }
    private static final int SEEK_CUR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SEEK_CUR 1
     * }
     */
    public static int SEEK_CUR() {
        return SEEK_CUR;
    }
    private static final int SEEK_END = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SEEK_END 2
     * }
     */
    public static int SEEK_END() {
        return SEEK_END;
    }
    private static final int SEEK_SET = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SEEK_SET 0
     * }
     */
    public static int SEEK_SET() {
        return SEEK_SET;
    }
    private static final int FILENAME_MAX = (int)260L;
    /**
     * {@snippet lang=c :
     * #define FILENAME_MAX 260
     * }
     */
    public static int FILENAME_MAX() {
        return FILENAME_MAX;
    }
    private static final int FOPEN_MAX = (int)20L;
    /**
     * {@snippet lang=c :
     * #define FOPEN_MAX 20
     * }
     */
    public static int FOPEN_MAX() {
        return FOPEN_MAX;
    }
    private static final int _SYS_OPEN = (int)20L;
    /**
     * {@snippet lang=c :
     * #define _SYS_OPEN 20
     * }
     */
    public static int _SYS_OPEN() {
        return _SYS_OPEN;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = Cubiomes.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef char *va_list
     * }
     */
    public static final AddressLayout va_list = Cubiomes.C_POINTER;

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void __va_start(va_list *, ...)
     * }
     */
    public static class __va_start {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                Cubiomes.C_POINTER
            );
        private static final MemorySegment ADDR = Cubiomes.findOrThrow("__va_start");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __va_start(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void __va_start(va_list *, ...)
         * }
         */
        public static __va_start makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __va_start(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__va_start", x0, x1);
                }
                 spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long long size_t
     * }
     */
    public static final OfLong size_t = Cubiomes.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = Cubiomes.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long intptr_t
     * }
     */
    public static final OfLong intptr_t = Cubiomes.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef _Bool __vcrt_bool
     * }
     */
    public static final OfBoolean __vcrt_bool = Cubiomes.C_BOOL;
    /**
     * {@snippet lang=c :
     * typedef unsigned short wchar_t
     * }
     */
    public static final OfShort wchar_t = Cubiomes.C_SHORT;

    private static class __security_init_cookie {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("__security_init_cookie");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __security_init_cookie()
     * }
     */
    public static FunctionDescriptor __security_init_cookie$descriptor() {
        return __security_init_cookie.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __security_init_cookie()
     * }
     */
    public static MethodHandle __security_init_cookie$handle() {
        return __security_init_cookie.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __security_init_cookie()
     * }
     */
    public static MemorySegment __security_init_cookie$address() {
        return __security_init_cookie.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __security_init_cookie()
     * }
     */
    public static void __security_init_cookie() {
        var mh$ = __security_init_cookie.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__security_init_cookie");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __security_check_cookie {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("__security_check_cookie");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static FunctionDescriptor __security_check_cookie$descriptor() {
        return __security_check_cookie.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static MethodHandle __security_check_cookie$handle() {
        return __security_check_cookie.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static MemorySegment __security_check_cookie$address() {
        return __security_check_cookie.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static void __security_check_cookie(long _StackCookie) {
        var mh$ = __security_check_cookie.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__security_check_cookie", _StackCookie);
            }
            mh$.invokeExact(_StackCookie);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __report_gsfailure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("__report_gsfailure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static FunctionDescriptor __report_gsfailure$descriptor() {
        return __report_gsfailure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static MethodHandle __report_gsfailure$handle() {
        return __report_gsfailure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static MemorySegment __report_gsfailure$address() {
        return __report_gsfailure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static void __report_gsfailure(long _StackCookie) {
        var mh$ = __report_gsfailure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__report_gsfailure", _StackCookie);
            }
            mh$.invokeExact(_StackCookie);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __security_cookie$constants {
        public static final OfLong LAYOUT = Cubiomes.C_LONG_LONG;
        public static final MemorySegment SEGMENT = Cubiomes.findOrThrow("__security_cookie").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static OfLong __security_cookie$layout() {
        return __security_cookie$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static MemorySegment __security_cookie$segment() {
        return __security_cookie$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static long __security_cookie() {
        return __security_cookie$constants.SEGMENT.get(__security_cookie$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static void __security_cookie(long varValue) {
        __security_cookie$constants.SEGMENT.set(__security_cookie$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef _Bool __crt_bool
     * }
     */
    public static final OfBoolean __crt_bool = Cubiomes.C_BOOL;

    private static class _invalid_parameter_noinfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_invalid_parameter_noinfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo()
     * }
     */
    public static FunctionDescriptor _invalid_parameter_noinfo$descriptor() {
        return _invalid_parameter_noinfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo()
     * }
     */
    public static MethodHandle _invalid_parameter_noinfo$handle() {
        return _invalid_parameter_noinfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo()
     * }
     */
    public static MemorySegment _invalid_parameter_noinfo$address() {
        return _invalid_parameter_noinfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo()
     * }
     */
    public static void _invalid_parameter_noinfo() {
        var mh$ = _invalid_parameter_noinfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_invalid_parameter_noinfo");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _invalid_parameter_noinfo_noreturn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_invalid_parameter_noinfo_noreturn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo_noreturn()
     * }
     */
    public static FunctionDescriptor _invalid_parameter_noinfo_noreturn$descriptor() {
        return _invalid_parameter_noinfo_noreturn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo_noreturn()
     * }
     */
    public static MethodHandle _invalid_parameter_noinfo_noreturn$handle() {
        return _invalid_parameter_noinfo_noreturn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo_noreturn()
     * }
     */
    public static MemorySegment _invalid_parameter_noinfo_noreturn$address() {
        return _invalid_parameter_noinfo_noreturn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo_noreturn()
     * }
     */
    public static void _invalid_parameter_noinfo_noreturn() {
        var mh$ = _invalid_parameter_noinfo_noreturn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_invalid_parameter_noinfo_noreturn");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _invoke_watson {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_invoke_watson");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved)
     * }
     */
    public static FunctionDescriptor _invoke_watson$descriptor() {
        return _invoke_watson.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved)
     * }
     */
    public static MethodHandle _invoke_watson$handle() {
        return _invoke_watson.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved)
     * }
     */
    public static MemorySegment _invoke_watson$address() {
        return _invoke_watson.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved)
     * }
     */
    public static void _invoke_watson(MemorySegment _Expression, MemorySegment _FunctionName, MemorySegment _FileName, int _LineNo, long _Reserved) {
        var mh$ = _invoke_watson.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_invoke_watson", _Expression, _FunctionName, _FileName, _LineNo, _Reserved);
            }
            mh$.invokeExact(_Expression, _FunctionName, _FileName, _LineNo, _Reserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int errno_t
     * }
     */
    public static final OfInt errno_t = Cubiomes.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short wint_t
     * }
     */
    public static final OfShort wint_t = Cubiomes.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short wctype_t
     * }
     */
    public static final OfShort wctype_t = Cubiomes.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef long __time32_t
     * }
     */
    public static final OfInt __time32_t = Cubiomes.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long __time64_t
     * }
     */
    public static final OfLong __time64_t = Cubiomes.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __crt_locale_pointers *_locale_t
     * }
     */
    public static final AddressLayout _locale_t = Cubiomes.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __time64_t time_t
     * }
     */
    public static final OfLong time_t = Cubiomes.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef size_t rsize_t
     * }
     */
    public static final OfLong rsize_t = Cubiomes.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int8_t
     * }
     */
    public static final OfByte int8_t = Cubiomes.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short int16_t
     * }
     */
    public static final OfShort int16_t = Cubiomes.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int int32_t
     * }
     */
    public static final OfInt int32_t = Cubiomes.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int64_t
     * }
     */
    public static final OfLong int64_t = Cubiomes.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint8_t
     * }
     */
    public static final OfByte uint8_t = Cubiomes.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short uint16_t
     * }
     */
    public static final OfShort uint16_t = Cubiomes.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint32_t
     * }
     */
    public static final OfInt uint32_t = Cubiomes.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint64_t
     * }
     */
    public static final OfLong uint64_t = Cubiomes.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int_least8_t
     * }
     */
    public static final OfByte int_least8_t = Cubiomes.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short int_least16_t
     * }
     */
    public static final OfShort int_least16_t = Cubiomes.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int int_least32_t
     * }
     */
    public static final OfInt int_least32_t = Cubiomes.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int_least64_t
     * }
     */
    public static final OfLong int_least64_t = Cubiomes.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = Cubiomes.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = Cubiomes.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = Cubiomes.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = Cubiomes.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = Cubiomes.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int int_fast16_t
     * }
     */
    public static final OfInt int_fast16_t = Cubiomes.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int int_fast32_t
     * }
     */
    public static final OfInt int_fast32_t = Cubiomes.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = Cubiomes.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = Cubiomes.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint_fast16_t
     * }
     */
    public static final OfInt uint_fast16_t = Cubiomes.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint_fast32_t
     * }
     */
    public static final OfInt uint_fast32_t = Cubiomes.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = Cubiomes.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long intmax_t
     * }
     */
    public static final OfLong intmax_t = Cubiomes.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uintmax_t
     * }
     */
    public static final OfLong uintmax_t = Cubiomes.C_LONG_LONG;

    private static class imaxabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("imaxabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intmax_t imaxabs(intmax_t _Number)
     * }
     */
    public static FunctionDescriptor imaxabs$descriptor() {
        return imaxabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intmax_t imaxabs(intmax_t _Number)
     * }
     */
    public static MethodHandle imaxabs$handle() {
        return imaxabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intmax_t imaxabs(intmax_t _Number)
     * }
     */
    public static MemorySegment imaxabs$address() {
        return imaxabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intmax_t imaxabs(intmax_t _Number)
     * }
     */
    public static long imaxabs(long _Number) {
        var mh$ = imaxabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imaxabs", _Number);
            }
            return (long)mh$.invokeExact(_Number);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class imaxdiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            _Lldiv_t.layout(),
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("imaxdiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * imaxdiv_t imaxdiv(intmax_t _Numerator, intmax_t _Denominator)
     * }
     */
    public static FunctionDescriptor imaxdiv$descriptor() {
        return imaxdiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * imaxdiv_t imaxdiv(intmax_t _Numerator, intmax_t _Denominator)
     * }
     */
    public static MethodHandle imaxdiv$handle() {
        return imaxdiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * imaxdiv_t imaxdiv(intmax_t _Numerator, intmax_t _Denominator)
     * }
     */
    public static MemorySegment imaxdiv$address() {
        return imaxdiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * imaxdiv_t imaxdiv(intmax_t _Numerator, intmax_t _Denominator)
     * }
     */
    public static MemorySegment imaxdiv(SegmentAllocator allocator, long _Numerator, long _Denominator) {
        var mh$ = imaxdiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imaxdiv", allocator, _Numerator, _Denominator);
            }
            return (MemorySegment)mh$.invokeExact(allocator, _Numerator, _Denominator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoimax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("strtoimax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intmax_t strtoimax(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor strtoimax$descriptor() {
        return strtoimax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intmax_t strtoimax(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle strtoimax$handle() {
        return strtoimax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intmax_t strtoimax(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment strtoimax$address() {
        return strtoimax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intmax_t strtoimax(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static long strtoimax(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = strtoimax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoimax", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoimax_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_strtoimax_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intmax_t _strtoimax_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtoimax_l$descriptor() {
        return _strtoimax_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intmax_t _strtoimax_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtoimax_l$handle() {
        return _strtoimax_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intmax_t _strtoimax_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtoimax_l$address() {
        return _strtoimax_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intmax_t _strtoimax_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _strtoimax_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtoimax_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoimax_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoumax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("strtoumax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uintmax_t strtoumax(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor strtoumax$descriptor() {
        return strtoumax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uintmax_t strtoumax(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle strtoumax$handle() {
        return strtoumax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uintmax_t strtoumax(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment strtoumax$address() {
        return strtoumax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uintmax_t strtoumax(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static long strtoumax(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = strtoumax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoumax", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoumax_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_strtoumax_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uintmax_t _strtoumax_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtoumax_l$descriptor() {
        return _strtoumax_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uintmax_t _strtoumax_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtoumax_l$handle() {
        return _strtoumax_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uintmax_t _strtoumax_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtoumax_l$address() {
        return _strtoumax_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uintmax_t _strtoumax_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _strtoumax_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtoumax_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoumax_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoimax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("wcstoimax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intmax_t wcstoimax(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor wcstoimax$descriptor() {
        return wcstoimax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intmax_t wcstoimax(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle wcstoimax$handle() {
        return wcstoimax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intmax_t wcstoimax(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment wcstoimax$address() {
        return wcstoimax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intmax_t wcstoimax(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static long wcstoimax(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = wcstoimax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoimax", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoimax_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wcstoimax_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intmax_t _wcstoimax_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoimax_l$descriptor() {
        return _wcstoimax_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intmax_t _wcstoimax_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoimax_l$handle() {
        return _wcstoimax_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intmax_t _wcstoimax_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstoimax_l$address() {
        return _wcstoimax_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intmax_t _wcstoimax_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _wcstoimax_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoimax_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoimax_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoumax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("wcstoumax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uintmax_t wcstoumax(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor wcstoumax$descriptor() {
        return wcstoumax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uintmax_t wcstoumax(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle wcstoumax$handle() {
        return wcstoumax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uintmax_t wcstoumax(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment wcstoumax$address() {
        return wcstoumax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uintmax_t wcstoumax(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static long wcstoumax(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = wcstoumax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoumax", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoumax_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wcstoumax_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uintmax_t _wcstoumax_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoumax_l$descriptor() {
        return _wcstoumax_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uintmax_t _wcstoumax_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoumax_l$handle() {
        return _wcstoumax_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uintmax_t _wcstoumax_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstoumax_l$address() {
        return _wcstoumax_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uintmax_t _wcstoumax_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _wcstoumax_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoumax_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoumax_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int btree18_order = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.btree18_order = 10
     * }
     */
    public static int btree18_order() {
        return btree18_order;
    }
    private static final int btree19_order = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.btree19_order = 6
     * }
     */
    public static int btree19_order() {
        return btree19_order;
    }
    private static final int btree20_order = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.btree20_order = 6
     * }
     */
    public static int btree20_order() {
        return btree20_order;
    }
    private static final int btree192_order = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.btree192_order = 10
     * }
     */
    public static int btree192_order() {
        return btree192_order;
    }
    private static final int btree21wd_order = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.btree21wd_order = 6
     * }
     */
    public static int btree21wd_order() {
        return btree21wd_order;
    }

    private static class _calloc_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_calloc_base");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_calloc_base(size_t _Count, size_t _Size)
     * }
     */
    public static FunctionDescriptor _calloc_base$descriptor() {
        return _calloc_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_calloc_base(size_t _Count, size_t _Size)
     * }
     */
    public static MethodHandle _calloc_base$handle() {
        return _calloc_base.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_calloc_base(size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment _calloc_base$address() {
        return _calloc_base.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_calloc_base(size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment _calloc_base(long _Count, long _Size) {
        var mh$ = _calloc_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_calloc_base", _Count, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Count, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *calloc(size_t _Count, size_t _Size)
     * }
     */
    public static FunctionDescriptor calloc$descriptor() {
        return calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *calloc(size_t _Count, size_t _Size)
     * }
     */
    public static MethodHandle calloc$handle() {
        return calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *calloc(size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment calloc$address() {
        return calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *calloc(size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment calloc(long _Count, long _Size) {
        var mh$ = calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("calloc", _Count, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Count, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _callnewh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_callnewh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _callnewh(size_t _Size)
     * }
     */
    public static FunctionDescriptor _callnewh$descriptor() {
        return _callnewh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _callnewh(size_t _Size)
     * }
     */
    public static MethodHandle _callnewh$handle() {
        return _callnewh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _callnewh(size_t _Size)
     * }
     */
    public static MemorySegment _callnewh$address() {
        return _callnewh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _callnewh(size_t _Size)
     * }
     */
    public static int _callnewh(long _Size) {
        var mh$ = _callnewh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_callnewh", _Size);
            }
            return (int)mh$.invokeExact(_Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _expand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_expand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_expand(void *_Block, size_t _Size)
     * }
     */
    public static FunctionDescriptor _expand$descriptor() {
        return _expand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_expand(void *_Block, size_t _Size)
     * }
     */
    public static MethodHandle _expand$handle() {
        return _expand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_expand(void *_Block, size_t _Size)
     * }
     */
    public static MemorySegment _expand$address() {
        return _expand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_expand(void *_Block, size_t _Size)
     * }
     */
    public static MemorySegment _expand(MemorySegment _Block, long _Size) {
        var mh$ = _expand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_expand", _Block, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _free_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_free_base");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _free_base(void *_Block)
     * }
     */
    public static FunctionDescriptor _free_base$descriptor() {
        return _free_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _free_base(void *_Block)
     * }
     */
    public static MethodHandle _free_base$handle() {
        return _free_base.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _free_base(void *_Block)
     * }
     */
    public static MemorySegment _free_base$address() {
        return _free_base.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _free_base(void *_Block)
     * }
     */
    public static void _free_base(MemorySegment _Block) {
        var mh$ = _free_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_free_base", _Block);
            }
            mh$.invokeExact(_Block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void free(void *_Block)
     * }
     */
    public static FunctionDescriptor free$descriptor() {
        return free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void free(void *_Block)
     * }
     */
    public static MethodHandle free$handle() {
        return free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void free(void *_Block)
     * }
     */
    public static MemorySegment free$address() {
        return free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void free(void *_Block)
     * }
     */
    public static void free(MemorySegment _Block) {
        var mh$ = free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("free", _Block);
            }
            mh$.invokeExact(_Block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _malloc_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_malloc_base");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_malloc_base(size_t _Size)
     * }
     */
    public static FunctionDescriptor _malloc_base$descriptor() {
        return _malloc_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_malloc_base(size_t _Size)
     * }
     */
    public static MethodHandle _malloc_base$handle() {
        return _malloc_base.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_malloc_base(size_t _Size)
     * }
     */
    public static MemorySegment _malloc_base$address() {
        return _malloc_base.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_malloc_base(size_t _Size)
     * }
     */
    public static MemorySegment _malloc_base(long _Size) {
        var mh$ = _malloc_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_malloc_base", _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc(size_t _Size)
     * }
     */
    public static FunctionDescriptor malloc$descriptor() {
        return malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc(size_t _Size)
     * }
     */
    public static MethodHandle malloc$handle() {
        return malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc(size_t _Size)
     * }
     */
    public static MemorySegment malloc$address() {
        return malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc(size_t _Size)
     * }
     */
    public static MemorySegment malloc(long _Size) {
        var mh$ = malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc", _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _msize_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_msize_base");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _msize_base(void *_Block)
     * }
     */
    public static FunctionDescriptor _msize_base$descriptor() {
        return _msize_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _msize_base(void *_Block)
     * }
     */
    public static MethodHandle _msize_base$handle() {
        return _msize_base.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _msize_base(void *_Block)
     * }
     */
    public static MemorySegment _msize_base$address() {
        return _msize_base.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _msize_base(void *_Block)
     * }
     */
    public static long _msize_base(MemorySegment _Block) {
        var mh$ = _msize_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_msize_base", _Block);
            }
            return (long)mh$.invokeExact(_Block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _msize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_msize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _msize(void *_Block)
     * }
     */
    public static FunctionDescriptor _msize$descriptor() {
        return _msize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _msize(void *_Block)
     * }
     */
    public static MethodHandle _msize$handle() {
        return _msize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _msize(void *_Block)
     * }
     */
    public static MemorySegment _msize$address() {
        return _msize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _msize(void *_Block)
     * }
     */
    public static long _msize(MemorySegment _Block) {
        var mh$ = _msize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_msize", _Block);
            }
            return (long)mh$.invokeExact(_Block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _realloc_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_realloc_base");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_realloc_base(void *_Block, size_t _Size)
     * }
     */
    public static FunctionDescriptor _realloc_base$descriptor() {
        return _realloc_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_realloc_base(void *_Block, size_t _Size)
     * }
     */
    public static MethodHandle _realloc_base$handle() {
        return _realloc_base.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_realloc_base(void *_Block, size_t _Size)
     * }
     */
    public static MemorySegment _realloc_base$address() {
        return _realloc_base.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_realloc_base(void *_Block, size_t _Size)
     * }
     */
    public static MemorySegment _realloc_base(MemorySegment _Block, long _Size) {
        var mh$ = _realloc_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_realloc_base", _Block, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *realloc(void *_Block, size_t _Size)
     * }
     */
    public static FunctionDescriptor realloc$descriptor() {
        return realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *realloc(void *_Block, size_t _Size)
     * }
     */
    public static MethodHandle realloc$handle() {
        return realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *realloc(void *_Block, size_t _Size)
     * }
     */
    public static MemorySegment realloc$address() {
        return realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *realloc(void *_Block, size_t _Size)
     * }
     */
    public static MemorySegment realloc(MemorySegment _Block, long _Size) {
        var mh$ = realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realloc", _Block, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _recalloc_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_recalloc_base");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_recalloc_base(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static FunctionDescriptor _recalloc_base$descriptor() {
        return _recalloc_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_recalloc_base(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static MethodHandle _recalloc_base$handle() {
        return _recalloc_base.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_recalloc_base(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment _recalloc_base$address() {
        return _recalloc_base.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_recalloc_base(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment _recalloc_base(MemorySegment _Block, long _Count, long _Size) {
        var mh$ = _recalloc_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_recalloc_base", _Block, _Count, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Count, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _recalloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_recalloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_recalloc(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static FunctionDescriptor _recalloc$descriptor() {
        return _recalloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_recalloc(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static MethodHandle _recalloc$handle() {
        return _recalloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_recalloc(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment _recalloc$address() {
        return _recalloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_recalloc(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment _recalloc(MemorySegment _Block, long _Count, long _Size) {
        var mh$ = _recalloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_recalloc", _Block, _Count, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Count, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_aligned_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _aligned_free(void *_Block)
     * }
     */
    public static FunctionDescriptor _aligned_free$descriptor() {
        return _aligned_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _aligned_free(void *_Block)
     * }
     */
    public static MethodHandle _aligned_free$handle() {
        return _aligned_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _aligned_free(void *_Block)
     * }
     */
    public static MemorySegment _aligned_free$address() {
        return _aligned_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _aligned_free(void *_Block)
     * }
     */
    public static void _aligned_free(MemorySegment _Block) {
        var mh$ = _aligned_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_free", _Block);
            }
            mh$.invokeExact(_Block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_aligned_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_aligned_malloc(size_t _Size, size_t _Alignment)
     * }
     */
    public static FunctionDescriptor _aligned_malloc$descriptor() {
        return _aligned_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_aligned_malloc(size_t _Size, size_t _Alignment)
     * }
     */
    public static MethodHandle _aligned_malloc$handle() {
        return _aligned_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_aligned_malloc(size_t _Size, size_t _Alignment)
     * }
     */
    public static MemorySegment _aligned_malloc$address() {
        return _aligned_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_aligned_malloc(size_t _Size, size_t _Alignment)
     * }
     */
    public static MemorySegment _aligned_malloc(long _Size, long _Alignment) {
        var mh$ = _aligned_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_malloc", _Size, _Alignment);
            }
            return (MemorySegment)mh$.invokeExact(_Size, _Alignment);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_offset_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_aligned_offset_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_aligned_offset_malloc(size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static FunctionDescriptor _aligned_offset_malloc$descriptor() {
        return _aligned_offset_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_aligned_offset_malloc(size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MethodHandle _aligned_offset_malloc$handle() {
        return _aligned_offset_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_aligned_offset_malloc(size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MemorySegment _aligned_offset_malloc$address() {
        return _aligned_offset_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_aligned_offset_malloc(size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MemorySegment _aligned_offset_malloc(long _Size, long _Alignment, long _Offset) {
        var mh$ = _aligned_offset_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_offset_malloc", _Size, _Alignment, _Offset);
            }
            return (MemorySegment)mh$.invokeExact(_Size, _Alignment, _Offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_msize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_aligned_msize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _aligned_msize(void *_Block, size_t _Alignment, size_t _Offset)
     * }
     */
    public static FunctionDescriptor _aligned_msize$descriptor() {
        return _aligned_msize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _aligned_msize(void *_Block, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MethodHandle _aligned_msize$handle() {
        return _aligned_msize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _aligned_msize(void *_Block, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MemorySegment _aligned_msize$address() {
        return _aligned_msize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _aligned_msize(void *_Block, size_t _Alignment, size_t _Offset)
     * }
     */
    public static long _aligned_msize(MemorySegment _Block, long _Alignment, long _Offset) {
        var mh$ = _aligned_msize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_msize", _Block, _Alignment, _Offset);
            }
            return (long)mh$.invokeExact(_Block, _Alignment, _Offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_offset_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_aligned_offset_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_aligned_offset_realloc(void *_Block, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static FunctionDescriptor _aligned_offset_realloc$descriptor() {
        return _aligned_offset_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_aligned_offset_realloc(void *_Block, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MethodHandle _aligned_offset_realloc$handle() {
        return _aligned_offset_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_aligned_offset_realloc(void *_Block, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MemorySegment _aligned_offset_realloc$address() {
        return _aligned_offset_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_aligned_offset_realloc(void *_Block, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MemorySegment _aligned_offset_realloc(MemorySegment _Block, long _Size, long _Alignment, long _Offset) {
        var mh$ = _aligned_offset_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_offset_realloc", _Block, _Size, _Alignment, _Offset);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Size, _Alignment, _Offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_offset_recalloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_aligned_offset_recalloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_aligned_offset_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static FunctionDescriptor _aligned_offset_recalloc$descriptor() {
        return _aligned_offset_recalloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_aligned_offset_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MethodHandle _aligned_offset_recalloc$handle() {
        return _aligned_offset_recalloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_aligned_offset_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MemorySegment _aligned_offset_recalloc$address() {
        return _aligned_offset_recalloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_aligned_offset_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MemorySegment _aligned_offset_recalloc(MemorySegment _Block, long _Count, long _Size, long _Alignment, long _Offset) {
        var mh$ = _aligned_offset_recalloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_offset_recalloc", _Block, _Count, _Size, _Alignment, _Offset);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Count, _Size, _Alignment, _Offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_aligned_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_aligned_realloc(void *_Block, size_t _Size, size_t _Alignment)
     * }
     */
    public static FunctionDescriptor _aligned_realloc$descriptor() {
        return _aligned_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_aligned_realloc(void *_Block, size_t _Size, size_t _Alignment)
     * }
     */
    public static MethodHandle _aligned_realloc$handle() {
        return _aligned_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_aligned_realloc(void *_Block, size_t _Size, size_t _Alignment)
     * }
     */
    public static MemorySegment _aligned_realloc$address() {
        return _aligned_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_aligned_realloc(void *_Block, size_t _Size, size_t _Alignment)
     * }
     */
    public static MemorySegment _aligned_realloc(MemorySegment _Block, long _Size, long _Alignment) {
        var mh$ = _aligned_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_realloc", _Block, _Size, _Alignment);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Size, _Alignment);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_recalloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_aligned_recalloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_aligned_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment)
     * }
     */
    public static FunctionDescriptor _aligned_recalloc$descriptor() {
        return _aligned_recalloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_aligned_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment)
     * }
     */
    public static MethodHandle _aligned_recalloc$handle() {
        return _aligned_recalloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_aligned_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment)
     * }
     */
    public static MemorySegment _aligned_recalloc$address() {
        return _aligned_recalloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_aligned_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment)
     * }
     */
    public static MemorySegment _aligned_recalloc(MemorySegment _Block, long _Count, long _Size, long _Alignment) {
        var mh$ = _aligned_recalloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_recalloc", _Block, _Count, _Size, _Alignment);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Count, _Size, _Alignment);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef double max_align_t
     * }
     */
    public static final OfDouble max_align_t = Cubiomes.C_DOUBLE;

    private static class bsearch_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("bsearch_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *bsearch_s(const void *_Key, const void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static FunctionDescriptor bsearch_s$descriptor() {
        return bsearch_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *bsearch_s(const void *_Key, const void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MethodHandle bsearch_s$handle() {
        return bsearch_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *bsearch_s(const void *_Key, const void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MemorySegment bsearch_s$address() {
        return bsearch_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *bsearch_s(const void *_Key, const void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MemorySegment bsearch_s(MemorySegment _Key, MemorySegment _Base, long _NumOfElements, long _SizeOfElements, MemorySegment _CompareFunction, MemorySegment _Context) {
        var mh$ = bsearch_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch_s", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("qsort_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort_s(void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static FunctionDescriptor qsort_s$descriptor() {
        return qsort_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort_s(void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MethodHandle qsort_s$handle() {
        return qsort_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort_s(void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MemorySegment qsort_s$address() {
        return qsort_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort_s(void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static void qsort_s(MemorySegment _Base, long _NumOfElements, long _SizeOfElements, MemorySegment _CompareFunction, MemorySegment _Context) {
        var mh$ = qsort_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort_s", _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
            }
            mh$.invokeExact(_Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("bsearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *bsearch(const void *_Key, const void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static FunctionDescriptor bsearch$descriptor() {
        return bsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *bsearch(const void *_Key, const void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MethodHandle bsearch$handle() {
        return bsearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *bsearch(const void *_Key, const void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment bsearch$address() {
        return bsearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *bsearch(const void *_Key, const void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment bsearch(MemorySegment _Key, MemorySegment _Base, long _NumOfElements, long _SizeOfElements, MemorySegment _CompareFunction) {
        var mh$ = bsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("qsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort(void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static FunctionDescriptor qsort$descriptor() {
        return qsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort(void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MethodHandle qsort$handle() {
        return qsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort(void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment qsort$address() {
        return qsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort(void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static void qsort(MemorySegment _Base, long _NumOfElements, long _SizeOfElements, MemorySegment _CompareFunction) {
        var mh$ = qsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort", _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
            }
            mh$.invokeExact(_Base, _NumOfElements, _SizeOfElements, _CompareFunction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lfind_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_lfind_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_lfind_s(const void *_Key, const void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static FunctionDescriptor _lfind_s$descriptor() {
        return _lfind_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_lfind_s(const void *_Key, const void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MethodHandle _lfind_s$handle() {
        return _lfind_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_lfind_s(const void *_Key, const void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MemorySegment _lfind_s$address() {
        return _lfind_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_lfind_s(const void *_Key, const void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MemorySegment _lfind_s(MemorySegment _Key, MemorySegment _Base, MemorySegment _NumOfElements, long _SizeOfElements, MemorySegment _CompareFunction, MemorySegment _Context) {
        var mh$ = _lfind_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lfind_s", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lfind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_lfind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static FunctionDescriptor _lfind$descriptor() {
        return _lfind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MethodHandle _lfind$handle() {
        return _lfind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment _lfind$address() {
        return _lfind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment _lfind(MemorySegment _Key, MemorySegment _Base, MemorySegment _NumOfElements, int _SizeOfElements, MemorySegment _CompareFunction) {
        var mh$ = _lfind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lfind", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lsearch_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_lsearch_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_lsearch_s(const void *_Key, void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static FunctionDescriptor _lsearch_s$descriptor() {
        return _lsearch_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_lsearch_s(const void *_Key, void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MethodHandle _lsearch_s$handle() {
        return _lsearch_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_lsearch_s(const void *_Key, void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MemorySegment _lsearch_s$address() {
        return _lsearch_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_lsearch_s(const void *_Key, void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MemorySegment _lsearch_s(MemorySegment _Key, MemorySegment _Base, MemorySegment _NumOfElements, long _SizeOfElements, MemorySegment _CompareFunction, MemorySegment _Context) {
        var mh$ = _lsearch_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lsearch_s", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_lsearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static FunctionDescriptor _lsearch$descriptor() {
        return _lsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MethodHandle _lsearch$handle() {
        return _lsearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *_lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment _lsearch$address() {
        return _lsearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *_lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment _lsearch(MemorySegment _Key, MemorySegment _Base, MemorySegment _NumOfElements, int _SizeOfElements, MemorySegment _CompareFunction) {
        var mh$ = _lsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lsearch", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lfind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("lfind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static FunctionDescriptor lfind$descriptor() {
        return lfind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MethodHandle lfind$handle() {
        return lfind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment lfind$address() {
        return lfind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment lfind(MemorySegment _Key, MemorySegment _Base, MemorySegment _NumOfElements, int _SizeOfElements, MemorySegment _CompareFunction) {
        var mh$ = lfind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lfind", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("lsearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static FunctionDescriptor lsearch$descriptor() {
        return lsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MethodHandle lsearch$handle() {
        return lsearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment lsearch$address() {
        return lsearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment lsearch(MemorySegment _Key, MemorySegment _Base, MemorySegment _NumOfElements, int _SizeOfElements, MemorySegment _CompareFunction) {
        var mh$ = lsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lsearch", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _itow_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_itow_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _itow_s(int _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _itow_s$descriptor() {
        return _itow_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _itow_s(int _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _itow_s$handle() {
        return _itow_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _itow_s(int _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _itow_s$address() {
        return _itow_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _itow_s(int _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _itow_s(int _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _itow_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_itow_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _itow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_itow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_itow(int _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _itow$descriptor() {
        return _itow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_itow(int _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _itow$handle() {
        return _itow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_itow(int _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _itow$address() {
        return _itow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_itow(int _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _itow(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _itow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_itow", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ltow_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_ltow_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ltow_s(long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ltow_s$descriptor() {
        return _ltow_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ltow_s(long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ltow_s$handle() {
        return _ltow_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ltow_s(long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _ltow_s$address() {
        return _ltow_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ltow_s(long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ltow_s(int _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ltow_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ltow_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ltow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_ltow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_ltow(long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ltow$descriptor() {
        return _ltow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_ltow(long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ltow$handle() {
        return _ltow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_ltow(long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ltow$address() {
        return _ltow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_ltow(long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ltow(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ltow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ltow", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ultow_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_ultow_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ultow_s(unsigned long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ultow_s$descriptor() {
        return _ultow_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ultow_s(unsigned long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ultow_s$handle() {
        return _ultow_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ultow_s(unsigned long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _ultow_s$address() {
        return _ultow_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ultow_s(unsigned long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ultow_s(int _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ultow_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ultow_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ultow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_ultow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_ultow(unsigned long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ultow$descriptor() {
        return _ultow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_ultow(unsigned long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ultow$handle() {
        return _ultow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_ultow(unsigned long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ultow$address() {
        return _ultow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_ultow(unsigned long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ultow(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ultow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ultow", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("wcstod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double wcstod(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static FunctionDescriptor wcstod$descriptor() {
        return wcstod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double wcstod(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static MethodHandle wcstod$handle() {
        return wcstod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double wcstod(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static MemorySegment wcstod$address() {
        return wcstod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double wcstod(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static double wcstod(MemorySegment _String, MemorySegment _EndPtr) {
        var mh$ = wcstod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstod", _String, _EndPtr);
            }
            return (double)mh$.invokeExact(_String, _EndPtr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstod_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wcstod_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _wcstod_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstod_l$descriptor() {
        return _wcstod_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _wcstod_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstod_l$handle() {
        return _wcstod_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _wcstod_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstod_l$address() {
        return _wcstod_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _wcstod_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static double _wcstod_l(MemorySegment _String, MemorySegment _EndPtr, MemorySegment _Locale) {
        var mh$ = _wcstod_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstod_l", _String, _EndPtr, _Locale);
            }
            return (double)mh$.invokeExact(_String, _EndPtr, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("wcstol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long wcstol(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor wcstol$descriptor() {
        return wcstol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long wcstol(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle wcstol$handle() {
        return wcstol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long wcstol(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment wcstol$address() {
        return wcstol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long wcstol(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static int wcstol(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = wcstol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstol", _String, _EndPtr, _Radix);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstol_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wcstol_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _wcstol_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstol_l$descriptor() {
        return _wcstol_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _wcstol_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstol_l$handle() {
        return _wcstol_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _wcstol_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstol_l$address() {
        return _wcstol_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _wcstol_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static int _wcstol_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstol_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstol_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("wcstoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long wcstoll(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor wcstoll$descriptor() {
        return wcstoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long wcstoll(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle wcstoll$handle() {
        return wcstoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long wcstoll(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment wcstoll$address() {
        return wcstoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long wcstoll(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static long wcstoll(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = wcstoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoll", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wcstoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wcstoll_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoll_l$descriptor() {
        return _wcstoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wcstoll_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoll_l$handle() {
        return _wcstoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wcstoll_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstoll_l$address() {
        return _wcstoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wcstoll_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _wcstoll_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoll_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("wcstoul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long wcstoul(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor wcstoul$descriptor() {
        return wcstoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long wcstoul(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle wcstoul$handle() {
        return wcstoul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long wcstoul(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment wcstoul$address() {
        return wcstoul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long wcstoul(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static int wcstoul(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = wcstoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoul", _String, _EndPtr, _Radix);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoul_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wcstoul_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long _wcstoul_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoul_l$descriptor() {
        return _wcstoul_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long _wcstoul_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoul_l$handle() {
        return _wcstoul_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long _wcstoul_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstoul_l$address() {
        return _wcstoul_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long _wcstoul_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static int _wcstoul_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoul_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoul_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("wcstoull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long wcstoull(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor wcstoull$descriptor() {
        return wcstoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long wcstoull(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle wcstoull$handle() {
        return wcstoull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long wcstoull(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment wcstoull$address() {
        return wcstoull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long wcstoull(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static long wcstoull(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = wcstoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoull", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoull_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wcstoull_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _wcstoull_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoull_l$descriptor() {
        return _wcstoull_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _wcstoull_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoull_l$handle() {
        return _wcstoull_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _wcstoull_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstoull_l$address() {
        return _wcstoull_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _wcstoull_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _wcstoull_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoull_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoull_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstold {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("wcstold");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double wcstold(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static FunctionDescriptor wcstold$descriptor() {
        return wcstold.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double wcstold(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static MethodHandle wcstold$handle() {
        return wcstold.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double wcstold(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static MemorySegment wcstold$address() {
        return wcstold.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double wcstold(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static double wcstold(MemorySegment _String, MemorySegment _EndPtr) {
        var mh$ = wcstold.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstold", _String, _EndPtr);
            }
            return (double)mh$.invokeExact(_String, _EndPtr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstold_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wcstold_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double _wcstold_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstold_l$descriptor() {
        return _wcstold_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double _wcstold_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstold_l$handle() {
        return _wcstold_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double _wcstold_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstold_l$address() {
        return _wcstold_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double _wcstold_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static double _wcstold_l(MemorySegment _String, MemorySegment _EndPtr, MemorySegment _Locale) {
        var mh$ = _wcstold_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstold_l", _String, _EndPtr, _Locale);
            }
            return (double)mh$.invokeExact(_String, _EndPtr, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("wcstof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float wcstof(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static FunctionDescriptor wcstof$descriptor() {
        return wcstof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float wcstof(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static MethodHandle wcstof$handle() {
        return wcstof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float wcstof(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static MemorySegment wcstof$address() {
        return wcstof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float wcstof(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static float wcstof(MemorySegment _String, MemorySegment _EndPtr) {
        var mh$ = wcstof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstof", _String, _EndPtr);
            }
            return (float)mh$.invokeExact(_String, _EndPtr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstof_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wcstof_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _wcstof_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstof_l$descriptor() {
        return _wcstof_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _wcstof_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstof_l$handle() {
        return _wcstof_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _wcstof_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstof_l$address() {
        return _wcstof_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _wcstof_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static float _wcstof_l(MemorySegment _String, MemorySegment _EndPtr, MemorySegment _Locale) {
        var mh$ = _wcstof_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstof_l", _String, _EndPtr, _Locale);
            }
            return (float)mh$.invokeExact(_String, _EndPtr, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wtof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _wtof(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wtof$descriptor() {
        return _wtof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _wtof(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wtof$handle() {
        return _wtof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _wtof(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wtof$address() {
        return _wtof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _wtof(const wchar_t *_String)
     * }
     */
    public static double _wtof(MemorySegment _String) {
        var mh$ = _wtof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtof", _String);
            }
            return (double)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtof_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wtof_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _wtof_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wtof_l$descriptor() {
        return _wtof_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _wtof_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wtof_l$handle() {
        return _wtof_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _wtof_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wtof_l$address() {
        return _wtof_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _wtof_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static double _wtof_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wtof_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtof_l", _String, _Locale);
            }
            return (double)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wtoi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wtoi(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wtoi$descriptor() {
        return _wtoi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wtoi(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wtoi$handle() {
        return _wtoi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wtoi(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wtoi$address() {
        return _wtoi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wtoi(const wchar_t *_String)
     * }
     */
    public static int _wtoi(MemorySegment _String) {
        var mh$ = _wtoi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoi", _String);
            }
            return (int)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoi_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wtoi_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wtoi_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wtoi_l$descriptor() {
        return _wtoi_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wtoi_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wtoi_l$handle() {
        return _wtoi_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wtoi_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wtoi_l$address() {
        return _wtoi_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wtoi_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static int _wtoi_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wtoi_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoi_l", _String, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wtol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _wtol(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wtol$descriptor() {
        return _wtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _wtol(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wtol$handle() {
        return _wtol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _wtol(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wtol$address() {
        return _wtol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _wtol(const wchar_t *_String)
     * }
     */
    public static int _wtol(MemorySegment _String) {
        var mh$ = _wtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtol", _String);
            }
            return (int)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtol_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wtol_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _wtol_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wtol_l$descriptor() {
        return _wtol_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _wtol_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wtol_l$handle() {
        return _wtol_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _wtol_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wtol_l$address() {
        return _wtol_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _wtol_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static int _wtol_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wtol_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtol_l", _String, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wtoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wtoll(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wtoll$descriptor() {
        return _wtoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wtoll(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wtoll$handle() {
        return _wtoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wtoll(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wtoll$address() {
        return _wtoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wtoll(const wchar_t *_String)
     * }
     */
    public static long _wtoll(MemorySegment _String) {
        var mh$ = _wtoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoll", _String);
            }
            return (long)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wtoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wtoll_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wtoll_l$descriptor() {
        return _wtoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wtoll_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wtoll_l$handle() {
        return _wtoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wtoll_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wtoll_l$address() {
        return _wtoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wtoll_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static long _wtoll_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wtoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoll_l", _String, _Locale);
            }
            return (long)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _i64tow_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_i64tow_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _i64tow_s(long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _i64tow_s$descriptor() {
        return _i64tow_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _i64tow_s(long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _i64tow_s$handle() {
        return _i64tow_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _i64tow_s(long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _i64tow_s$address() {
        return _i64tow_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _i64tow_s(long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _i64tow_s(long _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _i64tow_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_i64tow_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _i64tow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_i64tow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_i64tow(long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _i64tow$descriptor() {
        return _i64tow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_i64tow(long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _i64tow$handle() {
        return _i64tow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_i64tow(long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _i64tow$address() {
        return _i64tow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_i64tow(long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _i64tow(long _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _i64tow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_i64tow", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ui64tow_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_ui64tow_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ui64tow_s(unsigned long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ui64tow_s$descriptor() {
        return _ui64tow_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ui64tow_s(unsigned long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ui64tow_s$handle() {
        return _ui64tow_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ui64tow_s(unsigned long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _ui64tow_s$address() {
        return _ui64tow_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ui64tow_s(unsigned long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ui64tow_s(long _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ui64tow_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ui64tow_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ui64tow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_ui64tow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_ui64tow(unsigned long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ui64tow$descriptor() {
        return _ui64tow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_ui64tow(unsigned long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ui64tow$handle() {
        return _ui64tow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_ui64tow(unsigned long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ui64tow$address() {
        return _ui64tow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_ui64tow(unsigned long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ui64tow(long _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ui64tow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ui64tow", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoi64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wtoi64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wtoi64(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wtoi64$descriptor() {
        return _wtoi64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wtoi64(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wtoi64$handle() {
        return _wtoi64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wtoi64(const wchar_t *_String)
     * }
     */
    public static MemorySegment _wtoi64$address() {
        return _wtoi64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wtoi64(const wchar_t *_String)
     * }
     */
    public static long _wtoi64(MemorySegment _String) {
        var mh$ = _wtoi64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoi64", _String);
            }
            return (long)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoi64_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wtoi64_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wtoi64_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wtoi64_l$descriptor() {
        return _wtoi64_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wtoi64_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wtoi64_l$handle() {
        return _wtoi64_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wtoi64_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wtoi64_l$address() {
        return _wtoi64_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wtoi64_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static long _wtoi64_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wtoi64_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoi64_l", _String, _Locale);
            }
            return (long)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoi64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wcstoi64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wcstoi64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor _wcstoi64$descriptor() {
        return _wcstoi64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wcstoi64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle _wcstoi64$handle() {
        return _wcstoi64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wcstoi64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment _wcstoi64$address() {
        return _wcstoi64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wcstoi64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static long _wcstoi64(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = _wcstoi64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoi64", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoi64_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wcstoi64_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wcstoi64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoi64_l$descriptor() {
        return _wcstoi64_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wcstoi64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoi64_l$handle() {
        return _wcstoi64_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _wcstoi64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstoi64_l$address() {
        return _wcstoi64_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _wcstoi64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _wcstoi64_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoi64_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoi64_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoui64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wcstoui64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _wcstoui64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor _wcstoui64$descriptor() {
        return _wcstoui64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _wcstoui64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle _wcstoui64$handle() {
        return _wcstoui64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _wcstoui64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment _wcstoui64$address() {
        return _wcstoui64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _wcstoui64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static long _wcstoui64(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = _wcstoui64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoui64", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoui64_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wcstoui64_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _wcstoui64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoui64_l$descriptor() {
        return _wcstoui64_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _wcstoui64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoui64_l$handle() {
        return _wcstoui64_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _wcstoui64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstoui64_l$address() {
        return _wcstoui64_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _wcstoui64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _wcstoui64_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoui64_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoui64_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfullpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wfullpath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wfullpath(wchar_t *_Buffer, const wchar_t *_Path, size_t _BufferCount)
     * }
     */
    public static FunctionDescriptor _wfullpath$descriptor() {
        return _wfullpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wfullpath(wchar_t *_Buffer, const wchar_t *_Path, size_t _BufferCount)
     * }
     */
    public static MethodHandle _wfullpath$handle() {
        return _wfullpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wfullpath(wchar_t *_Buffer, const wchar_t *_Path, size_t _BufferCount)
     * }
     */
    public static MemorySegment _wfullpath$address() {
        return _wfullpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wfullpath(wchar_t *_Buffer, const wchar_t *_Path, size_t _BufferCount)
     * }
     */
    public static MemorySegment _wfullpath(MemorySegment _Buffer, MemorySegment _Path, long _BufferCount) {
        var mh$ = _wfullpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfullpath", _Buffer, _Path, _BufferCount);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer, _Path, _BufferCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wmakepath_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wmakepath_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wmakepath_s(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static FunctionDescriptor _wmakepath_s$descriptor() {
        return _wmakepath_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wmakepath_s(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static MethodHandle _wmakepath_s$handle() {
        return _wmakepath_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wmakepath_s(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static MemorySegment _wmakepath_s$address() {
        return _wmakepath_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wmakepath_s(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static int _wmakepath_s(MemorySegment _Buffer, long _BufferCount, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _wmakepath_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wmakepath_s", _Buffer, _BufferCount, _Drive, _Dir, _Filename, _Ext);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _Drive, _Dir, _Filename, _Ext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wmakepath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wmakepath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _wmakepath(wchar_t *_Buffer, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static FunctionDescriptor _wmakepath$descriptor() {
        return _wmakepath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _wmakepath(wchar_t *_Buffer, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static MethodHandle _wmakepath$handle() {
        return _wmakepath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _wmakepath(wchar_t *_Buffer, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static MemorySegment _wmakepath$address() {
        return _wmakepath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _wmakepath(wchar_t *_Buffer, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static void _wmakepath(MemorySegment _Buffer, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _wmakepath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wmakepath", _Buffer, _Drive, _Dir, _Filename, _Ext);
            }
            mh$.invokeExact(_Buffer, _Drive, _Dir, _Filename, _Ext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wperror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wperror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _wperror(const wchar_t *_ErrorMessage)
     * }
     */
    public static FunctionDescriptor _wperror$descriptor() {
        return _wperror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _wperror(const wchar_t *_ErrorMessage)
     * }
     */
    public static MethodHandle _wperror$handle() {
        return _wperror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _wperror(const wchar_t *_ErrorMessage)
     * }
     */
    public static MemorySegment _wperror$address() {
        return _wperror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _wperror(const wchar_t *_ErrorMessage)
     * }
     */
    public static void _wperror(MemorySegment _ErrorMessage) {
        var mh$ = _wperror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wperror", _ErrorMessage);
            }
            mh$.invokeExact(_ErrorMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wsplitpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wsplitpath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _wsplitpath(const wchar_t *_FullPath, wchar_t *_Drive, wchar_t *_Dir, wchar_t *_Filename, wchar_t *_Ext)
     * }
     */
    public static FunctionDescriptor _wsplitpath$descriptor() {
        return _wsplitpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _wsplitpath(const wchar_t *_FullPath, wchar_t *_Drive, wchar_t *_Dir, wchar_t *_Filename, wchar_t *_Ext)
     * }
     */
    public static MethodHandle _wsplitpath$handle() {
        return _wsplitpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _wsplitpath(const wchar_t *_FullPath, wchar_t *_Drive, wchar_t *_Dir, wchar_t *_Filename, wchar_t *_Ext)
     * }
     */
    public static MemorySegment _wsplitpath$address() {
        return _wsplitpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _wsplitpath(const wchar_t *_FullPath, wchar_t *_Drive, wchar_t *_Dir, wchar_t *_Filename, wchar_t *_Ext)
     * }
     */
    public static void _wsplitpath(MemorySegment _FullPath, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _wsplitpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wsplitpath", _FullPath, _Drive, _Dir, _Filename, _Ext);
            }
            mh$.invokeExact(_FullPath, _Drive, _Dir, _Filename, _Ext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wsplitpath_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wsplitpath_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wsplitpath_s(const wchar_t *_FullPath, wchar_t *_Drive, size_t _DriveCount, wchar_t *_Dir, size_t _DirCount, wchar_t *_Filename, size_t _FilenameCount, wchar_t *_Ext, size_t _ExtCount)
     * }
     */
    public static FunctionDescriptor _wsplitpath_s$descriptor() {
        return _wsplitpath_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wsplitpath_s(const wchar_t *_FullPath, wchar_t *_Drive, size_t _DriveCount, wchar_t *_Dir, size_t _DirCount, wchar_t *_Filename, size_t _FilenameCount, wchar_t *_Ext, size_t _ExtCount)
     * }
     */
    public static MethodHandle _wsplitpath_s$handle() {
        return _wsplitpath_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wsplitpath_s(const wchar_t *_FullPath, wchar_t *_Drive, size_t _DriveCount, wchar_t *_Dir, size_t _DirCount, wchar_t *_Filename, size_t _FilenameCount, wchar_t *_Ext, size_t _ExtCount)
     * }
     */
    public static MemorySegment _wsplitpath_s$address() {
        return _wsplitpath_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wsplitpath_s(const wchar_t *_FullPath, wchar_t *_Drive, size_t _DriveCount, wchar_t *_Dir, size_t _DirCount, wchar_t *_Filename, size_t _FilenameCount, wchar_t *_Ext, size_t _ExtCount)
     * }
     */
    public static int _wsplitpath_s(MemorySegment _FullPath, MemorySegment _Drive, long _DriveCount, MemorySegment _Dir, long _DirCount, MemorySegment _Filename, long _FilenameCount, MemorySegment _Ext, long _ExtCount) {
        var mh$ = _wsplitpath_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wsplitpath_s", _FullPath, _Drive, _DriveCount, _Dir, _DirCount, _Filename, _FilenameCount, _Ext, _ExtCount);
            }
            return (int)mh$.invokeExact(_FullPath, _Drive, _DriveCount, _Dir, _DirCount, _Filename, _FilenameCount, _Ext, _ExtCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wdupenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wdupenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wdupenv_s(wchar_t **_Buffer, size_t *_BufferCount, const wchar_t *_VarName)
     * }
     */
    public static FunctionDescriptor _wdupenv_s$descriptor() {
        return _wdupenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wdupenv_s(wchar_t **_Buffer, size_t *_BufferCount, const wchar_t *_VarName)
     * }
     */
    public static MethodHandle _wdupenv_s$handle() {
        return _wdupenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wdupenv_s(wchar_t **_Buffer, size_t *_BufferCount, const wchar_t *_VarName)
     * }
     */
    public static MemorySegment _wdupenv_s$address() {
        return _wdupenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wdupenv_s(wchar_t **_Buffer, size_t *_BufferCount, const wchar_t *_VarName)
     * }
     */
    public static int _wdupenv_s(MemorySegment _Buffer, MemorySegment _BufferCount, MemorySegment _VarName) {
        var mh$ = _wdupenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wdupenv_s", _Buffer, _BufferCount, _VarName);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _VarName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wgetenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wgetenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wgetenv(const wchar_t *_VarName)
     * }
     */
    public static FunctionDescriptor _wgetenv$descriptor() {
        return _wgetenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wgetenv(const wchar_t *_VarName)
     * }
     */
    public static MethodHandle _wgetenv$handle() {
        return _wgetenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wgetenv(const wchar_t *_VarName)
     * }
     */
    public static MemorySegment _wgetenv$address() {
        return _wgetenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wgetenv(const wchar_t *_VarName)
     * }
     */
    public static MemorySegment _wgetenv(MemorySegment _VarName) {
        var mh$ = _wgetenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wgetenv", _VarName);
            }
            return (MemorySegment)mh$.invokeExact(_VarName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wgetenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wgetenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wgetenv_s(size_t *_RequiredCount, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_VarName)
     * }
     */
    public static FunctionDescriptor _wgetenv_s$descriptor() {
        return _wgetenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wgetenv_s(size_t *_RequiredCount, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_VarName)
     * }
     */
    public static MethodHandle _wgetenv_s$handle() {
        return _wgetenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wgetenv_s(size_t *_RequiredCount, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_VarName)
     * }
     */
    public static MemorySegment _wgetenv_s$address() {
        return _wgetenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wgetenv_s(size_t *_RequiredCount, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_VarName)
     * }
     */
    public static int _wgetenv_s(MemorySegment _RequiredCount, MemorySegment _Buffer, long _BufferCount, MemorySegment _VarName) {
        var mh$ = _wgetenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wgetenv_s", _RequiredCount, _Buffer, _BufferCount, _VarName);
            }
            return (int)mh$.invokeExact(_RequiredCount, _Buffer, _BufferCount, _VarName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wputenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wputenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wputenv(const wchar_t *_EnvString)
     * }
     */
    public static FunctionDescriptor _wputenv$descriptor() {
        return _wputenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wputenv(const wchar_t *_EnvString)
     * }
     */
    public static MethodHandle _wputenv$handle() {
        return _wputenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wputenv(const wchar_t *_EnvString)
     * }
     */
    public static MemorySegment _wputenv$address() {
        return _wputenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wputenv(const wchar_t *_EnvString)
     * }
     */
    public static int _wputenv(MemorySegment _EnvString) {
        var mh$ = _wputenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wputenv", _EnvString);
            }
            return (int)mh$.invokeExact(_EnvString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wputenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wputenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wputenv_s(const wchar_t *_Name, const wchar_t *_Value)
     * }
     */
    public static FunctionDescriptor _wputenv_s$descriptor() {
        return _wputenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wputenv_s(const wchar_t *_Name, const wchar_t *_Value)
     * }
     */
    public static MethodHandle _wputenv_s$handle() {
        return _wputenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wputenv_s(const wchar_t *_Name, const wchar_t *_Value)
     * }
     */
    public static MemorySegment _wputenv_s$address() {
        return _wputenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wputenv_s(const wchar_t *_Name, const wchar_t *_Value)
     * }
     */
    public static int _wputenv_s(MemorySegment _Name, MemorySegment _Value) {
        var mh$ = _wputenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wputenv_s", _Name, _Value);
            }
            return (int)mh$.invokeExact(_Name, _Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wsearchenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wsearchenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wsearchenv_s(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static FunctionDescriptor _wsearchenv_s$descriptor() {
        return _wsearchenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wsearchenv_s(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static MethodHandle _wsearchenv_s$handle() {
        return _wsearchenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wsearchenv_s(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static MemorySegment _wsearchenv_s$address() {
        return _wsearchenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wsearchenv_s(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static int _wsearchenv_s(MemorySegment _Filename, MemorySegment _VarName, MemorySegment _Buffer, long _BufferCount) {
        var mh$ = _wsearchenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wsearchenv_s", _Filename, _VarName, _Buffer, _BufferCount);
            }
            return (int)mh$.invokeExact(_Filename, _VarName, _Buffer, _BufferCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wsearchenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wsearchenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _wsearchenv(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_ResultPath)
     * }
     */
    public static FunctionDescriptor _wsearchenv$descriptor() {
        return _wsearchenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _wsearchenv(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_ResultPath)
     * }
     */
    public static MethodHandle _wsearchenv$handle() {
        return _wsearchenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _wsearchenv(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_ResultPath)
     * }
     */
    public static MemorySegment _wsearchenv$address() {
        return _wsearchenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _wsearchenv(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_ResultPath)
     * }
     */
    public static void _wsearchenv(MemorySegment _Filename, MemorySegment _VarName, MemorySegment _ResultPath) {
        var mh$ = _wsearchenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wsearchenv", _Filename, _VarName, _ResultPath);
            }
            mh$.invokeExact(_Filename, _VarName, _ResultPath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wsystem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wsystem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wsystem(const wchar_t *_Command)
     * }
     */
    public static FunctionDescriptor _wsystem$descriptor() {
        return _wsystem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wsystem(const wchar_t *_Command)
     * }
     */
    public static MethodHandle _wsystem$handle() {
        return _wsystem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wsystem(const wchar_t *_Command)
     * }
     */
    public static MemorySegment _wsystem$address() {
        return _wsystem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wsystem(const wchar_t *_Command)
     * }
     */
    public static int _wsystem(MemorySegment _Command) {
        var mh$ = _wsystem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wsystem", _Command);
            }
            return (int)mh$.invokeExact(_Command);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _swab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_swab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static FunctionDescriptor _swab$descriptor() {
        return _swab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static MethodHandle _swab$handle() {
        return _swab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static MemorySegment _swab$address() {
        return _swab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static void _swab(MemorySegment _Buf1, MemorySegment _Buf2, int _SizeInBytes) {
        var mh$ = _swab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_swab", _Buf1, _Buf2, _SizeInBytes);
            }
            mh$.invokeExact(_Buf1, _Buf2, _SizeInBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void exit(int _Code)
     * }
     */
    public static FunctionDescriptor exit$descriptor() {
        return exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void exit(int _Code)
     * }
     */
    public static MethodHandle exit$handle() {
        return exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void exit(int _Code)
     * }
     */
    public static MemorySegment exit$address() {
        return exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void exit(int _Code)
     * }
     */
    public static void exit(int _Code) {
        var mh$ = exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exit", _Code);
            }
            mh$.invokeExact(_Code);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _exit(int _Code)
     * }
     */
    public static FunctionDescriptor _exit$descriptor() {
        return _exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _exit(int _Code)
     * }
     */
    public static MethodHandle _exit$handle() {
        return _exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _exit(int _Code)
     * }
     */
    public static MemorySegment _exit$address() {
        return _exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _exit(int _Code)
     * }
     */
    public static void _exit(int _Code) {
        var mh$ = _exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_exit", _Code);
            }
            mh$.invokeExact(_Code);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Exit$ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_Exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Exit(int _Code)
     * }
     */
    public static FunctionDescriptor _Exit$descriptor() {
        return _Exit$.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Exit(int _Code)
     * }
     */
    public static MethodHandle _Exit$handle() {
        return _Exit$.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Exit(int _Code)
     * }
     */
    public static MemorySegment _Exit$address() {
        return _Exit$.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Exit(int _Code)
     * }
     */
    public static void _Exit(int _Code) {
        var mh$ = _Exit$.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Exit", _Code);
            }
            mh$.invokeExact(_Code);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void quick_exit(int _Code)
     * }
     */
    public static FunctionDescriptor quick_exit$descriptor() {
        return quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void quick_exit(int _Code)
     * }
     */
    public static MethodHandle quick_exit$handle() {
        return quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void quick_exit(int _Code)
     * }
     */
    public static MemorySegment quick_exit$address() {
        return quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void quick_exit(int _Code)
     * }
     */
    public static void quick_exit(int _Code) {
        var mh$ = quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("quick_exit", _Code);
            }
            mh$.invokeExact(_Code);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("abort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static FunctionDescriptor abort$descriptor() {
        return abort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static MethodHandle abort$handle() {
        return abort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static MemorySegment abort$address() {
        return abort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static void abort() {
        var mh$ = abort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abort");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_abort_behavior {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_set_abort_behavior");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int _set_abort_behavior(unsigned int _Flags, unsigned int _Mask)
     * }
     */
    public static FunctionDescriptor _set_abort_behavior$descriptor() {
        return _set_abort_behavior.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int _set_abort_behavior(unsigned int _Flags, unsigned int _Mask)
     * }
     */
    public static MethodHandle _set_abort_behavior$handle() {
        return _set_abort_behavior.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int _set_abort_behavior(unsigned int _Flags, unsigned int _Mask)
     * }
     */
    public static MemorySegment _set_abort_behavior$address() {
        return _set_abort_behavior.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int _set_abort_behavior(unsigned int _Flags, unsigned int _Mask)
     * }
     */
    public static int _set_abort_behavior(int _Flags, int _Mask) {
        var mh$ = _set_abort_behavior.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_abort_behavior", _Flags, _Mask);
            }
            return (int)mh$.invokeExact(_Flags, _Mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("atexit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atexit(void (*)(void) __attribute__((cdecl)))
     * }
     */
    public static FunctionDescriptor atexit$descriptor() {
        return atexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atexit(void (*)(void) __attribute__((cdecl)))
     * }
     */
    public static MethodHandle atexit$handle() {
        return atexit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atexit(void (*)(void) __attribute__((cdecl)))
     * }
     */
    public static MemorySegment atexit$address() {
        return atexit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atexit(void (*)(void) __attribute__((cdecl)))
     * }
     */
    public static int atexit(MemorySegment x0) {
        var mh$ = atexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _onexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_onexit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _onexit_t _onexit(_onexit_t _Func)
     * }
     */
    public static FunctionDescriptor _onexit$descriptor() {
        return _onexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _onexit_t _onexit(_onexit_t _Func)
     * }
     */
    public static MethodHandle _onexit$handle() {
        return _onexit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _onexit_t _onexit(_onexit_t _Func)
     * }
     */
    public static MemorySegment _onexit$address() {
        return _onexit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _onexit_t _onexit(_onexit_t _Func)
     * }
     */
    public static MemorySegment _onexit(MemorySegment _Func) {
        var mh$ = _onexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_onexit", _Func);
            }
            return (MemorySegment)mh$.invokeExact(_Func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class at_quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("at_quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void) __attribute__((cdecl)))
     * }
     */
    public static FunctionDescriptor at_quick_exit$descriptor() {
        return at_quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void) __attribute__((cdecl)))
     * }
     */
    public static MethodHandle at_quick_exit$handle() {
        return at_quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void) __attribute__((cdecl)))
     * }
     */
    public static MemorySegment at_quick_exit$address() {
        return at_quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void) __attribute__((cdecl)))
     * }
     */
    public static int at_quick_exit(MemorySegment x0) {
        var mh$ = at_quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("at_quick_exit", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_purecall_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_set_purecall_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _purecall_handler _set_purecall_handler(_purecall_handler _Handler)
     * }
     */
    public static FunctionDescriptor _set_purecall_handler$descriptor() {
        return _set_purecall_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _purecall_handler _set_purecall_handler(_purecall_handler _Handler)
     * }
     */
    public static MethodHandle _set_purecall_handler$handle() {
        return _set_purecall_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _purecall_handler _set_purecall_handler(_purecall_handler _Handler)
     * }
     */
    public static MemorySegment _set_purecall_handler$address() {
        return _set_purecall_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _purecall_handler _set_purecall_handler(_purecall_handler _Handler)
     * }
     */
    public static MemorySegment _set_purecall_handler(MemorySegment _Handler) {
        var mh$ = _set_purecall_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_purecall_handler", _Handler);
            }
            return (MemorySegment)mh$.invokeExact(_Handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_purecall_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER    );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_get_purecall_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _purecall_handler _get_purecall_handler()
     * }
     */
    public static FunctionDescriptor _get_purecall_handler$descriptor() {
        return _get_purecall_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _purecall_handler _get_purecall_handler()
     * }
     */
    public static MethodHandle _get_purecall_handler$handle() {
        return _get_purecall_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _purecall_handler _get_purecall_handler()
     * }
     */
    public static MemorySegment _get_purecall_handler$address() {
        return _get_purecall_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _purecall_handler _get_purecall_handler()
     * }
     */
    public static MemorySegment _get_purecall_handler() {
        var mh$ = _get_purecall_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_purecall_handler");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_invalid_parameter_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_set_invalid_parameter_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static FunctionDescriptor _set_invalid_parameter_handler$descriptor() {
        return _set_invalid_parameter_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static MethodHandle _set_invalid_parameter_handler$handle() {
        return _set_invalid_parameter_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static MemorySegment _set_invalid_parameter_handler$address() {
        return _set_invalid_parameter_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static MemorySegment _set_invalid_parameter_handler(MemorySegment _Handler) {
        var mh$ = _set_invalid_parameter_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_invalid_parameter_handler", _Handler);
            }
            return (MemorySegment)mh$.invokeExact(_Handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_invalid_parameter_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER    );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_get_invalid_parameter_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_invalid_parameter_handler()
     * }
     */
    public static FunctionDescriptor _get_invalid_parameter_handler$descriptor() {
        return _get_invalid_parameter_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_invalid_parameter_handler()
     * }
     */
    public static MethodHandle _get_invalid_parameter_handler$handle() {
        return _get_invalid_parameter_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_invalid_parameter_handler()
     * }
     */
    public static MemorySegment _get_invalid_parameter_handler$address() {
        return _get_invalid_parameter_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_invalid_parameter_handler()
     * }
     */
    public static MemorySegment _get_invalid_parameter_handler() {
        var mh$ = _get_invalid_parameter_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_invalid_parameter_handler");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_thread_local_invalid_parameter_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_set_thread_local_invalid_parameter_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_thread_local_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static FunctionDescriptor _set_thread_local_invalid_parameter_handler$descriptor() {
        return _set_thread_local_invalid_parameter_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_thread_local_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static MethodHandle _set_thread_local_invalid_parameter_handler$handle() {
        return _set_thread_local_invalid_parameter_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_thread_local_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static MemorySegment _set_thread_local_invalid_parameter_handler$address() {
        return _set_thread_local_invalid_parameter_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_thread_local_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static MemorySegment _set_thread_local_invalid_parameter_handler(MemorySegment _Handler) {
        var mh$ = _set_thread_local_invalid_parameter_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_thread_local_invalid_parameter_handler", _Handler);
            }
            return (MemorySegment)mh$.invokeExact(_Handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_thread_local_invalid_parameter_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER    );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_get_thread_local_invalid_parameter_handler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_thread_local_invalid_parameter_handler()
     * }
     */
    public static FunctionDescriptor _get_thread_local_invalid_parameter_handler$descriptor() {
        return _get_thread_local_invalid_parameter_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_thread_local_invalid_parameter_handler()
     * }
     */
    public static MethodHandle _get_thread_local_invalid_parameter_handler$handle() {
        return _get_thread_local_invalid_parameter_handler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_thread_local_invalid_parameter_handler()
     * }
     */
    public static MemorySegment _get_thread_local_invalid_parameter_handler$address() {
        return _get_thread_local_invalid_parameter_handler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_thread_local_invalid_parameter_handler()
     * }
     */
    public static MemorySegment _get_thread_local_invalid_parameter_handler() {
        var mh$ = _get_thread_local_invalid_parameter_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_thread_local_invalid_parameter_handler");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_error_mode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_set_error_mode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _set_error_mode(int _Mode)
     * }
     */
    public static FunctionDescriptor _set_error_mode$descriptor() {
        return _set_error_mode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _set_error_mode(int _Mode)
     * }
     */
    public static MethodHandle _set_error_mode$handle() {
        return _set_error_mode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _set_error_mode(int _Mode)
     * }
     */
    public static MemorySegment _set_error_mode$address() {
        return _set_error_mode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _set_error_mode(int _Mode)
     * }
     */
    public static int _set_error_mode(int _Mode) {
        var mh$ = _set_error_mode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_error_mode", _Mode);
            }
            return (int)mh$.invokeExact(_Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _errno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER    );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_errno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *_errno()
     * }
     */
    public static FunctionDescriptor _errno$descriptor() {
        return _errno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *_errno()
     * }
     */
    public static MethodHandle _errno$handle() {
        return _errno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *_errno()
     * }
     */
    public static MemorySegment _errno$address() {
        return _errno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *_errno()
     * }
     */
    public static MemorySegment _errno() {
        var mh$ = _errno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_errno");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_errno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_set_errno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _set_errno(int _Value)
     * }
     */
    public static FunctionDescriptor _set_errno$descriptor() {
        return _set_errno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _set_errno(int _Value)
     * }
     */
    public static MethodHandle _set_errno$handle() {
        return _set_errno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _set_errno(int _Value)
     * }
     */
    public static MemorySegment _set_errno$address() {
        return _set_errno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _set_errno(int _Value)
     * }
     */
    public static int _set_errno(int _Value) {
        var mh$ = _set_errno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_errno", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_errno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_get_errno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_errno(int *_Value)
     * }
     */
    public static FunctionDescriptor _get_errno$descriptor() {
        return _get_errno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_errno(int *_Value)
     * }
     */
    public static MethodHandle _get_errno$handle() {
        return _get_errno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_errno(int *_Value)
     * }
     */
    public static MemorySegment _get_errno$address() {
        return _get_errno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_errno(int *_Value)
     * }
     */
    public static int _get_errno(MemorySegment _Value) {
        var mh$ = _get_errno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_errno", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __doserrno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER    );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("__doserrno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long *__doserrno()
     * }
     */
    public static FunctionDescriptor __doserrno$descriptor() {
        return __doserrno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long *__doserrno()
     * }
     */
    public static MethodHandle __doserrno$handle() {
        return __doserrno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long *__doserrno()
     * }
     */
    public static MemorySegment __doserrno$address() {
        return __doserrno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long *__doserrno()
     * }
     */
    public static MemorySegment __doserrno() {
        var mh$ = __doserrno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__doserrno");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_doserrno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_set_doserrno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _set_doserrno(unsigned long _Value)
     * }
     */
    public static FunctionDescriptor _set_doserrno$descriptor() {
        return _set_doserrno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _set_doserrno(unsigned long _Value)
     * }
     */
    public static MethodHandle _set_doserrno$handle() {
        return _set_doserrno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _set_doserrno(unsigned long _Value)
     * }
     */
    public static MemorySegment _set_doserrno$address() {
        return _set_doserrno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _set_doserrno(unsigned long _Value)
     * }
     */
    public static int _set_doserrno(int _Value) {
        var mh$ = _set_doserrno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_doserrno", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_doserrno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_get_doserrno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_doserrno(unsigned long *_Value)
     * }
     */
    public static FunctionDescriptor _get_doserrno$descriptor() {
        return _get_doserrno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_doserrno(unsigned long *_Value)
     * }
     */
    public static MethodHandle _get_doserrno$handle() {
        return _get_doserrno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_doserrno(unsigned long *_Value)
     * }
     */
    public static MemorySegment _get_doserrno$address() {
        return _get_doserrno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_doserrno(unsigned long *_Value)
     * }
     */
    public static int _get_doserrno(MemorySegment _Value) {
        var mh$ = _get_doserrno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_doserrno", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sys_errlist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER    );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("__sys_errlist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char **__sys_errlist()
     * }
     */
    public static FunctionDescriptor __sys_errlist$descriptor() {
        return __sys_errlist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char **__sys_errlist()
     * }
     */
    public static MethodHandle __sys_errlist$handle() {
        return __sys_errlist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char **__sys_errlist()
     * }
     */
    public static MemorySegment __sys_errlist$address() {
        return __sys_errlist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char **__sys_errlist()
     * }
     */
    public static MemorySegment __sys_errlist() {
        var mh$ = __sys_errlist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sys_errlist");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sys_nerr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER    );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("__sys_nerr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *__sys_nerr()
     * }
     */
    public static FunctionDescriptor __sys_nerr$descriptor() {
        return __sys_nerr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *__sys_nerr()
     * }
     */
    public static MethodHandle __sys_nerr$handle() {
        return __sys_nerr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *__sys_nerr()
     * }
     */
    public static MemorySegment __sys_nerr$address() {
        return __sys_nerr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *__sys_nerr()
     * }
     */
    public static MemorySegment __sys_nerr() {
        var mh$ = __sys_nerr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sys_nerr");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class perror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("perror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void perror(const char *_ErrMsg)
     * }
     */
    public static FunctionDescriptor perror$descriptor() {
        return perror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void perror(const char *_ErrMsg)
     * }
     */
    public static MethodHandle perror$handle() {
        return perror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void perror(const char *_ErrMsg)
     * }
     */
    public static MemorySegment perror$address() {
        return perror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void perror(const char *_ErrMsg)
     * }
     */
    public static void perror(MemorySegment _ErrMsg) {
        var mh$ = perror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("perror", _ErrMsg);
            }
            mh$.invokeExact(_ErrMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p__pgmptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER    );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("__p__pgmptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char **__p__pgmptr()
     * }
     */
    public static FunctionDescriptor __p__pgmptr$descriptor() {
        return __p__pgmptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char **__p__pgmptr()
     * }
     */
    public static MethodHandle __p__pgmptr$handle() {
        return __p__pgmptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char **__p__pgmptr()
     * }
     */
    public static MemorySegment __p__pgmptr$address() {
        return __p__pgmptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char **__p__pgmptr()
     * }
     */
    public static MemorySegment __p__pgmptr() {
        var mh$ = __p__pgmptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p__pgmptr");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p__wpgmptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER    );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("__p__wpgmptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t **__p__wpgmptr()
     * }
     */
    public static FunctionDescriptor __p__wpgmptr$descriptor() {
        return __p__wpgmptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t **__p__wpgmptr()
     * }
     */
    public static MethodHandle __p__wpgmptr$handle() {
        return __p__wpgmptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t **__p__wpgmptr()
     * }
     */
    public static MemorySegment __p__wpgmptr$address() {
        return __p__wpgmptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t **__p__wpgmptr()
     * }
     */
    public static MemorySegment __p__wpgmptr() {
        var mh$ = __p__wpgmptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p__wpgmptr");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p__fmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER    );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("__p__fmode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *__p__fmode()
     * }
     */
    public static FunctionDescriptor __p__fmode$descriptor() {
        return __p__fmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *__p__fmode()
     * }
     */
    public static MethodHandle __p__fmode$handle() {
        return __p__fmode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *__p__fmode()
     * }
     */
    public static MemorySegment __p__fmode$address() {
        return __p__fmode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *__p__fmode()
     * }
     */
    public static MemorySegment __p__fmode() {
        var mh$ = __p__fmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p__fmode");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_pgmptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_get_pgmptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_pgmptr(char **_Value)
     * }
     */
    public static FunctionDescriptor _get_pgmptr$descriptor() {
        return _get_pgmptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_pgmptr(char **_Value)
     * }
     */
    public static MethodHandle _get_pgmptr$handle() {
        return _get_pgmptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_pgmptr(char **_Value)
     * }
     */
    public static MemorySegment _get_pgmptr$address() {
        return _get_pgmptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_pgmptr(char **_Value)
     * }
     */
    public static int _get_pgmptr(MemorySegment _Value) {
        var mh$ = _get_pgmptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_pgmptr", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_wpgmptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_get_wpgmptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_wpgmptr(wchar_t **_Value)
     * }
     */
    public static FunctionDescriptor _get_wpgmptr$descriptor() {
        return _get_wpgmptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_wpgmptr(wchar_t **_Value)
     * }
     */
    public static MethodHandle _get_wpgmptr$handle() {
        return _get_wpgmptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_wpgmptr(wchar_t **_Value)
     * }
     */
    public static MemorySegment _get_wpgmptr$address() {
        return _get_wpgmptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_wpgmptr(wchar_t **_Value)
     * }
     */
    public static int _get_wpgmptr(MemorySegment _Value) {
        var mh$ = _get_wpgmptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_wpgmptr", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_fmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_set_fmode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _set_fmode(int _Mode)
     * }
     */
    public static FunctionDescriptor _set_fmode$descriptor() {
        return _set_fmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _set_fmode(int _Mode)
     * }
     */
    public static MethodHandle _set_fmode$handle() {
        return _set_fmode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _set_fmode(int _Mode)
     * }
     */
    public static MemorySegment _set_fmode$address() {
        return _set_fmode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _set_fmode(int _Mode)
     * }
     */
    public static int _set_fmode(int _Mode) {
        var mh$ = _set_fmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_fmode", _Mode);
            }
            return (int)mh$.invokeExact(_Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_fmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_get_fmode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_fmode(int *_PMode)
     * }
     */
    public static FunctionDescriptor _get_fmode$descriptor() {
        return _get_fmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_fmode(int *_PMode)
     * }
     */
    public static MethodHandle _get_fmode$handle() {
        return _get_fmode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_fmode(int *_PMode)
     * }
     */
    public static MemorySegment _get_fmode$address() {
        return _get_fmode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_fmode(int *_PMode)
     * }
     */
    public static int _get_fmode(MemorySegment _PMode) {
        var mh$ = _get_fmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_fmode", _PMode);
            }
            return (int)mh$.invokeExact(_PMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("abs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int abs(int _Number)
     * }
     */
    public static FunctionDescriptor abs$descriptor() {
        return abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int abs(int _Number)
     * }
     */
    public static MethodHandle abs$handle() {
        return abs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int abs(int _Number)
     * }
     */
    public static MemorySegment abs$address() {
        return abs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int abs(int _Number)
     * }
     */
    public static int abs(int _Number) {
        var mh$ = abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abs", _Number);
            }
            return (int)mh$.invokeExact(_Number);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class labs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG,
            Cubiomes.C_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("labs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long labs(long _Number)
     * }
     */
    public static FunctionDescriptor labs$descriptor() {
        return labs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long labs(long _Number)
     * }
     */
    public static MethodHandle labs$handle() {
        return labs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long labs(long _Number)
     * }
     */
    public static MemorySegment labs$address() {
        return labs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long labs(long _Number)
     * }
     */
    public static int labs(int _Number) {
        var mh$ = labs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("labs", _Number);
            }
            return (int)mh$.invokeExact(_Number);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("llabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llabs(long long _Number)
     * }
     */
    public static FunctionDescriptor llabs$descriptor() {
        return llabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llabs(long long _Number)
     * }
     */
    public static MethodHandle llabs$handle() {
        return llabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llabs(long long _Number)
     * }
     */
    public static MemorySegment llabs$address() {
        return llabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llabs(long long _Number)
     * }
     */
    public static long llabs(long _Number) {
        var mh$ = llabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llabs", _Number);
            }
            return (long)mh$.invokeExact(_Number);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _abs64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_abs64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _abs64(long long _Number)
     * }
     */
    public static FunctionDescriptor _abs64$descriptor() {
        return _abs64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _abs64(long long _Number)
     * }
     */
    public static MethodHandle _abs64$handle() {
        return _abs64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _abs64(long long _Number)
     * }
     */
    public static MemorySegment _abs64$address() {
        return _abs64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _abs64(long long _Number)
     * }
     */
    public static long _abs64(long _Number) {
        var mh$ = _abs64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_abs64", _Number);
            }
            return (long)mh$.invokeExact(_Number);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _byteswap_ushort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_SHORT,
            Cubiomes.C_SHORT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_byteswap_ushort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned short _byteswap_ushort(unsigned short _Number)
     * }
     */
    public static FunctionDescriptor _byteswap_ushort$descriptor() {
        return _byteswap_ushort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned short _byteswap_ushort(unsigned short _Number)
     * }
     */
    public static MethodHandle _byteswap_ushort$handle() {
        return _byteswap_ushort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned short _byteswap_ushort(unsigned short _Number)
     * }
     */
    public static MemorySegment _byteswap_ushort$address() {
        return _byteswap_ushort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned short _byteswap_ushort(unsigned short _Number)
     * }
     */
    public static short _byteswap_ushort(short _Number) {
        var mh$ = _byteswap_ushort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_byteswap_ushort", _Number);
            }
            return (short)mh$.invokeExact(_Number);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _byteswap_ulong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG,
            Cubiomes.C_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_byteswap_ulong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long _byteswap_ulong(unsigned long _Number)
     * }
     */
    public static FunctionDescriptor _byteswap_ulong$descriptor() {
        return _byteswap_ulong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long _byteswap_ulong(unsigned long _Number)
     * }
     */
    public static MethodHandle _byteswap_ulong$handle() {
        return _byteswap_ulong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long _byteswap_ulong(unsigned long _Number)
     * }
     */
    public static MemorySegment _byteswap_ulong$address() {
        return _byteswap_ulong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long _byteswap_ulong(unsigned long _Number)
     * }
     */
    public static int _byteswap_ulong(int _Number) {
        var mh$ = _byteswap_ulong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_byteswap_ulong", _Number);
            }
            return (int)mh$.invokeExact(_Number);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _byteswap_uint64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_byteswap_uint64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _byteswap_uint64(unsigned long long _Number)
     * }
     */
    public static FunctionDescriptor _byteswap_uint64$descriptor() {
        return _byteswap_uint64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _byteswap_uint64(unsigned long long _Number)
     * }
     */
    public static MethodHandle _byteswap_uint64$handle() {
        return _byteswap_uint64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _byteswap_uint64(unsigned long long _Number)
     * }
     */
    public static MemorySegment _byteswap_uint64$address() {
        return _byteswap_uint64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _byteswap_uint64(unsigned long long _Number)
     * }
     */
    public static long _byteswap_uint64(long _Number) {
        var mh$ = _byteswap_uint64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_byteswap_uint64", _Number);
            }
            return (long)mh$.invokeExact(_Number);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class div {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            _div_t.layout(),
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("div");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * div_t div(int _Numerator, int _Denominator)
     * }
     */
    public static FunctionDescriptor div$descriptor() {
        return div.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * div_t div(int _Numerator, int _Denominator)
     * }
     */
    public static MethodHandle div$handle() {
        return div.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * div_t div(int _Numerator, int _Denominator)
     * }
     */
    public static MemorySegment div$address() {
        return div.ADDR;
    }

    /**
     * {@snippet lang=c :
     * div_t div(int _Numerator, int _Denominator)
     * }
     */
    public static MemorySegment div(SegmentAllocator allocator, int _Numerator, int _Denominator) {
        var mh$ = div.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("div", allocator, _Numerator, _Denominator);
            }
            return (MemorySegment)mh$.invokeExact(allocator, _Numerator, _Denominator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            _ldiv_t.layout(),
            Cubiomes.C_LONG,
            Cubiomes.C_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("ldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long _Numerator, long _Denominator)
     * }
     */
    public static FunctionDescriptor ldiv$descriptor() {
        return ldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long _Numerator, long _Denominator)
     * }
     */
    public static MethodHandle ldiv$handle() {
        return ldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long _Numerator, long _Denominator)
     * }
     */
    public static MemorySegment ldiv$address() {
        return ldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ldiv_t ldiv(long _Numerator, long _Denominator)
     * }
     */
    public static MemorySegment ldiv(SegmentAllocator allocator, int _Numerator, int _Denominator) {
        var mh$ = ldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldiv", allocator, _Numerator, _Denominator);
            }
            return (MemorySegment)mh$.invokeExact(allocator, _Numerator, _Denominator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            _lldiv_t$3.layout(),
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("lldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long _Numerator, long long _Denominator)
     * }
     */
    public static FunctionDescriptor lldiv$descriptor() {
        return lldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long _Numerator, long long _Denominator)
     * }
     */
    public static MethodHandle lldiv$handle() {
        return lldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long _Numerator, long long _Denominator)
     * }
     */
    public static MemorySegment lldiv$address() {
        return lldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lldiv_t lldiv(long long _Numerator, long long _Denominator)
     * }
     */
    public static MemorySegment lldiv(SegmentAllocator allocator, long _Numerator, long _Denominator) {
        var mh$ = lldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lldiv", allocator, _Numerator, _Denominator);
            }
            return (MemorySegment)mh$.invokeExact(allocator, _Numerator, _Denominator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _rotl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_rotl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int _rotl(unsigned int _Value, int _Shift)
     * }
     */
    public static FunctionDescriptor _rotl$descriptor() {
        return _rotl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int _rotl(unsigned int _Value, int _Shift)
     * }
     */
    public static MethodHandle _rotl$handle() {
        return _rotl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int _rotl(unsigned int _Value, int _Shift)
     * }
     */
    public static MemorySegment _rotl$address() {
        return _rotl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int _rotl(unsigned int _Value, int _Shift)
     * }
     */
    public static int _rotl(int _Value, int _Shift) {
        var mh$ = _rotl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_rotl", _Value, _Shift);
            }
            return (int)mh$.invokeExact(_Value, _Shift);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lrotl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG,
            Cubiomes.C_LONG,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_lrotl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long _lrotl(unsigned long _Value, int _Shift)
     * }
     */
    public static FunctionDescriptor _lrotl$descriptor() {
        return _lrotl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long _lrotl(unsigned long _Value, int _Shift)
     * }
     */
    public static MethodHandle _lrotl$handle() {
        return _lrotl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long _lrotl(unsigned long _Value, int _Shift)
     * }
     */
    public static MemorySegment _lrotl$address() {
        return _lrotl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long _lrotl(unsigned long _Value, int _Shift)
     * }
     */
    public static int _lrotl(int _Value, int _Shift) {
        var mh$ = _lrotl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lrotl", _Value, _Shift);
            }
            return (int)mh$.invokeExact(_Value, _Shift);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _rotl64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_rotl64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _rotl64(unsigned long long _Value, int _Shift)
     * }
     */
    public static FunctionDescriptor _rotl64$descriptor() {
        return _rotl64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _rotl64(unsigned long long _Value, int _Shift)
     * }
     */
    public static MethodHandle _rotl64$handle() {
        return _rotl64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _rotl64(unsigned long long _Value, int _Shift)
     * }
     */
    public static MemorySegment _rotl64$address() {
        return _rotl64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _rotl64(unsigned long long _Value, int _Shift)
     * }
     */
    public static long _rotl64(long _Value, int _Shift) {
        var mh$ = _rotl64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_rotl64", _Value, _Shift);
            }
            return (long)mh$.invokeExact(_Value, _Shift);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _rotr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_rotr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int _rotr(unsigned int _Value, int _Shift)
     * }
     */
    public static FunctionDescriptor _rotr$descriptor() {
        return _rotr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int _rotr(unsigned int _Value, int _Shift)
     * }
     */
    public static MethodHandle _rotr$handle() {
        return _rotr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int _rotr(unsigned int _Value, int _Shift)
     * }
     */
    public static MemorySegment _rotr$address() {
        return _rotr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int _rotr(unsigned int _Value, int _Shift)
     * }
     */
    public static int _rotr(int _Value, int _Shift) {
        var mh$ = _rotr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_rotr", _Value, _Shift);
            }
            return (int)mh$.invokeExact(_Value, _Shift);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lrotr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG,
            Cubiomes.C_LONG,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_lrotr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long _lrotr(unsigned long _Value, int _Shift)
     * }
     */
    public static FunctionDescriptor _lrotr$descriptor() {
        return _lrotr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long _lrotr(unsigned long _Value, int _Shift)
     * }
     */
    public static MethodHandle _lrotr$handle() {
        return _lrotr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long _lrotr(unsigned long _Value, int _Shift)
     * }
     */
    public static MemorySegment _lrotr$address() {
        return _lrotr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long _lrotr(unsigned long _Value, int _Shift)
     * }
     */
    public static int _lrotr(int _Value, int _Shift) {
        var mh$ = _lrotr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lrotr", _Value, _Shift);
            }
            return (int)mh$.invokeExact(_Value, _Shift);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _rotr64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_rotr64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _rotr64(unsigned long long _Value, int _Shift)
     * }
     */
    public static FunctionDescriptor _rotr64$descriptor() {
        return _rotr64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _rotr64(unsigned long long _Value, int _Shift)
     * }
     */
    public static MethodHandle _rotr64$handle() {
        return _rotr64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _rotr64(unsigned long long _Value, int _Shift)
     * }
     */
    public static MemorySegment _rotr64$address() {
        return _rotr64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _rotr64(unsigned long long _Value, int _Shift)
     * }
     */
    public static long _rotr64(long _Value, int _Shift) {
        var mh$ = _rotr64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_rotr64", _Value, _Shift);
            }
            return (long)mh$.invokeExact(_Value, _Shift);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("srand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srand(unsigned int _Seed)
     * }
     */
    public static FunctionDescriptor srand$descriptor() {
        return srand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srand(unsigned int _Seed)
     * }
     */
    public static MethodHandle srand$handle() {
        return srand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srand(unsigned int _Seed)
     * }
     */
    public static MemorySegment srand$address() {
        return srand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srand(unsigned int _Seed)
     * }
     */
    public static void srand(int _Seed) {
        var mh$ = srand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand", _Seed);
            }
            mh$.invokeExact(_Seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT    );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("rand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static FunctionDescriptor rand$descriptor() {
        return rand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static MethodHandle rand$handle() {
        return rand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static MemorySegment rand$address() {
        return rand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static int rand() {
        var mh$ = rand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("atof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double atof(const char *_String)
     * }
     */
    public static FunctionDescriptor atof$descriptor() {
        return atof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double atof(const char *_String)
     * }
     */
    public static MethodHandle atof$handle() {
        return atof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double atof(const char *_String)
     * }
     */
    public static MemorySegment atof$address() {
        return atof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double atof(const char *_String)
     * }
     */
    public static double atof(MemorySegment _String) {
        var mh$ = atof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atof", _String);
            }
            return (double)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("atoi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atoi(const char *_String)
     * }
     */
    public static FunctionDescriptor atoi$descriptor() {
        return atoi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atoi(const char *_String)
     * }
     */
    public static MethodHandle atoi$handle() {
        return atoi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atoi(const char *_String)
     * }
     */
    public static MemorySegment atoi$address() {
        return atoi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atoi(const char *_String)
     * }
     */
    public static int atoi(MemorySegment _String) {
        var mh$ = atoi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoi", _String);
            }
            return (int)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("atol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long atol(const char *_String)
     * }
     */
    public static FunctionDescriptor atol$descriptor() {
        return atol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long atol(const char *_String)
     * }
     */
    public static MethodHandle atol$handle() {
        return atol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long atol(const char *_String)
     * }
     */
    public static MemorySegment atol$address() {
        return atol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long atol(const char *_String)
     * }
     */
    public static int atol(MemorySegment _String) {
        var mh$ = atol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atol", _String);
            }
            return (int)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("atoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long atoll(const char *_String)
     * }
     */
    public static FunctionDescriptor atoll$descriptor() {
        return atoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long atoll(const char *_String)
     * }
     */
    public static MethodHandle atoll$handle() {
        return atoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long atoll(const char *_String)
     * }
     */
    public static MemorySegment atoll$address() {
        return atoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long atoll(const char *_String)
     * }
     */
    public static long atoll(MemorySegment _String) {
        var mh$ = atoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoll", _String);
            }
            return (long)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoi64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_atoi64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _atoi64(const char *_String)
     * }
     */
    public static FunctionDescriptor _atoi64$descriptor() {
        return _atoi64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _atoi64(const char *_String)
     * }
     */
    public static MethodHandle _atoi64$handle() {
        return _atoi64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _atoi64(const char *_String)
     * }
     */
    public static MemorySegment _atoi64$address() {
        return _atoi64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _atoi64(const char *_String)
     * }
     */
    public static long _atoi64(MemorySegment _String) {
        var mh$ = _atoi64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoi64", _String);
            }
            return (long)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atof_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_atof_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _atof_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atof_l$descriptor() {
        return _atof_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _atof_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atof_l$handle() {
        return _atof_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _atof_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _atof_l$address() {
        return _atof_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _atof_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static double _atof_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atof_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atof_l", _String, _Locale);
            }
            return (double)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoi_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_atoi_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atoi_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atoi_l$descriptor() {
        return _atoi_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atoi_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atoi_l$handle() {
        return _atoi_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _atoi_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _atoi_l$address() {
        return _atoi_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _atoi_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static int _atoi_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atoi_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoi_l", _String, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atol_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_atol_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _atol_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atol_l$descriptor() {
        return _atol_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _atol_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atol_l$handle() {
        return _atol_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _atol_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _atol_l$address() {
        return _atol_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _atol_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static int _atol_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atol_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atol_l", _String, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_atoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _atoll_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atoll_l$descriptor() {
        return _atoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _atoll_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atoll_l$handle() {
        return _atoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _atoll_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _atoll_l$address() {
        return _atoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _atoll_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static long _atoll_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoll_l", _String, _Locale);
            }
            return (long)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoi64_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_atoi64_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _atoi64_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atoi64_l$descriptor() {
        return _atoi64_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _atoi64_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atoi64_l$handle() {
        return _atoi64_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _atoi64_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _atoi64_l$address() {
        return _atoi64_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _atoi64_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static long _atoi64_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atoi64_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoi64_l", _String, _Locale);
            }
            return (long)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoflt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_atoflt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atoflt(_CRT_FLOAT *_Result, const char *_String)
     * }
     */
    public static FunctionDescriptor _atoflt$descriptor() {
        return _atoflt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atoflt(_CRT_FLOAT *_Result, const char *_String)
     * }
     */
    public static MethodHandle _atoflt$handle() {
        return _atoflt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _atoflt(_CRT_FLOAT *_Result, const char *_String)
     * }
     */
    public static MemorySegment _atoflt$address() {
        return _atoflt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _atoflt(_CRT_FLOAT *_Result, const char *_String)
     * }
     */
    public static int _atoflt(MemorySegment _Result, MemorySegment _String) {
        var mh$ = _atoflt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoflt", _Result, _String);
            }
            return (int)mh$.invokeExact(_Result, _String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atodbl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_atodbl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atodbl(_CRT_DOUBLE *_Result, char *_String)
     * }
     */
    public static FunctionDescriptor _atodbl$descriptor() {
        return _atodbl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atodbl(_CRT_DOUBLE *_Result, char *_String)
     * }
     */
    public static MethodHandle _atodbl$handle() {
        return _atodbl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _atodbl(_CRT_DOUBLE *_Result, char *_String)
     * }
     */
    public static MemorySegment _atodbl$address() {
        return _atodbl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _atodbl(_CRT_DOUBLE *_Result, char *_String)
     * }
     */
    public static int _atodbl(MemorySegment _Result, MemorySegment _String) {
        var mh$ = _atodbl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atodbl", _Result, _String);
            }
            return (int)mh$.invokeExact(_Result, _String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoldbl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_atoldbl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atoldbl(_LDOUBLE *_Result, char *_String)
     * }
     */
    public static FunctionDescriptor _atoldbl$descriptor() {
        return _atoldbl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atoldbl(_LDOUBLE *_Result, char *_String)
     * }
     */
    public static MethodHandle _atoldbl$handle() {
        return _atoldbl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _atoldbl(_LDOUBLE *_Result, char *_String)
     * }
     */
    public static MemorySegment _atoldbl$address() {
        return _atoldbl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _atoldbl(_LDOUBLE *_Result, char *_String)
     * }
     */
    public static int _atoldbl(MemorySegment _Result, MemorySegment _String) {
        var mh$ = _atoldbl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoldbl", _Result, _String);
            }
            return (int)mh$.invokeExact(_Result, _String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoflt_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_atoflt_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atoflt_l(_CRT_FLOAT *_Result, const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atoflt_l$descriptor() {
        return _atoflt_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atoflt_l(_CRT_FLOAT *_Result, const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atoflt_l$handle() {
        return _atoflt_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _atoflt_l(_CRT_FLOAT *_Result, const char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _atoflt_l$address() {
        return _atoflt_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _atoflt_l(_CRT_FLOAT *_Result, const char *_String, _locale_t _Locale)
     * }
     */
    public static int _atoflt_l(MemorySegment _Result, MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atoflt_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoflt_l", _Result, _String, _Locale);
            }
            return (int)mh$.invokeExact(_Result, _String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atodbl_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_atodbl_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atodbl_l(_CRT_DOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atodbl_l$descriptor() {
        return _atodbl_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atodbl_l(_CRT_DOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atodbl_l$handle() {
        return _atodbl_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _atodbl_l(_CRT_DOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _atodbl_l$address() {
        return _atodbl_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _atodbl_l(_CRT_DOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static int _atodbl_l(MemorySegment _Result, MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atodbl_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atodbl_l", _Result, _String, _Locale);
            }
            return (int)mh$.invokeExact(_Result, _String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoldbl_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_atoldbl_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atoldbl_l(_LDOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atoldbl_l$descriptor() {
        return _atoldbl_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atoldbl_l(_LDOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atoldbl_l$handle() {
        return _atoldbl_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _atoldbl_l(_LDOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _atoldbl_l$address() {
        return _atoldbl_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _atoldbl_l(_LDOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static int _atoldbl_l(MemorySegment _Result, MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atoldbl_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoldbl_l", _Result, _String, _Locale);
            }
            return (int)mh$.invokeExact(_Result, _String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("strtof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float strtof(const char *_String, char **_EndPtr)
     * }
     */
    public static FunctionDescriptor strtof$descriptor() {
        return strtof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float strtof(const char *_String, char **_EndPtr)
     * }
     */
    public static MethodHandle strtof$handle() {
        return strtof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float strtof(const char *_String, char **_EndPtr)
     * }
     */
    public static MemorySegment strtof$address() {
        return strtof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float strtof(const char *_String, char **_EndPtr)
     * }
     */
    public static float strtof(MemorySegment _String, MemorySegment _EndPtr) {
        var mh$ = strtof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtof", _String, _EndPtr);
            }
            return (float)mh$.invokeExact(_String, _EndPtr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtof_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_strtof_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _strtof_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtof_l$descriptor() {
        return _strtof_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _strtof_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtof_l$handle() {
        return _strtof_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _strtof_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtof_l$address() {
        return _strtof_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _strtof_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static float _strtof_l(MemorySegment _String, MemorySegment _EndPtr, MemorySegment _Locale) {
        var mh$ = _strtof_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtof_l", _String, _EndPtr, _Locale);
            }
            return (float)mh$.invokeExact(_String, _EndPtr, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("strtod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double strtod(const char *_String, char **_EndPtr)
     * }
     */
    public static FunctionDescriptor strtod$descriptor() {
        return strtod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double strtod(const char *_String, char **_EndPtr)
     * }
     */
    public static MethodHandle strtod$handle() {
        return strtod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double strtod(const char *_String, char **_EndPtr)
     * }
     */
    public static MemorySegment strtod$address() {
        return strtod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double strtod(const char *_String, char **_EndPtr)
     * }
     */
    public static double strtod(MemorySegment _String, MemorySegment _EndPtr) {
        var mh$ = strtod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtod", _String, _EndPtr);
            }
            return (double)mh$.invokeExact(_String, _EndPtr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtod_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_strtod_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _strtod_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtod_l$descriptor() {
        return _strtod_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _strtod_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtod_l$handle() {
        return _strtod_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _strtod_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtod_l$address() {
        return _strtod_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _strtod_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static double _strtod_l(MemorySegment _String, MemorySegment _EndPtr, MemorySegment _Locale) {
        var mh$ = _strtod_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtod_l", _String, _EndPtr, _Locale);
            }
            return (double)mh$.invokeExact(_String, _EndPtr, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtold {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("strtold");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double strtold(const char *_String, char **_EndPtr)
     * }
     */
    public static FunctionDescriptor strtold$descriptor() {
        return strtold.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double strtold(const char *_String, char **_EndPtr)
     * }
     */
    public static MethodHandle strtold$handle() {
        return strtold.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double strtold(const char *_String, char **_EndPtr)
     * }
     */
    public static MemorySegment strtold$address() {
        return strtold.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double strtold(const char *_String, char **_EndPtr)
     * }
     */
    public static double strtold(MemorySegment _String, MemorySegment _EndPtr) {
        var mh$ = strtold.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtold", _String, _EndPtr);
            }
            return (double)mh$.invokeExact(_String, _EndPtr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtold_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_strtold_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double _strtold_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtold_l$descriptor() {
        return _strtold_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double _strtold_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtold_l$handle() {
        return _strtold_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double _strtold_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtold_l$address() {
        return _strtold_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double _strtold_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static double _strtold_l(MemorySegment _String, MemorySegment _EndPtr, MemorySegment _Locale) {
        var mh$ = _strtold_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtold_l", _String, _EndPtr, _Locale);
            }
            return (double)mh$.invokeExact(_String, _EndPtr, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("strtol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long strtol(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor strtol$descriptor() {
        return strtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long strtol(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle strtol$handle() {
        return strtol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long strtol(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment strtol$address() {
        return strtol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long strtol(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static int strtol(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = strtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtol", _String, _EndPtr, _Radix);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtol_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_strtol_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _strtol_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtol_l$descriptor() {
        return _strtol_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _strtol_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtol_l$handle() {
        return _strtol_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _strtol_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtol_l$address() {
        return _strtol_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _strtol_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static int _strtol_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtol_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtol_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("strtoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtoll(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor strtoll$descriptor() {
        return strtoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtoll(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle strtoll$handle() {
        return strtoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtoll(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment strtoll$address() {
        return strtoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtoll(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static long strtoll(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = strtoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoll", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_strtoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _strtoll_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtoll_l$descriptor() {
        return _strtoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _strtoll_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtoll_l$handle() {
        return _strtoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _strtoll_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtoll_l$address() {
        return _strtoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _strtoll_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _strtoll_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoll_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("strtoul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor strtoul$descriptor() {
        return strtoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle strtoul$handle() {
        return strtoul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment strtoul$address() {
        return strtoul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strtoul(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static int strtoul(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = strtoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoul", _String, _EndPtr, _Radix);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoul_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_strtoul_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long _strtoul_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtoul_l$descriptor() {
        return _strtoul_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long _strtoul_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtoul_l$handle() {
        return _strtoul_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long _strtoul_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtoul_l$address() {
        return _strtoul_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long _strtoul_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static int _strtoul_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtoul_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoul_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("strtoull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor strtoull$descriptor() {
        return strtoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle strtoull$handle() {
        return strtoull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment strtoull$address() {
        return strtoull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static long strtoull(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = strtoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoull", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoull_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_strtoull_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _strtoull_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtoull_l$descriptor() {
        return _strtoull_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _strtoull_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtoull_l$handle() {
        return _strtoull_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _strtoull_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtoull_l$address() {
        return _strtoull_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _strtoull_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _strtoull_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtoull_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoull_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoi64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_strtoi64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _strtoi64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor _strtoi64$descriptor() {
        return _strtoi64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _strtoi64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle _strtoi64$handle() {
        return _strtoi64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _strtoi64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment _strtoi64$address() {
        return _strtoi64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _strtoi64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static long _strtoi64(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = _strtoi64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoi64", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoi64_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_strtoi64_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _strtoi64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtoi64_l$descriptor() {
        return _strtoi64_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _strtoi64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtoi64_l$handle() {
        return _strtoi64_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _strtoi64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtoi64_l$address() {
        return _strtoi64_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _strtoi64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _strtoi64_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtoi64_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoi64_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoui64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_strtoui64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _strtoui64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor _strtoui64$descriptor() {
        return _strtoui64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _strtoui64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle _strtoui64$handle() {
        return _strtoui64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _strtoui64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MemorySegment _strtoui64$address() {
        return _strtoui64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _strtoui64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static long _strtoui64(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = _strtoui64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoui64", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoui64_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_strtoui64_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _strtoui64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtoui64_l$descriptor() {
        return _strtoui64_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _strtoui64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtoui64_l$handle() {
        return _strtoui64_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long _strtoui64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MemorySegment _strtoui64_l$address() {
        return _strtoui64_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long _strtoui64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _strtoui64_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtoui64_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoui64_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _itoa_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_itoa_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _itoa_s(int _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _itoa_s$descriptor() {
        return _itoa_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _itoa_s(int _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _itoa_s$handle() {
        return _itoa_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _itoa_s(int _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _itoa_s$address() {
        return _itoa_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _itoa_s(int _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _itoa_s(int _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _itoa_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_itoa_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _itoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_itoa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _itoa$descriptor() {
        return _itoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _itoa$handle() {
        return _itoa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _itoa$address() {
        return _itoa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _itoa(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _itoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_itoa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ltoa_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_ltoa_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ltoa_s(long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ltoa_s$descriptor() {
        return _ltoa_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ltoa_s(long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ltoa_s$handle() {
        return _ltoa_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ltoa_s(long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _ltoa_s$address() {
        return _ltoa_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ltoa_s(long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ltoa_s(int _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ltoa_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ltoa_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ltoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_ltoa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ltoa$descriptor() {
        return _ltoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ltoa$handle() {
        return _ltoa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ltoa$address() {
        return _ltoa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ltoa(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ltoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ltoa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ultoa_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_ultoa_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ultoa_s(unsigned long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ultoa_s$descriptor() {
        return _ultoa_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ultoa_s(unsigned long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ultoa_s$handle() {
        return _ultoa_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ultoa_s(unsigned long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _ultoa_s$address() {
        return _ultoa_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ultoa_s(unsigned long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ultoa_s(int _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ultoa_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ultoa_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ultoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_ultoa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ultoa$descriptor() {
        return _ultoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ultoa$handle() {
        return _ultoa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ultoa$address() {
        return _ultoa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ultoa(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ultoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ultoa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _i64toa_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_i64toa_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _i64toa_s(long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _i64toa_s$descriptor() {
        return _i64toa_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _i64toa_s(long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _i64toa_s$handle() {
        return _i64toa_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _i64toa_s(long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _i64toa_s$address() {
        return _i64toa_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _i64toa_s(long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _i64toa_s(long _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _i64toa_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_i64toa_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _i64toa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_i64toa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_i64toa(long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _i64toa$descriptor() {
        return _i64toa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_i64toa(long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _i64toa$handle() {
        return _i64toa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_i64toa(long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _i64toa$address() {
        return _i64toa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_i64toa(long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _i64toa(long _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _i64toa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_i64toa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ui64toa_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_ui64toa_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ui64toa_s(unsigned long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ui64toa_s$descriptor() {
        return _ui64toa_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ui64toa_s(unsigned long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ui64toa_s$handle() {
        return _ui64toa_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ui64toa_s(unsigned long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MemorySegment _ui64toa_s$address() {
        return _ui64toa_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ui64toa_s(unsigned long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ui64toa_s(long _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ui64toa_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ui64toa_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ui64toa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_ui64toa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_ui64toa(unsigned long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ui64toa$descriptor() {
        return _ui64toa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_ui64toa(unsigned long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ui64toa$handle() {
        return _ui64toa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_ui64toa(unsigned long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ui64toa$address() {
        return _ui64toa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_ui64toa(unsigned long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ui64toa(long _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ui64toa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ui64toa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ecvt_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_ecvt_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ecvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor _ecvt_s$descriptor() {
        return _ecvt_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ecvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle _ecvt_s$handle() {
        return _ecvt_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _ecvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment _ecvt_s$address() {
        return _ecvt_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _ecvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static int _ecvt_s(MemorySegment _Buffer, long _BufferCount, double _Value, int _DigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = _ecvt_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ecvt_s", _Buffer, _BufferCount, _Value, _DigitCount, _PtDec, _PtSign);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _Value, _DigitCount, _PtDec, _PtSign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ecvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_ecvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor _ecvt$descriptor() {
        return _ecvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle _ecvt$handle() {
        return _ecvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment _ecvt$address() {
        return _ecvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment _ecvt(double _Value, int _DigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = _ecvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ecvt", _Value, _DigitCount, _PtDec, _PtSign);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _DigitCount, _PtDec, _PtSign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fcvt_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_fcvt_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _fcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor _fcvt_s$descriptor() {
        return _fcvt_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _fcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle _fcvt_s$handle() {
        return _fcvt_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _fcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment _fcvt_s$address() {
        return _fcvt_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _fcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static int _fcvt_s(MemorySegment _Buffer, long _BufferCount, double _Value, int _FractionalDigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = _fcvt_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fcvt_s", _Buffer, _BufferCount, _Value, _FractionalDigitCount, _PtDec, _PtSign);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _Value, _FractionalDigitCount, _PtDec, _PtSign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_fcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor _fcvt$descriptor() {
        return _fcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle _fcvt$handle() {
        return _fcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment _fcvt$address() {
        return _fcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment _fcvt(double _Value, int _FractionalDigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = _fcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fcvt", _Value, _FractionalDigitCount, _PtDec, _PtSign);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _FractionalDigitCount, _PtDec, _PtSign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _gcvt_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_gcvt_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _gcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount)
     * }
     */
    public static FunctionDescriptor _gcvt_s$descriptor() {
        return _gcvt_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _gcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount)
     * }
     */
    public static MethodHandle _gcvt_s$handle() {
        return _gcvt_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _gcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount)
     * }
     */
    public static MemorySegment _gcvt_s$address() {
        return _gcvt_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _gcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount)
     * }
     */
    public static int _gcvt_s(MemorySegment _Buffer, long _BufferCount, double _Value, int _DigitCount) {
        var mh$ = _gcvt_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_gcvt_s", _Buffer, _BufferCount, _Value, _DigitCount);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _Value, _DigitCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _gcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_gcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_gcvt(double _Value, int _DigitCount, char *_Buffer)
     * }
     */
    public static FunctionDescriptor _gcvt$descriptor() {
        return _gcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_gcvt(double _Value, int _DigitCount, char *_Buffer)
     * }
     */
    public static MethodHandle _gcvt$handle() {
        return _gcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_gcvt(double _Value, int _DigitCount, char *_Buffer)
     * }
     */
    public static MemorySegment _gcvt$address() {
        return _gcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_gcvt(double _Value, int _DigitCount, char *_Buffer)
     * }
     */
    public static MemorySegment _gcvt(double _Value, int _DigitCount, MemorySegment _Buffer) {
        var mh$ = _gcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_gcvt", _Value, _DigitCount, _Buffer);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _DigitCount, _Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ___mb_cur_max_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT    );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("___mb_cur_max_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ___mb_cur_max_func()
     * }
     */
    public static FunctionDescriptor ___mb_cur_max_func$descriptor() {
        return ___mb_cur_max_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ___mb_cur_max_func()
     * }
     */
    public static MethodHandle ___mb_cur_max_func$handle() {
        return ___mb_cur_max_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ___mb_cur_max_func()
     * }
     */
    public static MemorySegment ___mb_cur_max_func$address() {
        return ___mb_cur_max_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ___mb_cur_max_func()
     * }
     */
    public static int ___mb_cur_max_func() {
        var mh$ = ___mb_cur_max_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("___mb_cur_max_func");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ___mb_cur_max_l_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("___mb_cur_max_l_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ___mb_cur_max_l_func(_locale_t _Locale)
     * }
     */
    public static FunctionDescriptor ___mb_cur_max_l_func$descriptor() {
        return ___mb_cur_max_l_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ___mb_cur_max_l_func(_locale_t _Locale)
     * }
     */
    public static MethodHandle ___mb_cur_max_l_func$handle() {
        return ___mb_cur_max_l_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ___mb_cur_max_l_func(_locale_t _Locale)
     * }
     */
    public static MemorySegment ___mb_cur_max_l_func$address() {
        return ___mb_cur_max_l_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ___mb_cur_max_l_func(_locale_t _Locale)
     * }
     */
    public static int ___mb_cur_max_l_func(MemorySegment _Locale) {
        var mh$ = ___mb_cur_max_l_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("___mb_cur_max_l_func", _Locale);
            }
            return (int)mh$.invokeExact(_Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mblen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("mblen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mblen(const char *_Ch, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor mblen$descriptor() {
        return mblen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mblen(const char *_Ch, size_t _MaxCount)
     * }
     */
    public static MethodHandle mblen$handle() {
        return mblen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mblen(const char *_Ch, size_t _MaxCount)
     * }
     */
    public static MemorySegment mblen$address() {
        return mblen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mblen(const char *_Ch, size_t _MaxCount)
     * }
     */
    public static int mblen(MemorySegment _Ch, long _MaxCount) {
        var mh$ = mblen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mblen", _Ch, _MaxCount);
            }
            return (int)mh$.invokeExact(_Ch, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mblen_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_mblen_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _mblen_l(const char *_Ch, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mblen_l$descriptor() {
        return _mblen_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _mblen_l(const char *_Ch, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mblen_l$handle() {
        return _mblen_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _mblen_l(const char *_Ch, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _mblen_l$address() {
        return _mblen_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _mblen_l(const char *_Ch, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _mblen_l(MemorySegment _Ch, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _mblen_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mblen_l", _Ch, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_Ch, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstrlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_mbstrlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _mbstrlen(const char *_String)
     * }
     */
    public static FunctionDescriptor _mbstrlen$descriptor() {
        return _mbstrlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _mbstrlen(const char *_String)
     * }
     */
    public static MethodHandle _mbstrlen$handle() {
        return _mbstrlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _mbstrlen(const char *_String)
     * }
     */
    public static MemorySegment _mbstrlen$address() {
        return _mbstrlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _mbstrlen(const char *_String)
     * }
     */
    public static long _mbstrlen(MemorySegment _String) {
        var mh$ = _mbstrlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstrlen", _String);
            }
            return (long)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstrlen_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_mbstrlen_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _mbstrlen_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mbstrlen_l$descriptor() {
        return _mbstrlen_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _mbstrlen_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mbstrlen_l$handle() {
        return _mbstrlen_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _mbstrlen_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MemorySegment _mbstrlen_l$address() {
        return _mbstrlen_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _mbstrlen_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static long _mbstrlen_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _mbstrlen_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstrlen_l", _String, _Locale);
            }
            return (long)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstrnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_mbstrnlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _mbstrnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _mbstrnlen$descriptor() {
        return _mbstrnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _mbstrnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static MethodHandle _mbstrnlen$handle() {
        return _mbstrnlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _mbstrnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static MemorySegment _mbstrnlen$address() {
        return _mbstrnlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _mbstrnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static long _mbstrnlen(MemorySegment _String, long _MaxCount) {
        var mh$ = _mbstrnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstrnlen", _String, _MaxCount);
            }
            return (long)mh$.invokeExact(_String, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstrnlen_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_mbstrnlen_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _mbstrnlen_l(const char *_String, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mbstrnlen_l$descriptor() {
        return _mbstrnlen_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _mbstrnlen_l(const char *_String, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mbstrnlen_l$handle() {
        return _mbstrnlen_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _mbstrnlen_l(const char *_String, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _mbstrnlen_l$address() {
        return _mbstrnlen_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _mbstrnlen_l(const char *_String, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static long _mbstrnlen_l(MemorySegment _String, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _mbstrnlen_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstrnlen_l", _String, _MaxCount, _Locale);
            }
            return (long)mh$.invokeExact(_String, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbtowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("mbtowc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes)
     * }
     */
    public static FunctionDescriptor mbtowc$descriptor() {
        return mbtowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes)
     * }
     */
    public static MethodHandle mbtowc$handle() {
        return mbtowc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes)
     * }
     */
    public static MemorySegment mbtowc$address() {
        return mbtowc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mbtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes)
     * }
     */
    public static int mbtowc(MemorySegment _DstCh, MemorySegment _SrcCh, long _SrcSizeInBytes) {
        var mh$ = mbtowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbtowc", _DstCh, _SrcCh, _SrcSizeInBytes);
            }
            return (int)mh$.invokeExact(_DstCh, _SrcCh, _SrcSizeInBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbtowc_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_mbtowc_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _mbtowc_l(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mbtowc_l$descriptor() {
        return _mbtowc_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _mbtowc_l(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mbtowc_l$handle() {
        return _mbtowc_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _mbtowc_l(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale)
     * }
     */
    public static MemorySegment _mbtowc_l$address() {
        return _mbtowc_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _mbtowc_l(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale)
     * }
     */
    public static int _mbtowc_l(MemorySegment _DstCh, MemorySegment _SrcCh, long _SrcSizeInBytes, MemorySegment _Locale) {
        var mh$ = _mbtowc_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbtowc_l", _DstCh, _SrcCh, _SrcSizeInBytes, _Locale);
            }
            return (int)mh$.invokeExact(_DstCh, _SrcCh, _SrcSizeInBytes, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbstowcs_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("mbstowcs_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t mbstowcs_s(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor mbstowcs_s$descriptor() {
        return mbstowcs_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t mbstowcs_s(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount)
     * }
     */
    public static MethodHandle mbstowcs_s$handle() {
        return mbstowcs_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t mbstowcs_s(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount)
     * }
     */
    public static MemorySegment mbstowcs_s$address() {
        return mbstowcs_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t mbstowcs_s(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount)
     * }
     */
    public static int mbstowcs_s(MemorySegment _PtNumOfCharConverted, MemorySegment _DstBuf, long _SizeInWords, MemorySegment _SrcBuf, long _MaxCount) {
        var mh$ = mbstowcs_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbstowcs_s", _PtNumOfCharConverted, _DstBuf, _SizeInWords, _SrcBuf, _MaxCount);
            }
            return (int)mh$.invokeExact(_PtNumOfCharConverted, _DstBuf, _SizeInWords, _SrcBuf, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbstowcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("mbstowcs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *_Dest, const char *_Source, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor mbstowcs$descriptor() {
        return mbstowcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *_Dest, const char *_Source, size_t _MaxCount)
     * }
     */
    public static MethodHandle mbstowcs$handle() {
        return mbstowcs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *_Dest, const char *_Source, size_t _MaxCount)
     * }
     */
    public static MemorySegment mbstowcs$address() {
        return mbstowcs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *_Dest, const char *_Source, size_t _MaxCount)
     * }
     */
    public static long mbstowcs(MemorySegment _Dest, MemorySegment _Source, long _MaxCount) {
        var mh$ = mbstowcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbstowcs", _Dest, _Source, _MaxCount);
            }
            return (long)mh$.invokeExact(_Dest, _Source, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstowcs_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_mbstowcs_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _mbstowcs_s_l(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mbstowcs_s_l$descriptor() {
        return _mbstowcs_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _mbstowcs_s_l(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mbstowcs_s_l$handle() {
        return _mbstowcs_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _mbstowcs_s_l(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _mbstowcs_s_l$address() {
        return _mbstowcs_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _mbstowcs_s_l(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _mbstowcs_s_l(MemorySegment _PtNumOfCharConverted, MemorySegment _DstBuf, long _SizeInWords, MemorySegment _SrcBuf, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _mbstowcs_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstowcs_s_l", _PtNumOfCharConverted, _DstBuf, _SizeInWords, _SrcBuf, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_PtNumOfCharConverted, _DstBuf, _SizeInWords, _SrcBuf, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstowcs_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_mbstowcs_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _mbstowcs_l(wchar_t *_Dest, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mbstowcs_l$descriptor() {
        return _mbstowcs_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _mbstowcs_l(wchar_t *_Dest, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mbstowcs_l$handle() {
        return _mbstowcs_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _mbstowcs_l(wchar_t *_Dest, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _mbstowcs_l$address() {
        return _mbstowcs_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _mbstowcs_l(wchar_t *_Dest, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static long _mbstowcs_l(MemorySegment _Dest, MemorySegment _Source, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _mbstowcs_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstowcs_l", _Dest, _Source, _MaxCount, _Locale);
            }
            return (long)mh$.invokeExact(_Dest, _Source, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_SHORT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("wctomb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wctomb(char *_MbCh, wchar_t _WCh)
     * }
     */
    public static FunctionDescriptor wctomb$descriptor() {
        return wctomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wctomb(char *_MbCh, wchar_t _WCh)
     * }
     */
    public static MethodHandle wctomb$handle() {
        return wctomb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wctomb(char *_MbCh, wchar_t _WCh)
     * }
     */
    public static MemorySegment wctomb$address() {
        return wctomb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wctomb(char *_MbCh, wchar_t _WCh)
     * }
     */
    public static int wctomb(MemorySegment _MbCh, short _WCh) {
        var mh$ = wctomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctomb", _MbCh, _WCh);
            }
            return (int)mh$.invokeExact(_MbCh, _WCh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wctomb_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_SHORT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wctomb_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wctomb_l(char *_MbCh, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wctomb_l$descriptor() {
        return _wctomb_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wctomb_l(char *_MbCh, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wctomb_l$handle() {
        return _wctomb_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wctomb_l(char *_MbCh, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wctomb_l$address() {
        return _wctomb_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wctomb_l(char *_MbCh, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static int _wctomb_l(MemorySegment _MbCh, short _WCh, MemorySegment _Locale) {
        var mh$ = _wctomb_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wctomb_l", _MbCh, _WCh, _Locale);
            }
            return (int)mh$.invokeExact(_MbCh, _WCh, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctomb_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_SHORT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("wctomb_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wctomb_s(int *_SizeConverted, char *_MbCh, rsize_t _SizeInBytes, wchar_t _WCh)
     * }
     */
    public static FunctionDescriptor wctomb_s$descriptor() {
        return wctomb_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wctomb_s(int *_SizeConverted, char *_MbCh, rsize_t _SizeInBytes, wchar_t _WCh)
     * }
     */
    public static MethodHandle wctomb_s$handle() {
        return wctomb_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wctomb_s(int *_SizeConverted, char *_MbCh, rsize_t _SizeInBytes, wchar_t _WCh)
     * }
     */
    public static MemorySegment wctomb_s$address() {
        return wctomb_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wctomb_s(int *_SizeConverted, char *_MbCh, rsize_t _SizeInBytes, wchar_t _WCh)
     * }
     */
    public static int wctomb_s(MemorySegment _SizeConverted, MemorySegment _MbCh, long _SizeInBytes, short _WCh) {
        var mh$ = wctomb_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctomb_s", _SizeConverted, _MbCh, _SizeInBytes, _WCh);
            }
            return (int)mh$.invokeExact(_SizeConverted, _MbCh, _SizeInBytes, _WCh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wctomb_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_SHORT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wctomb_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wctomb_s_l(int *_SizeConverted, char *_MbCh, size_t _SizeInBytes, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wctomb_s_l$descriptor() {
        return _wctomb_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wctomb_s_l(int *_SizeConverted, char *_MbCh, size_t _SizeInBytes, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wctomb_s_l$handle() {
        return _wctomb_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wctomb_s_l(int *_SizeConverted, char *_MbCh, size_t _SizeInBytes, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wctomb_s_l$address() {
        return _wctomb_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wctomb_s_l(int *_SizeConverted, char *_MbCh, size_t _SizeInBytes, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static int _wctomb_s_l(MemorySegment _SizeConverted, MemorySegment _MbCh, long _SizeInBytes, short _WCh, MemorySegment _Locale) {
        var mh$ = _wctomb_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wctomb_s_l", _SizeConverted, _MbCh, _SizeInBytes, _WCh, _Locale);
            }
            return (int)mh$.invokeExact(_SizeConverted, _MbCh, _SizeInBytes, _WCh, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstombs_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("wcstombs_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wcstombs_s(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes)
     * }
     */
    public static FunctionDescriptor wcstombs_s$descriptor() {
        return wcstombs_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wcstombs_s(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes)
     * }
     */
    public static MethodHandle wcstombs_s$handle() {
        return wcstombs_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t wcstombs_s(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes)
     * }
     */
    public static MemorySegment wcstombs_s$address() {
        return wcstombs_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t wcstombs_s(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes)
     * }
     */
    public static int wcstombs_s(MemorySegment _PtNumOfCharConverted, MemorySegment _Dst, long _DstSizeInBytes, MemorySegment _Src, long _MaxCountInBytes) {
        var mh$ = wcstombs_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstombs_s", _PtNumOfCharConverted, _Dst, _DstSizeInBytes, _Src, _MaxCountInBytes);
            }
            return (int)mh$.invokeExact(_PtNumOfCharConverted, _Dst, _DstSizeInBytes, _Src, _MaxCountInBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstombs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("wcstombs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcstombs(char *_Dest, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcstombs$descriptor() {
        return wcstombs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcstombs(char *_Dest, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcstombs$handle() {
        return wcstombs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcstombs(char *_Dest, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MemorySegment wcstombs$address() {
        return wcstombs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcstombs(char *_Dest, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static long wcstombs(MemorySegment _Dest, MemorySegment _Source, long _MaxCount) {
        var mh$ = wcstombs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstombs", _Dest, _Source, _MaxCount);
            }
            return (long)mh$.invokeExact(_Dest, _Source, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstombs_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wcstombs_s_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcstombs_s_l(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstombs_s_l$descriptor() {
        return _wcstombs_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcstombs_s_l(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstombs_s_l$handle() {
        return _wcstombs_s_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wcstombs_s_l(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstombs_s_l$address() {
        return _wcstombs_s_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wcstombs_s_l(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes, _locale_t _Locale)
     * }
     */
    public static int _wcstombs_s_l(MemorySegment _PtNumOfCharConverted, MemorySegment _Dst, long _DstSizeInBytes, MemorySegment _Src, long _MaxCountInBytes, MemorySegment _Locale) {
        var mh$ = _wcstombs_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstombs_s_l", _PtNumOfCharConverted, _Dst, _DstSizeInBytes, _Src, _MaxCountInBytes, _Locale);
            }
            return (int)mh$.invokeExact(_PtNumOfCharConverted, _Dst, _DstSizeInBytes, _Src, _MaxCountInBytes, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstombs_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_wcstombs_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _wcstombs_l(char *_Dest, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstombs_l$descriptor() {
        return _wcstombs_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _wcstombs_l(char *_Dest, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstombs_l$handle() {
        return _wcstombs_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _wcstombs_l(char *_Dest, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MemorySegment _wcstombs_l$address() {
        return _wcstombs_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _wcstombs_l(char *_Dest, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static long _wcstombs_l(MemorySegment _Dest, MemorySegment _Source, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _wcstombs_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstombs_l", _Dest, _Source, _MaxCount, _Locale);
            }
            return (long)mh$.invokeExact(_Dest, _Source, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fullpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_fullpath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_fullpath(char *_Buffer, const char *_Path, size_t _BufferCount)
     * }
     */
    public static FunctionDescriptor _fullpath$descriptor() {
        return _fullpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_fullpath(char *_Buffer, const char *_Path, size_t _BufferCount)
     * }
     */
    public static MethodHandle _fullpath$handle() {
        return _fullpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_fullpath(char *_Buffer, const char *_Path, size_t _BufferCount)
     * }
     */
    public static MemorySegment _fullpath$address() {
        return _fullpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_fullpath(char *_Buffer, const char *_Path, size_t _BufferCount)
     * }
     */
    public static MemorySegment _fullpath(MemorySegment _Buffer, MemorySegment _Path, long _BufferCount) {
        var mh$ = _fullpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fullpath", _Buffer, _Path, _BufferCount);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer, _Path, _BufferCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _makepath_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_makepath_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _makepath_s(char *_Buffer, size_t _BufferCount, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static FunctionDescriptor _makepath_s$descriptor() {
        return _makepath_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _makepath_s(char *_Buffer, size_t _BufferCount, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static MethodHandle _makepath_s$handle() {
        return _makepath_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _makepath_s(char *_Buffer, size_t _BufferCount, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static MemorySegment _makepath_s$address() {
        return _makepath_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _makepath_s(char *_Buffer, size_t _BufferCount, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static int _makepath_s(MemorySegment _Buffer, long _BufferCount, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _makepath_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_makepath_s", _Buffer, _BufferCount, _Drive, _Dir, _Filename, _Ext);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _Drive, _Dir, _Filename, _Ext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _makepath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_makepath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _makepath(char *_Buffer, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static FunctionDescriptor _makepath$descriptor() {
        return _makepath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _makepath(char *_Buffer, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static MethodHandle _makepath$handle() {
        return _makepath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _makepath(char *_Buffer, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static MemorySegment _makepath$address() {
        return _makepath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _makepath(char *_Buffer, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static void _makepath(MemorySegment _Buffer, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _makepath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_makepath", _Buffer, _Drive, _Dir, _Filename, _Ext);
            }
            mh$.invokeExact(_Buffer, _Drive, _Dir, _Filename, _Ext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _splitpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_splitpath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _splitpath(const char *_FullPath, char *_Drive, char *_Dir, char *_Filename, char *_Ext)
     * }
     */
    public static FunctionDescriptor _splitpath$descriptor() {
        return _splitpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _splitpath(const char *_FullPath, char *_Drive, char *_Dir, char *_Filename, char *_Ext)
     * }
     */
    public static MethodHandle _splitpath$handle() {
        return _splitpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _splitpath(const char *_FullPath, char *_Drive, char *_Dir, char *_Filename, char *_Ext)
     * }
     */
    public static MemorySegment _splitpath$address() {
        return _splitpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _splitpath(const char *_FullPath, char *_Drive, char *_Dir, char *_Filename, char *_Ext)
     * }
     */
    public static void _splitpath(MemorySegment _FullPath, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _splitpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_splitpath", _FullPath, _Drive, _Dir, _Filename, _Ext);
            }
            mh$.invokeExact(_FullPath, _Drive, _Dir, _Filename, _Ext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _splitpath_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_splitpath_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _splitpath_s(const char *_FullPath, char *_Drive, size_t _DriveCount, char *_Dir, size_t _DirCount, char *_Filename, size_t _FilenameCount, char *_Ext, size_t _ExtCount)
     * }
     */
    public static FunctionDescriptor _splitpath_s$descriptor() {
        return _splitpath_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _splitpath_s(const char *_FullPath, char *_Drive, size_t _DriveCount, char *_Dir, size_t _DirCount, char *_Filename, size_t _FilenameCount, char *_Ext, size_t _ExtCount)
     * }
     */
    public static MethodHandle _splitpath_s$handle() {
        return _splitpath_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _splitpath_s(const char *_FullPath, char *_Drive, size_t _DriveCount, char *_Dir, size_t _DirCount, char *_Filename, size_t _FilenameCount, char *_Ext, size_t _ExtCount)
     * }
     */
    public static MemorySegment _splitpath_s$address() {
        return _splitpath_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _splitpath_s(const char *_FullPath, char *_Drive, size_t _DriveCount, char *_Dir, size_t _DirCount, char *_Filename, size_t _FilenameCount, char *_Ext, size_t _ExtCount)
     * }
     */
    public static int _splitpath_s(MemorySegment _FullPath, MemorySegment _Drive, long _DriveCount, MemorySegment _Dir, long _DirCount, MemorySegment _Filename, long _FilenameCount, MemorySegment _Ext, long _ExtCount) {
        var mh$ = _splitpath_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_splitpath_s", _FullPath, _Drive, _DriveCount, _Dir, _DirCount, _Filename, _FilenameCount, _Ext, _ExtCount);
            }
            return (int)mh$.invokeExact(_FullPath, _Drive, _DriveCount, _Dir, _DirCount, _Filename, _FilenameCount, _Ext, _ExtCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("getenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t getenv_s(size_t *_RequiredCount, char *_Buffer, rsize_t _BufferCount, const char *_VarName)
     * }
     */
    public static FunctionDescriptor getenv_s$descriptor() {
        return getenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t getenv_s(size_t *_RequiredCount, char *_Buffer, rsize_t _BufferCount, const char *_VarName)
     * }
     */
    public static MethodHandle getenv_s$handle() {
        return getenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t getenv_s(size_t *_RequiredCount, char *_Buffer, rsize_t _BufferCount, const char *_VarName)
     * }
     */
    public static MemorySegment getenv_s$address() {
        return getenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t getenv_s(size_t *_RequiredCount, char *_Buffer, rsize_t _BufferCount, const char *_VarName)
     * }
     */
    public static int getenv_s(MemorySegment _RequiredCount, MemorySegment _Buffer, long _BufferCount, MemorySegment _VarName) {
        var mh$ = getenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getenv_s", _RequiredCount, _Buffer, _BufferCount, _VarName);
            }
            return (int)mh$.invokeExact(_RequiredCount, _Buffer, _BufferCount, _VarName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p___argc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER    );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("__p___argc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *__p___argc()
     * }
     */
    public static FunctionDescriptor __p___argc$descriptor() {
        return __p___argc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *__p___argc()
     * }
     */
    public static MethodHandle __p___argc$handle() {
        return __p___argc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *__p___argc()
     * }
     */
    public static MemorySegment __p___argc$address() {
        return __p___argc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *__p___argc()
     * }
     */
    public static MemorySegment __p___argc() {
        var mh$ = __p___argc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p___argc");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p___argv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER    );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("__p___argv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char ***__p___argv()
     * }
     */
    public static FunctionDescriptor __p___argv$descriptor() {
        return __p___argv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char ***__p___argv()
     * }
     */
    public static MethodHandle __p___argv$handle() {
        return __p___argv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char ***__p___argv()
     * }
     */
    public static MemorySegment __p___argv$address() {
        return __p___argv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char ***__p___argv()
     * }
     */
    public static MemorySegment __p___argv() {
        var mh$ = __p___argv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p___argv");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p___wargv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER    );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("__p___wargv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t ***__p___wargv()
     * }
     */
    public static FunctionDescriptor __p___wargv$descriptor() {
        return __p___wargv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t ***__p___wargv()
     * }
     */
    public static MethodHandle __p___wargv$handle() {
        return __p___wargv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t ***__p___wargv()
     * }
     */
    public static MemorySegment __p___wargv$address() {
        return __p___wargv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t ***__p___wargv()
     * }
     */
    public static MemorySegment __p___wargv() {
        var mh$ = __p___wargv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p___wargv");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p__environ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER    );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("__p__environ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char ***__p__environ()
     * }
     */
    public static FunctionDescriptor __p__environ$descriptor() {
        return __p__environ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char ***__p__environ()
     * }
     */
    public static MethodHandle __p__environ$handle() {
        return __p__environ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char ***__p__environ()
     * }
     */
    public static MemorySegment __p__environ$address() {
        return __p__environ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char ***__p__environ()
     * }
     */
    public static MemorySegment __p__environ() {
        var mh$ = __p__environ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p__environ");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p__wenviron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER    );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("__p__wenviron");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t ***__p__wenviron()
     * }
     */
    public static FunctionDescriptor __p__wenviron$descriptor() {
        return __p__wenviron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t ***__p__wenviron()
     * }
     */
    public static MethodHandle __p__wenviron$handle() {
        return __p__wenviron.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t ***__p__wenviron()
     * }
     */
    public static MemorySegment __p__wenviron$address() {
        return __p__wenviron.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t ***__p__wenviron()
     * }
     */
    public static MemorySegment __p__wenviron() {
        var mh$ = __p__wenviron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p__wenviron");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("getenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getenv(const char *_VarName)
     * }
     */
    public static FunctionDescriptor getenv$descriptor() {
        return getenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getenv(const char *_VarName)
     * }
     */
    public static MethodHandle getenv$handle() {
        return getenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getenv(const char *_VarName)
     * }
     */
    public static MemorySegment getenv$address() {
        return getenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getenv(const char *_VarName)
     * }
     */
    public static MemorySegment getenv(MemorySegment _VarName) {
        var mh$ = getenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getenv", _VarName);
            }
            return (MemorySegment)mh$.invokeExact(_VarName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dupenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_dupenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _dupenv_s(char **_Buffer, size_t *_BufferCount, const char *_VarName)
     * }
     */
    public static FunctionDescriptor _dupenv_s$descriptor() {
        return _dupenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _dupenv_s(char **_Buffer, size_t *_BufferCount, const char *_VarName)
     * }
     */
    public static MethodHandle _dupenv_s$handle() {
        return _dupenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _dupenv_s(char **_Buffer, size_t *_BufferCount, const char *_VarName)
     * }
     */
    public static MemorySegment _dupenv_s$address() {
        return _dupenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _dupenv_s(char **_Buffer, size_t *_BufferCount, const char *_VarName)
     * }
     */
    public static int _dupenv_s(MemorySegment _Buffer, MemorySegment _BufferCount, MemorySegment _VarName) {
        var mh$ = _dupenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dupenv_s", _Buffer, _BufferCount, _VarName);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _VarName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class system {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("system");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int system(const char *_Command)
     * }
     */
    public static FunctionDescriptor system$descriptor() {
        return system.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int system(const char *_Command)
     * }
     */
    public static MethodHandle system$handle() {
        return system.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int system(const char *_Command)
     * }
     */
    public static MemorySegment system$address() {
        return system.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int system(const char *_Command)
     * }
     */
    public static int system(MemorySegment _Command) {
        var mh$ = system.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("system", _Command);
            }
            return (int)mh$.invokeExact(_Command);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_putenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _putenv(const char *_EnvString)
     * }
     */
    public static FunctionDescriptor _putenv$descriptor() {
        return _putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _putenv(const char *_EnvString)
     * }
     */
    public static MethodHandle _putenv$handle() {
        return _putenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _putenv(const char *_EnvString)
     * }
     */
    public static MemorySegment _putenv$address() {
        return _putenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _putenv(const char *_EnvString)
     * }
     */
    public static int _putenv(MemorySegment _EnvString) {
        var mh$ = _putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putenv", _EnvString);
            }
            return (int)mh$.invokeExact(_EnvString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_putenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _putenv_s(const char *_Name, const char *_Value)
     * }
     */
    public static FunctionDescriptor _putenv_s$descriptor() {
        return _putenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _putenv_s(const char *_Name, const char *_Value)
     * }
     */
    public static MethodHandle _putenv_s$handle() {
        return _putenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _putenv_s(const char *_Name, const char *_Value)
     * }
     */
    public static MemorySegment _putenv_s$address() {
        return _putenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _putenv_s(const char *_Name, const char *_Value)
     * }
     */
    public static int _putenv_s(MemorySegment _Name, MemorySegment _Value) {
        var mh$ = _putenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putenv_s", _Name, _Value);
            }
            return (int)mh$.invokeExact(_Name, _Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _searchenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_searchenv_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _searchenv_s(const char *_Filename, const char *_VarName, char *_Buffer, size_t _BufferCount)
     * }
     */
    public static FunctionDescriptor _searchenv_s$descriptor() {
        return _searchenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _searchenv_s(const char *_Filename, const char *_VarName, char *_Buffer, size_t _BufferCount)
     * }
     */
    public static MethodHandle _searchenv_s$handle() {
        return _searchenv_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _searchenv_s(const char *_Filename, const char *_VarName, char *_Buffer, size_t _BufferCount)
     * }
     */
    public static MemorySegment _searchenv_s$address() {
        return _searchenv_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _searchenv_s(const char *_Filename, const char *_VarName, char *_Buffer, size_t _BufferCount)
     * }
     */
    public static int _searchenv_s(MemorySegment _Filename, MemorySegment _VarName, MemorySegment _Buffer, long _BufferCount) {
        var mh$ = _searchenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_searchenv_s", _Filename, _VarName, _Buffer, _BufferCount);
            }
            return (int)mh$.invokeExact(_Filename, _VarName, _Buffer, _BufferCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _searchenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_searchenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _searchenv(const char *_Filename, const char *_VarName, char *_Buffer)
     * }
     */
    public static FunctionDescriptor _searchenv$descriptor() {
        return _searchenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _searchenv(const char *_Filename, const char *_VarName, char *_Buffer)
     * }
     */
    public static MethodHandle _searchenv$handle() {
        return _searchenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _searchenv(const char *_Filename, const char *_VarName, char *_Buffer)
     * }
     */
    public static MemorySegment _searchenv$address() {
        return _searchenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _searchenv(const char *_Filename, const char *_VarName, char *_Buffer)
     * }
     */
    public static void _searchenv(MemorySegment _Filename, MemorySegment _VarName, MemorySegment _Buffer) {
        var mh$ = _searchenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_searchenv", _Filename, _VarName, _Buffer);
            }
            mh$.invokeExact(_Filename, _VarName, _Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _seterrormode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_seterrormode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _seterrormode(int _Mode)
     * }
     */
    public static FunctionDescriptor _seterrormode$descriptor() {
        return _seterrormode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _seterrormode(int _Mode)
     * }
     */
    public static MethodHandle _seterrormode$handle() {
        return _seterrormode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _seterrormode(int _Mode)
     * }
     */
    public static MemorySegment _seterrormode$address() {
        return _seterrormode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _seterrormode(int _Mode)
     * }
     */
    public static void _seterrormode(int _Mode) {
        var mh$ = _seterrormode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_seterrormode", _Mode);
            }
            mh$.invokeExact(_Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _beep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_beep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _beep(unsigned int _Frequency, unsigned int _Duration)
     * }
     */
    public static FunctionDescriptor _beep$descriptor() {
        return _beep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _beep(unsigned int _Frequency, unsigned int _Duration)
     * }
     */
    public static MethodHandle _beep$handle() {
        return _beep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _beep(unsigned int _Frequency, unsigned int _Duration)
     * }
     */
    public static MemorySegment _beep$address() {
        return _beep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _beep(unsigned int _Frequency, unsigned int _Duration)
     * }
     */
    public static void _beep(int _Frequency, int _Duration) {
        var mh$ = _beep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_beep", _Frequency, _Duration);
            }
            mh$.invokeExact(_Frequency, _Duration);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _sleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_sleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _sleep(unsigned long _Duration)
     * }
     */
    public static FunctionDescriptor _sleep$descriptor() {
        return _sleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _sleep(unsigned long _Duration)
     * }
     */
    public static MethodHandle _sleep$handle() {
        return _sleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _sleep(unsigned long _Duration)
     * }
     */
    public static MemorySegment _sleep$address() {
        return _sleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _sleep(unsigned long _Duration)
     * }
     */
    public static void _sleep(int _Duration) {
        var mh$ = _sleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_sleep", _Duration);
            }
            mh$.invokeExact(_Duration);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("ecvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor ecvt$descriptor() {
        return ecvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle ecvt$handle() {
        return ecvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment ecvt$address() {
        return ecvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment ecvt(double _Value, int _DigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = ecvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt", _Value, _DigitCount, _PtDec, _PtSign);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _DigitCount, _PtDec, _PtSign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("fcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor fcvt$descriptor() {
        return fcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle fcvt$handle() {
        return fcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment fcvt$address() {
        return fcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment fcvt(double _Value, int _FractionalDigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = fcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt", _Value, _FractionalDigitCount, _PtDec, _PtSign);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _FractionalDigitCount, _PtDec, _PtSign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("gcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *gcvt(double _Value, int _DigitCount, char *_DstBuf)
     * }
     */
    public static FunctionDescriptor gcvt$descriptor() {
        return gcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *gcvt(double _Value, int _DigitCount, char *_DstBuf)
     * }
     */
    public static MethodHandle gcvt$handle() {
        return gcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *gcvt(double _Value, int _DigitCount, char *_DstBuf)
     * }
     */
    public static MemorySegment gcvt$address() {
        return gcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *gcvt(double _Value, int _DigitCount, char *_DstBuf)
     * }
     */
    public static MemorySegment gcvt(double _Value, int _DigitCount, MemorySegment _DstBuf) {
        var mh$ = gcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcvt", _Value, _DigitCount, _DstBuf);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _DigitCount, _DstBuf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class itoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("itoa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor itoa$descriptor() {
        return itoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle itoa$handle() {
        return itoa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment itoa$address() {
        return itoa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment itoa(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = itoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("itoa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ltoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("ltoa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor ltoa$descriptor() {
        return ltoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle ltoa$handle() {
        return ltoa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment ltoa$address() {
        return ltoa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment ltoa(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = ltoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ltoa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class swab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("swab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static FunctionDescriptor swab$descriptor() {
        return swab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static MethodHandle swab$handle() {
        return swab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static MemorySegment swab$address() {
        return swab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static void swab(MemorySegment _Buf1, MemorySegment _Buf2, int _SizeInBytes) {
        var mh$ = swab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("swab", _Buf1, _Buf2, _SizeInBytes);
            }
            mh$.invokeExact(_Buf1, _Buf2, _SizeInBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ultoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("ultoa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor ultoa$descriptor() {
        return ultoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle ultoa$handle() {
        return ultoa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment ultoa$address() {
        return ultoa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment ultoa(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = ultoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ultoa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("putenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putenv(const char *_EnvString)
     * }
     */
    public static FunctionDescriptor putenv$descriptor() {
        return putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putenv(const char *_EnvString)
     * }
     */
    public static MethodHandle putenv$handle() {
        return putenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putenv(const char *_EnvString)
     * }
     */
    public static MemorySegment putenv$address() {
        return putenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putenv(const char *_EnvString)
     * }
     */
    public static int putenv(MemorySegment _EnvString) {
        var mh$ = putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putenv", _EnvString);
            }
            return (int)mh$.invokeExact(_EnvString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class onexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("onexit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _onexit_t onexit(_onexit_t _Func)
     * }
     */
    public static FunctionDescriptor onexit$descriptor() {
        return onexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _onexit_t onexit(_onexit_t _Func)
     * }
     */
    public static MethodHandle onexit$handle() {
        return onexit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _onexit_t onexit(_onexit_t _Func)
     * }
     */
    public static MemorySegment onexit$address() {
        return onexit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _onexit_t onexit(_onexit_t _Func)
     * }
     */
    public static MemorySegment onexit(MemorySegment _Func) {
        var mh$ = onexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("onexit", _Func);
            }
            return (MemorySegment)mh$.invokeExact(_Func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int8_t i8
     * }
     */
    public static final OfByte i8 = Cubiomes.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint8_t u8
     * }
     */
    public static final OfByte u8 = Cubiomes.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t i16
     * }
     */
    public static final OfShort i16 = Cubiomes.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint16_t u16
     * }
     */
    public static final OfShort u16 = Cubiomes.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t i32
     * }
     */
    public static final OfInt i32 = Cubiomes.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t u32
     * }
     */
    public static final OfInt u32 = Cubiomes.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t i64
     * }
     */
    public static final OfLong i64 = Cubiomes.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t u64
     * }
     */
    public static final OfLong u64 = Cubiomes.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef float f32
     * }
     */
    public static final OfFloat f32 = Cubiomes.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double f64
     * }
     */
    public static final OfDouble f64 = Cubiomes.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef float float_t
     * }
     */
    public static final OfFloat float_t = Cubiomes.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double double_t
     * }
     */
    public static final OfDouble double_t = Cubiomes.C_DOUBLE;

    private static class _HUGE$constants {
        public static final OfDouble LAYOUT = Cubiomes.C_DOUBLE;
        public static final MemorySegment SEGMENT = Cubiomes.findOrThrow("_HUGE").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const double _HUGE
     * }
     */
    public static OfDouble _HUGE$layout() {
        return _HUGE$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const double _HUGE
     * }
     */
    public static MemorySegment _HUGE$segment() {
        return _HUGE$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const double _HUGE
     * }
     */
    public static double _HUGE() {
        return _HUGE$constants.SEGMENT.get(_HUGE$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const double _HUGE
     * }
     */
    public static void _HUGE(double varValue) {
        _HUGE$constants.SEGMENT.set(_HUGE$constants.LAYOUT, 0L, varValue);
    }

    private static class _fperrraise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_fperrraise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _fperrraise(int _Except)
     * }
     */
    public static FunctionDescriptor _fperrraise$descriptor() {
        return _fperrraise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _fperrraise(int _Except)
     * }
     */
    public static MethodHandle _fperrraise$handle() {
        return _fperrraise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _fperrraise(int _Except)
     * }
     */
    public static MemorySegment _fperrraise$address() {
        return _fperrraise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _fperrraise(int _Except)
     * }
     */
    public static void _fperrraise(int _Except) {
        var mh$ = _fperrraise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fperrraise", _Except);
            }
            mh$.invokeExact(_Except);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dclass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_SHORT,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_dclass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _dclass(double _X)
     * }
     */
    public static FunctionDescriptor _dclass$descriptor() {
        return _dclass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _dclass(double _X)
     * }
     */
    public static MethodHandle _dclass$handle() {
        return _dclass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _dclass(double _X)
     * }
     */
    public static MemorySegment _dclass$address() {
        return _dclass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _dclass(double _X)
     * }
     */
    public static short _dclass(double _X) {
        var mh$ = _dclass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dclass", _X);
            }
            return (short)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldclass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_SHORT,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_ldclass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _ldclass(long double _X)
     * }
     */
    public static FunctionDescriptor _ldclass$descriptor() {
        return _ldclass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _ldclass(long double _X)
     * }
     */
    public static MethodHandle _ldclass$handle() {
        return _ldclass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _ldclass(long double _X)
     * }
     */
    public static MemorySegment _ldclass$address() {
        return _ldclass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _ldclass(long double _X)
     * }
     */
    public static short _ldclass(double _X) {
        var mh$ = _ldclass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldclass", _X);
            }
            return (short)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdclass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_SHORT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_fdclass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _fdclass(float _X)
     * }
     */
    public static FunctionDescriptor _fdclass$descriptor() {
        return _fdclass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _fdclass(float _X)
     * }
     */
    public static MethodHandle _fdclass$handle() {
        return _fdclass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _fdclass(float _X)
     * }
     */
    public static MemorySegment _fdclass$address() {
        return _fdclass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _fdclass(float _X)
     * }
     */
    public static short _fdclass(float _X) {
        var mh$ = _fdclass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdclass", _X);
            }
            return (short)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dsign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_dsign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _dsign(double _X)
     * }
     */
    public static FunctionDescriptor _dsign$descriptor() {
        return _dsign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _dsign(double _X)
     * }
     */
    public static MethodHandle _dsign$handle() {
        return _dsign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _dsign(double _X)
     * }
     */
    public static MemorySegment _dsign$address() {
        return _dsign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _dsign(double _X)
     * }
     */
    public static int _dsign(double _X) {
        var mh$ = _dsign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dsign", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldsign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_ldsign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _ldsign(long double _X)
     * }
     */
    public static FunctionDescriptor _ldsign$descriptor() {
        return _ldsign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _ldsign(long double _X)
     * }
     */
    public static MethodHandle _ldsign$handle() {
        return _ldsign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _ldsign(long double _X)
     * }
     */
    public static MemorySegment _ldsign$address() {
        return _ldsign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _ldsign(long double _X)
     * }
     */
    public static int _ldsign(double _X) {
        var mh$ = _ldsign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldsign", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdsign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_fdsign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fdsign(float _X)
     * }
     */
    public static FunctionDescriptor _fdsign$descriptor() {
        return _fdsign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fdsign(float _X)
     * }
     */
    public static MethodHandle _fdsign$handle() {
        return _fdsign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fdsign(float _X)
     * }
     */
    public static MemorySegment _fdsign$address() {
        return _fdsign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fdsign(float _X)
     * }
     */
    public static int _fdsign(float _X) {
        var mh$ = _fdsign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdsign", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dpcomp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_dpcomp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _dpcomp(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor _dpcomp$descriptor() {
        return _dpcomp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _dpcomp(double _X, double _Y)
     * }
     */
    public static MethodHandle _dpcomp$handle() {
        return _dpcomp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _dpcomp(double _X, double _Y)
     * }
     */
    public static MemorySegment _dpcomp$address() {
        return _dpcomp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _dpcomp(double _X, double _Y)
     * }
     */
    public static int _dpcomp(double _X, double _Y) {
        var mh$ = _dpcomp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dpcomp", _X, _Y);
            }
            return (int)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldpcomp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_ldpcomp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _ldpcomp(long double _X, long double _Y)
     * }
     */
    public static FunctionDescriptor _ldpcomp$descriptor() {
        return _ldpcomp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _ldpcomp(long double _X, long double _Y)
     * }
     */
    public static MethodHandle _ldpcomp$handle() {
        return _ldpcomp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _ldpcomp(long double _X, long double _Y)
     * }
     */
    public static MemorySegment _ldpcomp$address() {
        return _ldpcomp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _ldpcomp(long double _X, long double _Y)
     * }
     */
    public static int _ldpcomp(double _X, double _Y) {
        var mh$ = _ldpcomp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldpcomp", _X, _Y);
            }
            return (int)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdpcomp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_fdpcomp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fdpcomp(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor _fdpcomp$descriptor() {
        return _fdpcomp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fdpcomp(float _X, float _Y)
     * }
     */
    public static MethodHandle _fdpcomp$handle() {
        return _fdpcomp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fdpcomp(float _X, float _Y)
     * }
     */
    public static MemorySegment _fdpcomp$address() {
        return _fdpcomp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fdpcomp(float _X, float _Y)
     * }
     */
    public static int _fdpcomp(float _X, float _Y) {
        var mh$ = _fdpcomp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdpcomp", _X, _Y);
            }
            return (int)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dtest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_SHORT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_dtest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _dtest(double *_Px)
     * }
     */
    public static FunctionDescriptor _dtest$descriptor() {
        return _dtest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _dtest(double *_Px)
     * }
     */
    public static MethodHandle _dtest$handle() {
        return _dtest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _dtest(double *_Px)
     * }
     */
    public static MemorySegment _dtest$address() {
        return _dtest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _dtest(double *_Px)
     * }
     */
    public static short _dtest(MemorySegment _Px) {
        var mh$ = _dtest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dtest", _Px);
            }
            return (short)mh$.invokeExact(_Px);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldtest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_SHORT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_ldtest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _ldtest(long double *_Px)
     * }
     */
    public static FunctionDescriptor _ldtest$descriptor() {
        return _ldtest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _ldtest(long double *_Px)
     * }
     */
    public static MethodHandle _ldtest$handle() {
        return _ldtest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _ldtest(long double *_Px)
     * }
     */
    public static MemorySegment _ldtest$address() {
        return _ldtest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _ldtest(long double *_Px)
     * }
     */
    public static short _ldtest(MemorySegment _Px) {
        var mh$ = _ldtest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldtest", _Px);
            }
            return (short)mh$.invokeExact(_Px);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdtest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_SHORT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_fdtest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _fdtest(float *_Px)
     * }
     */
    public static FunctionDescriptor _fdtest$descriptor() {
        return _fdtest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _fdtest(float *_Px)
     * }
     */
    public static MethodHandle _fdtest$handle() {
        return _fdtest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _fdtest(float *_Px)
     * }
     */
    public static MemorySegment _fdtest$address() {
        return _fdtest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _fdtest(float *_Px)
     * }
     */
    public static short _fdtest(MemorySegment _Px) {
        var mh$ = _fdtest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdtest", _Px);
            }
            return (short)mh$.invokeExact(_Px);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _d_int {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_SHORT,
            Cubiomes.C_POINTER,
            Cubiomes.C_SHORT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_d_int");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _d_int(double *_Px, short _Xexp)
     * }
     */
    public static FunctionDescriptor _d_int$descriptor() {
        return _d_int.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _d_int(double *_Px, short _Xexp)
     * }
     */
    public static MethodHandle _d_int$handle() {
        return _d_int.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _d_int(double *_Px, short _Xexp)
     * }
     */
    public static MemorySegment _d_int$address() {
        return _d_int.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _d_int(double *_Px, short _Xexp)
     * }
     */
    public static short _d_int(MemorySegment _Px, short _Xexp) {
        var mh$ = _d_int.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_d_int", _Px, _Xexp);
            }
            return (short)mh$.invokeExact(_Px, _Xexp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ld_int {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_SHORT,
            Cubiomes.C_POINTER,
            Cubiomes.C_SHORT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_ld_int");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _ld_int(long double *_Px, short _Xexp)
     * }
     */
    public static FunctionDescriptor _ld_int$descriptor() {
        return _ld_int.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _ld_int(long double *_Px, short _Xexp)
     * }
     */
    public static MethodHandle _ld_int$handle() {
        return _ld_int.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _ld_int(long double *_Px, short _Xexp)
     * }
     */
    public static MemorySegment _ld_int$address() {
        return _ld_int.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _ld_int(long double *_Px, short _Xexp)
     * }
     */
    public static short _ld_int(MemorySegment _Px, short _Xexp) {
        var mh$ = _ld_int.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ld_int", _Px, _Xexp);
            }
            return (short)mh$.invokeExact(_Px, _Xexp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fd_int {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_SHORT,
            Cubiomes.C_POINTER,
            Cubiomes.C_SHORT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_fd_int");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _fd_int(float *_Px, short _Xexp)
     * }
     */
    public static FunctionDescriptor _fd_int$descriptor() {
        return _fd_int.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _fd_int(float *_Px, short _Xexp)
     * }
     */
    public static MethodHandle _fd_int$handle() {
        return _fd_int.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _fd_int(float *_Px, short _Xexp)
     * }
     */
    public static MemorySegment _fd_int$address() {
        return _fd_int.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _fd_int(float *_Px, short _Xexp)
     * }
     */
    public static short _fd_int(MemorySegment _Px, short _Xexp) {
        var mh$ = _fd_int.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fd_int", _Px, _Xexp);
            }
            return (short)mh$.invokeExact(_Px, _Xexp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dscale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_SHORT,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_dscale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _dscale(double *_Px, long _Lexp)
     * }
     */
    public static FunctionDescriptor _dscale$descriptor() {
        return _dscale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _dscale(double *_Px, long _Lexp)
     * }
     */
    public static MethodHandle _dscale$handle() {
        return _dscale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _dscale(double *_Px, long _Lexp)
     * }
     */
    public static MemorySegment _dscale$address() {
        return _dscale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _dscale(double *_Px, long _Lexp)
     * }
     */
    public static short _dscale(MemorySegment _Px, int _Lexp) {
        var mh$ = _dscale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dscale", _Px, _Lexp);
            }
            return (short)mh$.invokeExact(_Px, _Lexp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldscale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_SHORT,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_ldscale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _ldscale(long double *_Px, long _Lexp)
     * }
     */
    public static FunctionDescriptor _ldscale$descriptor() {
        return _ldscale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _ldscale(long double *_Px, long _Lexp)
     * }
     */
    public static MethodHandle _ldscale$handle() {
        return _ldscale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _ldscale(long double *_Px, long _Lexp)
     * }
     */
    public static MemorySegment _ldscale$address() {
        return _ldscale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _ldscale(long double *_Px, long _Lexp)
     * }
     */
    public static short _ldscale(MemorySegment _Px, int _Lexp) {
        var mh$ = _ldscale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldscale", _Px, _Lexp);
            }
            return (short)mh$.invokeExact(_Px, _Lexp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdscale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_SHORT,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_fdscale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _fdscale(float *_Px, long _Lexp)
     * }
     */
    public static FunctionDescriptor _fdscale$descriptor() {
        return _fdscale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _fdscale(float *_Px, long _Lexp)
     * }
     */
    public static MethodHandle _fdscale$handle() {
        return _fdscale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _fdscale(float *_Px, long _Lexp)
     * }
     */
    public static MemorySegment _fdscale$address() {
        return _fdscale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _fdscale(float *_Px, long _Lexp)
     * }
     */
    public static short _fdscale(MemorySegment _Px, int _Lexp) {
        var mh$ = _fdscale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdscale", _Px, _Lexp);
            }
            return (short)mh$.invokeExact(_Px, _Lexp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dunscale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_SHORT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_dunscale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _dunscale(short *_Pex, double *_Px)
     * }
     */
    public static FunctionDescriptor _dunscale$descriptor() {
        return _dunscale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _dunscale(short *_Pex, double *_Px)
     * }
     */
    public static MethodHandle _dunscale$handle() {
        return _dunscale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _dunscale(short *_Pex, double *_Px)
     * }
     */
    public static MemorySegment _dunscale$address() {
        return _dunscale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _dunscale(short *_Pex, double *_Px)
     * }
     */
    public static short _dunscale(MemorySegment _Pex, MemorySegment _Px) {
        var mh$ = _dunscale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dunscale", _Pex, _Px);
            }
            return (short)mh$.invokeExact(_Pex, _Px);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldunscale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_SHORT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_ldunscale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _ldunscale(short *_Pex, long double *_Px)
     * }
     */
    public static FunctionDescriptor _ldunscale$descriptor() {
        return _ldunscale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _ldunscale(short *_Pex, long double *_Px)
     * }
     */
    public static MethodHandle _ldunscale$handle() {
        return _ldunscale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _ldunscale(short *_Pex, long double *_Px)
     * }
     */
    public static MemorySegment _ldunscale$address() {
        return _ldunscale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _ldunscale(short *_Pex, long double *_Px)
     * }
     */
    public static short _ldunscale(MemorySegment _Pex, MemorySegment _Px) {
        var mh$ = _ldunscale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldunscale", _Pex, _Px);
            }
            return (short)mh$.invokeExact(_Pex, _Px);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdunscale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_SHORT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_fdunscale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _fdunscale(short *_Pex, float *_Px)
     * }
     */
    public static FunctionDescriptor _fdunscale$descriptor() {
        return _fdunscale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _fdunscale(short *_Pex, float *_Px)
     * }
     */
    public static MethodHandle _fdunscale$handle() {
        return _fdunscale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _fdunscale(short *_Pex, float *_Px)
     * }
     */
    public static MemorySegment _fdunscale$address() {
        return _fdunscale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _fdunscale(short *_Pex, float *_Px)
     * }
     */
    public static short _fdunscale(MemorySegment _Pex, MemorySegment _Px) {
        var mh$ = _fdunscale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdunscale", _Pex, _Px);
            }
            return (short)mh$.invokeExact(_Pex, _Px);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_SHORT,
            Cubiomes.C_POINTER,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_dexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _dexp(double *_Px, double _Y, long _Eoff)
     * }
     */
    public static FunctionDescriptor _dexp$descriptor() {
        return _dexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _dexp(double *_Px, double _Y, long _Eoff)
     * }
     */
    public static MethodHandle _dexp$handle() {
        return _dexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _dexp(double *_Px, double _Y, long _Eoff)
     * }
     */
    public static MemorySegment _dexp$address() {
        return _dexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _dexp(double *_Px, double _Y, long _Eoff)
     * }
     */
    public static short _dexp(MemorySegment _Px, double _Y, int _Eoff) {
        var mh$ = _dexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dexp", _Px, _Y, _Eoff);
            }
            return (short)mh$.invokeExact(_Px, _Y, _Eoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_SHORT,
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_ldexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _ldexp(long double *_Px, long double _Y, long _Eoff)
     * }
     */
    public static FunctionDescriptor _ldexp$descriptor() {
        return _ldexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _ldexp(long double *_Px, long double _Y, long _Eoff)
     * }
     */
    public static MethodHandle _ldexp$handle() {
        return _ldexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _ldexp(long double *_Px, long double _Y, long _Eoff)
     * }
     */
    public static MemorySegment _ldexp$address() {
        return _ldexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _ldexp(long double *_Px, long double _Y, long _Eoff)
     * }
     */
    public static short _ldexp(MemorySegment _Px, double _Y, int _Eoff) {
        var mh$ = _ldexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldexp", _Px, _Y, _Eoff);
            }
            return (short)mh$.invokeExact(_Px, _Y, _Eoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_SHORT,
            Cubiomes.C_POINTER,
            Cubiomes.C_FLOAT,
            Cubiomes.C_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_fdexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _fdexp(float *_Px, float _Y, long _Eoff)
     * }
     */
    public static FunctionDescriptor _fdexp$descriptor() {
        return _fdexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _fdexp(float *_Px, float _Y, long _Eoff)
     * }
     */
    public static MethodHandle _fdexp$handle() {
        return _fdexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _fdexp(float *_Px, float _Y, long _Eoff)
     * }
     */
    public static MemorySegment _fdexp$address() {
        return _fdexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _fdexp(float *_Px, float _Y, long _Eoff)
     * }
     */
    public static short _fdexp(MemorySegment _Px, float _Y, int _Eoff) {
        var mh$ = _fdexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdexp", _Px, _Y, _Eoff);
            }
            return (short)mh$.invokeExact(_Px, _Y, _Eoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dnorm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_SHORT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_dnorm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _dnorm(unsigned short *_Ps)
     * }
     */
    public static FunctionDescriptor _dnorm$descriptor() {
        return _dnorm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _dnorm(unsigned short *_Ps)
     * }
     */
    public static MethodHandle _dnorm$handle() {
        return _dnorm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _dnorm(unsigned short *_Ps)
     * }
     */
    public static MemorySegment _dnorm$address() {
        return _dnorm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _dnorm(unsigned short *_Ps)
     * }
     */
    public static short _dnorm(MemorySegment _Ps) {
        var mh$ = _dnorm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dnorm", _Ps);
            }
            return (short)mh$.invokeExact(_Ps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdnorm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_SHORT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_fdnorm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * short _fdnorm(unsigned short *_Ps)
     * }
     */
    public static FunctionDescriptor _fdnorm$descriptor() {
        return _fdnorm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * short _fdnorm(unsigned short *_Ps)
     * }
     */
    public static MethodHandle _fdnorm$handle() {
        return _fdnorm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * short _fdnorm(unsigned short *_Ps)
     * }
     */
    public static MemorySegment _fdnorm$address() {
        return _fdnorm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * short _fdnorm(unsigned short *_Ps)
     * }
     */
    public static short _fdnorm(MemorySegment _Ps) {
        var mh$ = _fdnorm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdnorm", _Ps);
            }
            return (short)mh$.invokeExact(_Ps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dpoly {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_dpoly");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _dpoly(double _X, const double *_Tab, int _N)
     * }
     */
    public static FunctionDescriptor _dpoly$descriptor() {
        return _dpoly.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _dpoly(double _X, const double *_Tab, int _N)
     * }
     */
    public static MethodHandle _dpoly$handle() {
        return _dpoly.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _dpoly(double _X, const double *_Tab, int _N)
     * }
     */
    public static MemorySegment _dpoly$address() {
        return _dpoly.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _dpoly(double _X, const double *_Tab, int _N)
     * }
     */
    public static double _dpoly(double _X, MemorySegment _Tab, int _N) {
        var mh$ = _dpoly.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dpoly", _X, _Tab, _N);
            }
            return (double)mh$.invokeExact(_X, _Tab, _N);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldpoly {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_ldpoly");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double _ldpoly(long double _X, const long double *_Tab, int _N)
     * }
     */
    public static FunctionDescriptor _ldpoly$descriptor() {
        return _ldpoly.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double _ldpoly(long double _X, const long double *_Tab, int _N)
     * }
     */
    public static MethodHandle _ldpoly$handle() {
        return _ldpoly.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double _ldpoly(long double _X, const long double *_Tab, int _N)
     * }
     */
    public static MemorySegment _ldpoly$address() {
        return _ldpoly.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double _ldpoly(long double _X, const long double *_Tab, int _N)
     * }
     */
    public static double _ldpoly(double _X, MemorySegment _Tab, int _N) {
        var mh$ = _ldpoly.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldpoly", _X, _Tab, _N);
            }
            return (double)mh$.invokeExact(_X, _Tab, _N);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdpoly {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_fdpoly");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _fdpoly(float _X, const float *_Tab, int _N)
     * }
     */
    public static FunctionDescriptor _fdpoly$descriptor() {
        return _fdpoly.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _fdpoly(float _X, const float *_Tab, int _N)
     * }
     */
    public static MethodHandle _fdpoly$handle() {
        return _fdpoly.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _fdpoly(float _X, const float *_Tab, int _N)
     * }
     */
    public static MemorySegment _fdpoly$address() {
        return _fdpoly.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _fdpoly(float _X, const float *_Tab, int _N)
     * }
     */
    public static float _fdpoly(float _X, MemorySegment _Tab, int _N) {
        var mh$ = _fdpoly.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdpoly", _X, _Tab, _N);
            }
            return (float)mh$.invokeExact(_X, _Tab, _N);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dlog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_dlog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _dlog(double _X, int _Baseflag)
     * }
     */
    public static FunctionDescriptor _dlog$descriptor() {
        return _dlog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _dlog(double _X, int _Baseflag)
     * }
     */
    public static MethodHandle _dlog$handle() {
        return _dlog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _dlog(double _X, int _Baseflag)
     * }
     */
    public static MemorySegment _dlog$address() {
        return _dlog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _dlog(double _X, int _Baseflag)
     * }
     */
    public static double _dlog(double _X, int _Baseflag) {
        var mh$ = _dlog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dlog", _X, _Baseflag);
            }
            return (double)mh$.invokeExact(_X, _Baseflag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldlog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_ldlog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double _ldlog(long double _X, int _Baseflag)
     * }
     */
    public static FunctionDescriptor _ldlog$descriptor() {
        return _ldlog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double _ldlog(long double _X, int _Baseflag)
     * }
     */
    public static MethodHandle _ldlog$handle() {
        return _ldlog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double _ldlog(long double _X, int _Baseflag)
     * }
     */
    public static MemorySegment _ldlog$address() {
        return _ldlog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double _ldlog(long double _X, int _Baseflag)
     * }
     */
    public static double _ldlog(double _X, int _Baseflag) {
        var mh$ = _ldlog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldlog", _X, _Baseflag);
            }
            return (double)mh$.invokeExact(_X, _Baseflag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdlog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_fdlog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _fdlog(float _X, int _Baseflag)
     * }
     */
    public static FunctionDescriptor _fdlog$descriptor() {
        return _fdlog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _fdlog(float _X, int _Baseflag)
     * }
     */
    public static MethodHandle _fdlog$handle() {
        return _fdlog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _fdlog(float _X, int _Baseflag)
     * }
     */
    public static MemorySegment _fdlog$address() {
        return _fdlog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _fdlog(float _X, int _Baseflag)
     * }
     */
    public static float _fdlog(float _X, int _Baseflag) {
        var mh$ = _fdlog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdlog", _X, _Baseflag);
            }
            return (float)mh$.invokeExact(_X, _Baseflag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dsin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_dsin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _dsin(double _X, unsigned int _Qoff)
     * }
     */
    public static FunctionDescriptor _dsin$descriptor() {
        return _dsin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _dsin(double _X, unsigned int _Qoff)
     * }
     */
    public static MethodHandle _dsin$handle() {
        return _dsin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _dsin(double _X, unsigned int _Qoff)
     * }
     */
    public static MemorySegment _dsin$address() {
        return _dsin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _dsin(double _X, unsigned int _Qoff)
     * }
     */
    public static double _dsin(double _X, int _Qoff) {
        var mh$ = _dsin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dsin", _X, _Qoff);
            }
            return (double)mh$.invokeExact(_X, _Qoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ldsin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_ldsin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double _ldsin(long double _X, unsigned int _Qoff)
     * }
     */
    public static FunctionDescriptor _ldsin$descriptor() {
        return _ldsin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double _ldsin(long double _X, unsigned int _Qoff)
     * }
     */
    public static MethodHandle _ldsin$handle() {
        return _ldsin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double _ldsin(long double _X, unsigned int _Qoff)
     * }
     */
    public static MemorySegment _ldsin$address() {
        return _ldsin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double _ldsin(long double _X, unsigned int _Qoff)
     * }
     */
    public static double _ldsin(double _X, int _Qoff) {
        var mh$ = _ldsin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ldsin", _X, _Qoff);
            }
            return (double)mh$.invokeExact(_X, _Qoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdsin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_fdsin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _fdsin(float _X, unsigned int _Qoff)
     * }
     */
    public static FunctionDescriptor _fdsin$descriptor() {
        return _fdsin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _fdsin(float _X, unsigned int _Qoff)
     * }
     */
    public static MethodHandle _fdsin$handle() {
        return _fdsin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _fdsin(float _X, unsigned int _Qoff)
     * }
     */
    public static MemorySegment _fdsin$address() {
        return _fdsin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _fdsin(float _X, unsigned int _Qoff)
     * }
     */
    public static float _fdsin(float _X, int _Qoff) {
        var mh$ = _fdsin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdsin", _X, _Qoff);
            }
            return (float)mh$.invokeExact(_X, _Qoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Denorm_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Cubiomes.findOrThrow("_Denorm_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _Denorm_C
     * }
     */
    public static GroupLayout _Denorm_C$layout() {
        return _Denorm_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Denorm_C
     * }
     */
    public static MemorySegment _Denorm_C() {
        return _Denorm_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Denorm_C
     * }
     */
    public static void _Denorm_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Denorm_C$constants.SEGMENT, 0L, _Denorm_C$constants.LAYOUT.byteSize());
    }

    private static class _Inf_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Cubiomes.findOrThrow("_Inf_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _Inf_C
     * }
     */
    public static GroupLayout _Inf_C$layout() {
        return _Inf_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Inf_C
     * }
     */
    public static MemorySegment _Inf_C() {
        return _Inf_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Inf_C
     * }
     */
    public static void _Inf_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Inf_C$constants.SEGMENT, 0L, _Inf_C$constants.LAYOUT.byteSize());
    }

    private static class _Nan_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Cubiomes.findOrThrow("_Nan_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _Nan_C
     * }
     */
    public static GroupLayout _Nan_C$layout() {
        return _Nan_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Nan_C
     * }
     */
    public static MemorySegment _Nan_C() {
        return _Nan_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Nan_C
     * }
     */
    public static void _Nan_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Nan_C$constants.SEGMENT, 0L, _Nan_C$constants.LAYOUT.byteSize());
    }

    private static class _Snan_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Cubiomes.findOrThrow("_Snan_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _Snan_C
     * }
     */
    public static GroupLayout _Snan_C$layout() {
        return _Snan_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Snan_C
     * }
     */
    public static MemorySegment _Snan_C() {
        return _Snan_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Snan_C
     * }
     */
    public static void _Snan_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Snan_C$constants.SEGMENT, 0L, _Snan_C$constants.LAYOUT.byteSize());
    }

    private static class _Hugeval_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Cubiomes.findOrThrow("_Hugeval_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _Hugeval_C
     * }
     */
    public static GroupLayout _Hugeval_C$layout() {
        return _Hugeval_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Hugeval_C
     * }
     */
    public static MemorySegment _Hugeval_C() {
        return _Hugeval_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Hugeval_C
     * }
     */
    public static void _Hugeval_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Hugeval_C$constants.SEGMENT, 0L, _Hugeval_C$constants.LAYOUT.byteSize());
    }

    private static class _FDenorm_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Cubiomes.findOrThrow("_FDenorm_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _FDenorm_C
     * }
     */
    public static GroupLayout _FDenorm_C$layout() {
        return _FDenorm_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FDenorm_C
     * }
     */
    public static MemorySegment _FDenorm_C() {
        return _FDenorm_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FDenorm_C
     * }
     */
    public static void _FDenorm_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _FDenorm_C$constants.SEGMENT, 0L, _FDenorm_C$constants.LAYOUT.byteSize());
    }

    private static class _FInf_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Cubiomes.findOrThrow("_FInf_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _FInf_C
     * }
     */
    public static GroupLayout _FInf_C$layout() {
        return _FInf_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FInf_C
     * }
     */
    public static MemorySegment _FInf_C() {
        return _FInf_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FInf_C
     * }
     */
    public static void _FInf_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _FInf_C$constants.SEGMENT, 0L, _FInf_C$constants.LAYOUT.byteSize());
    }

    private static class _FNan_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Cubiomes.findOrThrow("_FNan_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _FNan_C
     * }
     */
    public static GroupLayout _FNan_C$layout() {
        return _FNan_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FNan_C
     * }
     */
    public static MemorySegment _FNan_C() {
        return _FNan_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FNan_C
     * }
     */
    public static void _FNan_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _FNan_C$constants.SEGMENT, 0L, _FNan_C$constants.LAYOUT.byteSize());
    }

    private static class _FSnan_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Cubiomes.findOrThrow("_FSnan_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _FSnan_C
     * }
     */
    public static GroupLayout _FSnan_C$layout() {
        return _FSnan_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FSnan_C
     * }
     */
    public static MemorySegment _FSnan_C() {
        return _FSnan_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FSnan_C
     * }
     */
    public static void _FSnan_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _FSnan_C$constants.SEGMENT, 0L, _FSnan_C$constants.LAYOUT.byteSize());
    }

    private static class _LDenorm_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Cubiomes.findOrThrow("_LDenorm_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _LDenorm_C
     * }
     */
    public static GroupLayout _LDenorm_C$layout() {
        return _LDenorm_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LDenorm_C
     * }
     */
    public static MemorySegment _LDenorm_C() {
        return _LDenorm_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LDenorm_C
     * }
     */
    public static void _LDenorm_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _LDenorm_C$constants.SEGMENT, 0L, _LDenorm_C$constants.LAYOUT.byteSize());
    }

    private static class _LInf_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Cubiomes.findOrThrow("_LInf_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _LInf_C
     * }
     */
    public static GroupLayout _LInf_C$layout() {
        return _LInf_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LInf_C
     * }
     */
    public static MemorySegment _LInf_C() {
        return _LInf_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LInf_C
     * }
     */
    public static void _LInf_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _LInf_C$constants.SEGMENT, 0L, _LInf_C$constants.LAYOUT.byteSize());
    }

    private static class _LNan_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Cubiomes.findOrThrow("_LNan_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _LNan_C
     * }
     */
    public static GroupLayout _LNan_C$layout() {
        return _LNan_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LNan_C
     * }
     */
    public static MemorySegment _LNan_C() {
        return _LNan_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LNan_C
     * }
     */
    public static void _LNan_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _LNan_C$constants.SEGMENT, 0L, _LNan_C$constants.LAYOUT.byteSize());
    }

    private static class _LSnan_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Cubiomes.findOrThrow("_LSnan_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _LSnan_C
     * }
     */
    public static GroupLayout _LSnan_C$layout() {
        return _LSnan_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LSnan_C
     * }
     */
    public static MemorySegment _LSnan_C() {
        return _LSnan_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LSnan_C
     * }
     */
    public static void _LSnan_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _LSnan_C$constants.SEGMENT, 0L, _LSnan_C$constants.LAYOUT.byteSize());
    }

    private static class _Eps_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Cubiomes.findOrThrow("_Eps_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _Eps_C
     * }
     */
    public static GroupLayout _Eps_C$layout() {
        return _Eps_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Eps_C
     * }
     */
    public static MemorySegment _Eps_C() {
        return _Eps_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Eps_C
     * }
     */
    public static void _Eps_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Eps_C$constants.SEGMENT, 0L, _Eps_C$constants.LAYOUT.byteSize());
    }

    private static class _Rteps_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Cubiomes.findOrThrow("_Rteps_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _Rteps_C
     * }
     */
    public static GroupLayout _Rteps_C$layout() {
        return _Rteps_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Rteps_C
     * }
     */
    public static MemorySegment _Rteps_C() {
        return _Rteps_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _Rteps_C
     * }
     */
    public static void _Rteps_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _Rteps_C$constants.SEGMENT, 0L, _Rteps_C$constants.LAYOUT.byteSize());
    }

    private static class _FEps_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Cubiomes.findOrThrow("_FEps_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _FEps_C
     * }
     */
    public static GroupLayout _FEps_C$layout() {
        return _FEps_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FEps_C
     * }
     */
    public static MemorySegment _FEps_C() {
        return _FEps_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FEps_C
     * }
     */
    public static void _FEps_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _FEps_C$constants.SEGMENT, 0L, _FEps_C$constants.LAYOUT.byteSize());
    }

    private static class _FRteps_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Cubiomes.findOrThrow("_FRteps_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _FRteps_C
     * }
     */
    public static GroupLayout _FRteps_C$layout() {
        return _FRteps_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FRteps_C
     * }
     */
    public static MemorySegment _FRteps_C() {
        return _FRteps_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _FRteps_C
     * }
     */
    public static void _FRteps_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _FRteps_C$constants.SEGMENT, 0L, _FRteps_C$constants.LAYOUT.byteSize());
    }

    private static class _LEps_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Cubiomes.findOrThrow("_LEps_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _LEps_C
     * }
     */
    public static GroupLayout _LEps_C$layout() {
        return _LEps_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LEps_C
     * }
     */
    public static MemorySegment _LEps_C() {
        return _LEps_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LEps_C
     * }
     */
    public static void _LEps_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _LEps_C$constants.SEGMENT, 0L, _LEps_C$constants.LAYOUT.byteSize());
    }

    private static class _LRteps_C$constants {
        public static final GroupLayout LAYOUT = _float_const.layout();
        public static final MemorySegment SEGMENT = Cubiomes.findOrThrow("_LRteps_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const _float_const _LRteps_C
     * }
     */
    public static GroupLayout _LRteps_C$layout() {
        return _LRteps_C$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LRteps_C
     * }
     */
    public static MemorySegment _LRteps_C() {
        return _LRteps_C$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const _float_const _LRteps_C
     * }
     */
    public static void _LRteps_C(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, _LRteps_C$constants.SEGMENT, 0L, _LRteps_C$constants.LAYOUT.byteSize());
    }

    private static class _Zero_C$constants {
        public static final OfDouble LAYOUT = Cubiomes.C_DOUBLE;
        public static final MemorySegment SEGMENT = Cubiomes.findOrThrow("_Zero_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const double _Zero_C
     * }
     */
    public static OfDouble _Zero_C$layout() {
        return _Zero_C$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const double _Zero_C
     * }
     */
    public static MemorySegment _Zero_C$segment() {
        return _Zero_C$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const double _Zero_C
     * }
     */
    public static double _Zero_C() {
        return _Zero_C$constants.SEGMENT.get(_Zero_C$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const double _Zero_C
     * }
     */
    public static void _Zero_C(double varValue) {
        _Zero_C$constants.SEGMENT.set(_Zero_C$constants.LAYOUT, 0L, varValue);
    }

    private static class _Xbig_C$constants {
        public static final OfDouble LAYOUT = Cubiomes.C_DOUBLE;
        public static final MemorySegment SEGMENT = Cubiomes.findOrThrow("_Xbig_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const double _Xbig_C
     * }
     */
    public static OfDouble _Xbig_C$layout() {
        return _Xbig_C$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const double _Xbig_C
     * }
     */
    public static MemorySegment _Xbig_C$segment() {
        return _Xbig_C$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const double _Xbig_C
     * }
     */
    public static double _Xbig_C() {
        return _Xbig_C$constants.SEGMENT.get(_Xbig_C$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const double _Xbig_C
     * }
     */
    public static void _Xbig_C(double varValue) {
        _Xbig_C$constants.SEGMENT.set(_Xbig_C$constants.LAYOUT, 0L, varValue);
    }

    private static class _FZero_C$constants {
        public static final OfFloat LAYOUT = Cubiomes.C_FLOAT;
        public static final MemorySegment SEGMENT = Cubiomes.findOrThrow("_FZero_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const float _FZero_C
     * }
     */
    public static OfFloat _FZero_C$layout() {
        return _FZero_C$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const float _FZero_C
     * }
     */
    public static MemorySegment _FZero_C$segment() {
        return _FZero_C$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const float _FZero_C
     * }
     */
    public static float _FZero_C() {
        return _FZero_C$constants.SEGMENT.get(_FZero_C$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const float _FZero_C
     * }
     */
    public static void _FZero_C(float varValue) {
        _FZero_C$constants.SEGMENT.set(_FZero_C$constants.LAYOUT, 0L, varValue);
    }

    private static class _FXbig_C$constants {
        public static final OfFloat LAYOUT = Cubiomes.C_FLOAT;
        public static final MemorySegment SEGMENT = Cubiomes.findOrThrow("_FXbig_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const float _FXbig_C
     * }
     */
    public static OfFloat _FXbig_C$layout() {
        return _FXbig_C$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const float _FXbig_C
     * }
     */
    public static MemorySegment _FXbig_C$segment() {
        return _FXbig_C$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const float _FXbig_C
     * }
     */
    public static float _FXbig_C() {
        return _FXbig_C$constants.SEGMENT.get(_FXbig_C$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const float _FXbig_C
     * }
     */
    public static void _FXbig_C(float varValue) {
        _FXbig_C$constants.SEGMENT.set(_FXbig_C$constants.LAYOUT, 0L, varValue);
    }

    private static class _LZero_C$constants {
        public static final OfDouble LAYOUT = Cubiomes.C_LONG_DOUBLE;
        public static final MemorySegment SEGMENT = Cubiomes.findOrThrow("_LZero_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const long double _LZero_C
     * }
     */
    public static OfDouble _LZero_C$layout() {
        return _LZero_C$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const long double _LZero_C
     * }
     */
    public static MemorySegment _LZero_C$segment() {
        return _LZero_C$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const long double _LZero_C
     * }
     */
    public static double _LZero_C() {
        return _LZero_C$constants.SEGMENT.get(_LZero_C$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const long double _LZero_C
     * }
     */
    public static void _LZero_C(double varValue) {
        _LZero_C$constants.SEGMENT.set(_LZero_C$constants.LAYOUT, 0L, varValue);
    }

    private static class _LXbig_C$constants {
        public static final OfDouble LAYOUT = Cubiomes.C_LONG_DOUBLE;
        public static final MemorySegment SEGMENT = Cubiomes.findOrThrow("_LXbig_C").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const long double _LXbig_C
     * }
     */
    public static OfDouble _LXbig_C$layout() {
        return _LXbig_C$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const long double _LXbig_C
     * }
     */
    public static MemorySegment _LXbig_C$segment() {
        return _LXbig_C$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const long double _LXbig_C
     * }
     */
    public static double _LXbig_C() {
        return _LXbig_C$constants.SEGMENT.get(_LXbig_C$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const long double _LXbig_C
     * }
     */
    public static void _LXbig_C(double varValue) {
        _LXbig_C$constants.SEGMENT.set(_LXbig_C$constants.LAYOUT, 0L, varValue);
    }

    private static class acos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("acos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double acos(double _X)
     * }
     */
    public static FunctionDescriptor acos$descriptor() {
        return acos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double acos(double _X)
     * }
     */
    public static MethodHandle acos$handle() {
        return acos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double acos(double _X)
     * }
     */
    public static MemorySegment acos$address() {
        return acos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double acos(double _X)
     * }
     */
    public static double acos(double _X) {
        var mh$ = acos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acos", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("asin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double asin(double _X)
     * }
     */
    public static FunctionDescriptor asin$descriptor() {
        return asin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double asin(double _X)
     * }
     */
    public static MethodHandle asin$handle() {
        return asin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double asin(double _X)
     * }
     */
    public static MemorySegment asin$address() {
        return asin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double asin(double _X)
     * }
     */
    public static double asin(double _X) {
        var mh$ = asin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asin", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("atan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double atan(double _X)
     * }
     */
    public static FunctionDescriptor atan$descriptor() {
        return atan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double atan(double _X)
     * }
     */
    public static MethodHandle atan$handle() {
        return atan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double atan(double _X)
     * }
     */
    public static MemorySegment atan$address() {
        return atan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double atan(double _X)
     * }
     */
    public static double atan(double _X) {
        var mh$ = atan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atan", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atan2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("atan2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double atan2(double _Y, double _X)
     * }
     */
    public static FunctionDescriptor atan2$descriptor() {
        return atan2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double atan2(double _Y, double _X)
     * }
     */
    public static MethodHandle atan2$handle() {
        return atan2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double atan2(double _Y, double _X)
     * }
     */
    public static MemorySegment atan2$address() {
        return atan2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double atan2(double _Y, double _X)
     * }
     */
    public static double atan2(double _Y, double _X) {
        var mh$ = atan2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atan2", _Y, _X);
            }
            return (double)mh$.invokeExact(_Y, _X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("cos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cos(double _X)
     * }
     */
    public static FunctionDescriptor cos$descriptor() {
        return cos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cos(double _X)
     * }
     */
    public static MethodHandle cos$handle() {
        return cos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cos(double _X)
     * }
     */
    public static MemorySegment cos$address() {
        return cos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cos(double _X)
     * }
     */
    public static double cos(double _X) {
        var mh$ = cos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cos", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("cosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cosh(double _X)
     * }
     */
    public static FunctionDescriptor cosh$descriptor() {
        return cosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cosh(double _X)
     * }
     */
    public static MethodHandle cosh$handle() {
        return cosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cosh(double _X)
     * }
     */
    public static MemorySegment cosh$address() {
        return cosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cosh(double _X)
     * }
     */
    public static double cosh(double _X) {
        var mh$ = cosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cosh", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("exp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double exp(double _X)
     * }
     */
    public static FunctionDescriptor exp$descriptor() {
        return exp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double exp(double _X)
     * }
     */
    public static MethodHandle exp$handle() {
        return exp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double exp(double _X)
     * }
     */
    public static MemorySegment exp$address() {
        return exp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double exp(double _X)
     * }
     */
    public static double exp(double _X) {
        var mh$ = exp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("fabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double fabs(double _X)
     * }
     */
    public static FunctionDescriptor fabs$descriptor() {
        return fabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double fabs(double _X)
     * }
     */
    public static MethodHandle fabs$handle() {
        return fabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double fabs(double _X)
     * }
     */
    public static MemorySegment fabs$address() {
        return fabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double fabs(double _X)
     * }
     */
    public static double fabs(double _X) {
        var mh$ = fabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fabs", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("fmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double fmod(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor fmod$descriptor() {
        return fmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double fmod(double _X, double _Y)
     * }
     */
    public static MethodHandle fmod$handle() {
        return fmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double fmod(double _X, double _Y)
     * }
     */
    public static MemorySegment fmod$address() {
        return fmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double fmod(double _X, double _Y)
     * }
     */
    public static double fmod(double _X, double _Y) {
        var mh$ = fmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmod", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("log");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double log(double _X)
     * }
     */
    public static FunctionDescriptor log$descriptor() {
        return log.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double log(double _X)
     * }
     */
    public static MethodHandle log$handle() {
        return log.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double log(double _X)
     * }
     */
    public static MemorySegment log$address() {
        return log.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double log(double _X)
     * }
     */
    public static double log(double _X) {
        var mh$ = log.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log10 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("log10");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double log10(double _X)
     * }
     */
    public static FunctionDescriptor log10$descriptor() {
        return log10.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double log10(double _X)
     * }
     */
    public static MethodHandle log10$handle() {
        return log10.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double log10(double _X)
     * }
     */
    public static MemorySegment log10$address() {
        return log10.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double log10(double _X)
     * }
     */
    public static double log10(double _X) {
        var mh$ = log10.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log10", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("pow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double pow(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor pow$descriptor() {
        return pow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double pow(double _X, double _Y)
     * }
     */
    public static MethodHandle pow$handle() {
        return pow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double pow(double _X, double _Y)
     * }
     */
    public static MemorySegment pow$address() {
        return pow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double pow(double _X, double _Y)
     * }
     */
    public static double pow(double _X, double _Y) {
        var mh$ = pow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pow", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("sin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sin(double _X)
     * }
     */
    public static FunctionDescriptor sin$descriptor() {
        return sin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sin(double _X)
     * }
     */
    public static MethodHandle sin$handle() {
        return sin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sin(double _X)
     * }
     */
    public static MemorySegment sin$address() {
        return sin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sin(double _X)
     * }
     */
    public static double sin(double _X) {
        var mh$ = sin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sin", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("sinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sinh(double _X)
     * }
     */
    public static FunctionDescriptor sinh$descriptor() {
        return sinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sinh(double _X)
     * }
     */
    public static MethodHandle sinh$handle() {
        return sinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sinh(double _X)
     * }
     */
    public static MemorySegment sinh$address() {
        return sinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sinh(double _X)
     * }
     */
    public static double sinh(double _X) {
        var mh$ = sinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinh", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("sqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sqrt(double _X)
     * }
     */
    public static FunctionDescriptor sqrt$descriptor() {
        return sqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sqrt(double _X)
     * }
     */
    public static MethodHandle sqrt$handle() {
        return sqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sqrt(double _X)
     * }
     */
    public static MemorySegment sqrt$address() {
        return sqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sqrt(double _X)
     * }
     */
    public static double sqrt(double _X) {
        var mh$ = sqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sqrt", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("tan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double tan(double _X)
     * }
     */
    public static FunctionDescriptor tan$descriptor() {
        return tan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double tan(double _X)
     * }
     */
    public static MethodHandle tan$handle() {
        return tan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double tan(double _X)
     * }
     */
    public static MemorySegment tan$address() {
        return tan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double tan(double _X)
     * }
     */
    public static double tan(double _X) {
        var mh$ = tan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tan", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("tanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double tanh(double _X)
     * }
     */
    public static FunctionDescriptor tanh$descriptor() {
        return tanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double tanh(double _X)
     * }
     */
    public static MethodHandle tanh$handle() {
        return tanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double tanh(double _X)
     * }
     */
    public static MemorySegment tanh$address() {
        return tanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double tanh(double _X)
     * }
     */
    public static double tanh(double _X) {
        var mh$ = tanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanh", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("acosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double acosh(double _X)
     * }
     */
    public static FunctionDescriptor acosh$descriptor() {
        return acosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double acosh(double _X)
     * }
     */
    public static MethodHandle acosh$handle() {
        return acosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double acosh(double _X)
     * }
     */
    public static MemorySegment acosh$address() {
        return acosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double acosh(double _X)
     * }
     */
    public static double acosh(double _X) {
        var mh$ = acosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acosh", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("asinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double asinh(double _X)
     * }
     */
    public static FunctionDescriptor asinh$descriptor() {
        return asinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double asinh(double _X)
     * }
     */
    public static MethodHandle asinh$handle() {
        return asinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double asinh(double _X)
     * }
     */
    public static MemorySegment asinh$address() {
        return asinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double asinh(double _X)
     * }
     */
    public static double asinh(double _X) {
        var mh$ = asinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinh", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("atanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double atanh(double _X)
     * }
     */
    public static FunctionDescriptor atanh$descriptor() {
        return atanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double atanh(double _X)
     * }
     */
    public static MethodHandle atanh$handle() {
        return atanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double atanh(double _X)
     * }
     */
    public static MemorySegment atanh$address() {
        return atanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double atanh(double _X)
     * }
     */
    public static double atanh(double _X) {
        var mh$ = atanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanh", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _cabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            _complex.layout()
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_cabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _cabs(struct _complex _Complex_value)
     * }
     */
    public static FunctionDescriptor _cabs$descriptor() {
        return _cabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _cabs(struct _complex _Complex_value)
     * }
     */
    public static MethodHandle _cabs$handle() {
        return _cabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _cabs(struct _complex _Complex_value)
     * }
     */
    public static MemorySegment _cabs$address() {
        return _cabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _cabs(struct _complex _Complex_value)
     * }
     */
    public static double _cabs(MemorySegment _Complex_value) {
        var mh$ = _cabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_cabs", _Complex_value);
            }
            return (double)mh$.invokeExact(_Complex_value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cbrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("cbrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double cbrt(double _X)
     * }
     */
    public static FunctionDescriptor cbrt$descriptor() {
        return cbrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double cbrt(double _X)
     * }
     */
    public static MethodHandle cbrt$handle() {
        return cbrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double cbrt(double _X)
     * }
     */
    public static MemorySegment cbrt$address() {
        return cbrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double cbrt(double _X)
     * }
     */
    public static double cbrt(double _X) {
        var mh$ = cbrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cbrt", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ceil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("ceil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double ceil(double _X)
     * }
     */
    public static FunctionDescriptor ceil$descriptor() {
        return ceil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double ceil(double _X)
     * }
     */
    public static MethodHandle ceil$handle() {
        return ceil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double ceil(double _X)
     * }
     */
    public static MemorySegment ceil$address() {
        return ceil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double ceil(double _X)
     * }
     */
    public static double ceil(double _X) {
        var mh$ = ceil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ceil", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _chgsign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_chgsign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _chgsign(double _X)
     * }
     */
    public static FunctionDescriptor _chgsign$descriptor() {
        return _chgsign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _chgsign(double _X)
     * }
     */
    public static MethodHandle _chgsign$handle() {
        return _chgsign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _chgsign(double _X)
     * }
     */
    public static MemorySegment _chgsign$address() {
        return _chgsign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _chgsign(double _X)
     * }
     */
    public static double _chgsign(double _X) {
        var mh$ = _chgsign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_chgsign", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class copysign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("copysign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double copysign(double _Number, double _Sign)
     * }
     */
    public static FunctionDescriptor copysign$descriptor() {
        return copysign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double copysign(double _Number, double _Sign)
     * }
     */
    public static MethodHandle copysign$handle() {
        return copysign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double copysign(double _Number, double _Sign)
     * }
     */
    public static MemorySegment copysign$address() {
        return copysign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double copysign(double _Number, double _Sign)
     * }
     */
    public static double copysign(double _Number, double _Sign) {
        var mh$ = copysign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("copysign", _Number, _Sign);
            }
            return (double)mh$.invokeExact(_Number, _Sign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _copysign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_copysign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _copysign(double _Number, double _Sign)
     * }
     */
    public static FunctionDescriptor _copysign$descriptor() {
        return _copysign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _copysign(double _Number, double _Sign)
     * }
     */
    public static MethodHandle _copysign$handle() {
        return _copysign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _copysign(double _Number, double _Sign)
     * }
     */
    public static MemorySegment _copysign$address() {
        return _copysign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _copysign(double _Number, double _Sign)
     * }
     */
    public static double _copysign(double _Number, double _Sign) {
        var mh$ = _copysign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_copysign", _Number, _Sign);
            }
            return (double)mh$.invokeExact(_Number, _Sign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("erf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double erf(double _X)
     * }
     */
    public static FunctionDescriptor erf$descriptor() {
        return erf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double erf(double _X)
     * }
     */
    public static MethodHandle erf$handle() {
        return erf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double erf(double _X)
     * }
     */
    public static MemorySegment erf$address() {
        return erf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double erf(double _X)
     * }
     */
    public static double erf(double _X) {
        var mh$ = erf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erf", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erfc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("erfc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double erfc(double _X)
     * }
     */
    public static FunctionDescriptor erfc$descriptor() {
        return erfc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double erfc(double _X)
     * }
     */
    public static MethodHandle erfc$handle() {
        return erfc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double erfc(double _X)
     * }
     */
    public static MemorySegment erfc$address() {
        return erfc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double erfc(double _X)
     * }
     */
    public static double erfc(double _X) {
        var mh$ = erfc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erfc", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("exp2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double exp2(double _X)
     * }
     */
    public static FunctionDescriptor exp2$descriptor() {
        return exp2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double exp2(double _X)
     * }
     */
    public static MethodHandle exp2$handle() {
        return exp2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double exp2(double _X)
     * }
     */
    public static MemorySegment exp2$address() {
        return exp2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double exp2(double _X)
     * }
     */
    public static double exp2(double _X) {
        var mh$ = exp2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp2", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expm1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("expm1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double expm1(double _X)
     * }
     */
    public static FunctionDescriptor expm1$descriptor() {
        return expm1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double expm1(double _X)
     * }
     */
    public static MethodHandle expm1$handle() {
        return expm1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double expm1(double _X)
     * }
     */
    public static MemorySegment expm1$address() {
        return expm1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double expm1(double _X)
     * }
     */
    public static double expm1(double _X) {
        var mh$ = expm1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expm1", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("fdim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double fdim(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor fdim$descriptor() {
        return fdim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double fdim(double _X, double _Y)
     * }
     */
    public static MethodHandle fdim$handle() {
        return fdim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double fdim(double _X, double _Y)
     * }
     */
    public static MemorySegment fdim$address() {
        return fdim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double fdim(double _X, double _Y)
     * }
     */
    public static double fdim(double _X, double _Y) {
        var mh$ = fdim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdim", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class floor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("floor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double floor(double _X)
     * }
     */
    public static FunctionDescriptor floor$descriptor() {
        return floor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double floor(double _X)
     * }
     */
    public static MethodHandle floor$handle() {
        return floor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double floor(double _X)
     * }
     */
    public static MemorySegment floor$address() {
        return floor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double floor(double _X)
     * }
     */
    public static double floor(double _X) {
        var mh$ = floor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("floor", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("fma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double fma(double _X, double _Y, double _Z)
     * }
     */
    public static FunctionDescriptor fma$descriptor() {
        return fma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double fma(double _X, double _Y, double _Z)
     * }
     */
    public static MethodHandle fma$handle() {
        return fma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double fma(double _X, double _Y, double _Z)
     * }
     */
    public static MemorySegment fma$address() {
        return fma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double fma(double _X, double _Y, double _Z)
     * }
     */
    public static double fma(double _X, double _Y, double _Z) {
        var mh$ = fma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fma", _X, _Y, _Z);
            }
            return (double)mh$.invokeExact(_X, _Y, _Z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("fmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double fmax(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor fmax$descriptor() {
        return fmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double fmax(double _X, double _Y)
     * }
     */
    public static MethodHandle fmax$handle() {
        return fmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double fmax(double _X, double _Y)
     * }
     */
    public static MemorySegment fmax$address() {
        return fmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double fmax(double _X, double _Y)
     * }
     */
    public static double fmax(double _X, double _Y) {
        var mh$ = fmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmax", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("fmin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double fmin(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor fmin$descriptor() {
        return fmin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double fmin(double _X, double _Y)
     * }
     */
    public static MethodHandle fmin$handle() {
        return fmin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double fmin(double _X, double _Y)
     * }
     */
    public static MemorySegment fmin$address() {
        return fmin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double fmin(double _X, double _Y)
     * }
     */
    public static double fmin(double _X, double _Y) {
        var mh$ = fmin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmin", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class frexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("frexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double frexp(double _X, int *_Y)
     * }
     */
    public static FunctionDescriptor frexp$descriptor() {
        return frexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double frexp(double _X, int *_Y)
     * }
     */
    public static MethodHandle frexp$handle() {
        return frexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double frexp(double _X, int *_Y)
     * }
     */
    public static MemorySegment frexp$address() {
        return frexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double frexp(double _X, int *_Y)
     * }
     */
    public static double frexp(double _X, MemorySegment _Y) {
        var mh$ = frexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("frexp", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class hypot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("hypot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double hypot(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor hypot$descriptor() {
        return hypot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double hypot(double _X, double _Y)
     * }
     */
    public static MethodHandle hypot$handle() {
        return hypot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double hypot(double _X, double _Y)
     * }
     */
    public static MemorySegment hypot$address() {
        return hypot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double hypot(double _X, double _Y)
     * }
     */
    public static double hypot(double _X, double _Y) {
        var mh$ = hypot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("hypot", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _hypot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_hypot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _hypot(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor _hypot$descriptor() {
        return _hypot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _hypot(double _X, double _Y)
     * }
     */
    public static MethodHandle _hypot$handle() {
        return _hypot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _hypot(double _X, double _Y)
     * }
     */
    public static MemorySegment _hypot$address() {
        return _hypot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _hypot(double _X, double _Y)
     * }
     */
    public static double _hypot(double _X, double _Y) {
        var mh$ = _hypot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_hypot", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilogb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("ilogb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ilogb(double _X)
     * }
     */
    public static FunctionDescriptor ilogb$descriptor() {
        return ilogb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ilogb(double _X)
     * }
     */
    public static MethodHandle ilogb$handle() {
        return ilogb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ilogb(double _X)
     * }
     */
    public static MemorySegment ilogb$address() {
        return ilogb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ilogb(double _X)
     * }
     */
    public static int ilogb(double _X) {
        var mh$ = ilogb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilogb", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("ldexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double ldexp(double _X, int _Y)
     * }
     */
    public static FunctionDescriptor ldexp$descriptor() {
        return ldexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double ldexp(double _X, int _Y)
     * }
     */
    public static MethodHandle ldexp$handle() {
        return ldexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double ldexp(double _X, int _Y)
     * }
     */
    public static MemorySegment ldexp$address() {
        return ldexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double ldexp(double _X, int _Y)
     * }
     */
    public static double ldexp(double _X, int _Y) {
        var mh$ = ldexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldexp", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("lgamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double lgamma(double _X)
     * }
     */
    public static FunctionDescriptor lgamma$descriptor() {
        return lgamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double lgamma(double _X)
     * }
     */
    public static MethodHandle lgamma$handle() {
        return lgamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double lgamma(double _X)
     * }
     */
    public static MemorySegment lgamma$address() {
        return lgamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double lgamma(double _X)
     * }
     */
    public static double lgamma(double _X) {
        var mh$ = lgamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgamma", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("llrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llrint(double _X)
     * }
     */
    public static FunctionDescriptor llrint$descriptor() {
        return llrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llrint(double _X)
     * }
     */
    public static MethodHandle llrint$handle() {
        return llrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llrint(double _X)
     * }
     */
    public static MemorySegment llrint$address() {
        return llrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llrint(double _X)
     * }
     */
    public static long llrint(double _X) {
        var mh$ = llrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llrint", _X);
            }
            return (long)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("llround");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llround(double _X)
     * }
     */
    public static FunctionDescriptor llround$descriptor() {
        return llround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llround(double _X)
     * }
     */
    public static MethodHandle llround$handle() {
        return llround.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llround(double _X)
     * }
     */
    public static MemorySegment llround$address() {
        return llround.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llround(double _X)
     * }
     */
    public static long llround(double _X) {
        var mh$ = llround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llround", _X);
            }
            return (long)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log1p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("log1p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double log1p(double _X)
     * }
     */
    public static FunctionDescriptor log1p$descriptor() {
        return log1p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double log1p(double _X)
     * }
     */
    public static MethodHandle log1p$handle() {
        return log1p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double log1p(double _X)
     * }
     */
    public static MemorySegment log1p$address() {
        return log1p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double log1p(double _X)
     * }
     */
    public static double log1p(double _X) {
        var mh$ = log1p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log1p", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("log2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double log2(double _X)
     * }
     */
    public static FunctionDescriptor log2$descriptor() {
        return log2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double log2(double _X)
     * }
     */
    public static MethodHandle log2$handle() {
        return log2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double log2(double _X)
     * }
     */
    public static MemorySegment log2$address() {
        return log2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double log2(double _X)
     * }
     */
    public static double log2(double _X) {
        var mh$ = log2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log2", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("logb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double logb(double _X)
     * }
     */
    public static FunctionDescriptor logb$descriptor() {
        return logb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double logb(double _X)
     * }
     */
    public static MethodHandle logb$handle() {
        return logb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double logb(double _X)
     * }
     */
    public static MemorySegment logb$address() {
        return logb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double logb(double _X)
     * }
     */
    public static double logb(double _X) {
        var mh$ = logb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logb", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("lrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lrint(double _X)
     * }
     */
    public static FunctionDescriptor lrint$descriptor() {
        return lrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lrint(double _X)
     * }
     */
    public static MethodHandle lrint$handle() {
        return lrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lrint(double _X)
     * }
     */
    public static MemorySegment lrint$address() {
        return lrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lrint(double _X)
     * }
     */
    public static int lrint(double _X) {
        var mh$ = lrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrint", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("lround");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lround(double _X)
     * }
     */
    public static FunctionDescriptor lround$descriptor() {
        return lround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lround(double _X)
     * }
     */
    public static MethodHandle lround$handle() {
        return lround.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lround(double _X)
     * }
     */
    public static MemorySegment lround$address() {
        return lround.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lround(double _X)
     * }
     */
    public static int lround(double _X) {
        var mh$ = lround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lround", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _matherr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_matherr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _matherr(struct _exception *_Except)
     * }
     */
    public static FunctionDescriptor _matherr$descriptor() {
        return _matherr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _matherr(struct _exception *_Except)
     * }
     */
    public static MethodHandle _matherr$handle() {
        return _matherr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _matherr(struct _exception *_Except)
     * }
     */
    public static MemorySegment _matherr$address() {
        return _matherr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _matherr(struct _exception *_Except)
     * }
     */
    public static int _matherr(MemorySegment _Except) {
        var mh$ = _matherr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_matherr", _Except);
            }
            return (int)mh$.invokeExact(_Except);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class modf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("modf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double modf(double _X, double *_Y)
     * }
     */
    public static FunctionDescriptor modf$descriptor() {
        return modf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double modf(double _X, double *_Y)
     * }
     */
    public static MethodHandle modf$handle() {
        return modf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double modf(double _X, double *_Y)
     * }
     */
    public static MemorySegment modf$address() {
        return modf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double modf(double _X, double *_Y)
     * }
     */
    public static double modf(double _X, MemorySegment _Y) {
        var mh$ = modf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("modf", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("nan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double nan(const char *_X)
     * }
     */
    public static FunctionDescriptor nan$descriptor() {
        return nan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double nan(const char *_X)
     * }
     */
    public static MethodHandle nan$handle() {
        return nan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double nan(const char *_X)
     * }
     */
    public static MemorySegment nan$address() {
        return nan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double nan(const char *_X)
     * }
     */
    public static double nan(MemorySegment _X) {
        var mh$ = nan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nan", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nearbyint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("nearbyint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double nearbyint(double _X)
     * }
     */
    public static FunctionDescriptor nearbyint$descriptor() {
        return nearbyint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double nearbyint(double _X)
     * }
     */
    public static MethodHandle nearbyint$handle() {
        return nearbyint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double nearbyint(double _X)
     * }
     */
    public static MemorySegment nearbyint$address() {
        return nearbyint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double nearbyint(double _X)
     * }
     */
    public static double nearbyint(double _X) {
        var mh$ = nearbyint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nearbyint", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nextafter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("nextafter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double nextafter(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor nextafter$descriptor() {
        return nextafter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double nextafter(double _X, double _Y)
     * }
     */
    public static MethodHandle nextafter$handle() {
        return nextafter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double nextafter(double _X, double _Y)
     * }
     */
    public static MemorySegment nextafter$address() {
        return nextafter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double nextafter(double _X, double _Y)
     * }
     */
    public static double nextafter(double _X, double _Y) {
        var mh$ = nextafter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nextafter", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nexttoward {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("nexttoward");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double nexttoward(double _X, long double _Y)
     * }
     */
    public static FunctionDescriptor nexttoward$descriptor() {
        return nexttoward.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double nexttoward(double _X, long double _Y)
     * }
     */
    public static MethodHandle nexttoward$handle() {
        return nexttoward.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double nexttoward(double _X, long double _Y)
     * }
     */
    public static MemorySegment nexttoward$address() {
        return nexttoward.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double nexttoward(double _X, long double _Y)
     * }
     */
    public static double nexttoward(double _X, double _Y) {
        var mh$ = nexttoward.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nexttoward", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remainder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("remainder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double remainder(double _X, double _Y)
     * }
     */
    public static FunctionDescriptor remainder$descriptor() {
        return remainder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double remainder(double _X, double _Y)
     * }
     */
    public static MethodHandle remainder$handle() {
        return remainder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double remainder(double _X, double _Y)
     * }
     */
    public static MemorySegment remainder$address() {
        return remainder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double remainder(double _X, double _Y)
     * }
     */
    public static double remainder(double _X, double _Y) {
        var mh$ = remainder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remainder", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remquo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("remquo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double remquo(double _X, double _Y, int *_Z)
     * }
     */
    public static FunctionDescriptor remquo$descriptor() {
        return remquo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double remquo(double _X, double _Y, int *_Z)
     * }
     */
    public static MethodHandle remquo$handle() {
        return remquo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double remquo(double _X, double _Y, int *_Z)
     * }
     */
    public static MemorySegment remquo$address() {
        return remquo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double remquo(double _X, double _Y, int *_Z)
     * }
     */
    public static double remquo(double _X, double _Y, MemorySegment _Z) {
        var mh$ = remquo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remquo", _X, _Y, _Z);
            }
            return (double)mh$.invokeExact(_X, _Y, _Z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("rint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double rint(double _X)
     * }
     */
    public static FunctionDescriptor rint$descriptor() {
        return rint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double rint(double _X)
     * }
     */
    public static MethodHandle rint$handle() {
        return rint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double rint(double _X)
     * }
     */
    public static MemorySegment rint$address() {
        return rint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double rint(double _X)
     * }
     */
    public static double rint(double _X) {
        var mh$ = rint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rint", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class round {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("round");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double round(double _X)
     * }
     */
    public static FunctionDescriptor round$descriptor() {
        return round.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double round(double _X)
     * }
     */
    public static MethodHandle round$handle() {
        return round.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double round(double _X)
     * }
     */
    public static MemorySegment round$address() {
        return round.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double round(double _X)
     * }
     */
    public static double round(double _X) {
        var mh$ = round.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("round", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbln {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("scalbln");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double scalbln(double _X, long _Y)
     * }
     */
    public static FunctionDescriptor scalbln$descriptor() {
        return scalbln.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double scalbln(double _X, long _Y)
     * }
     */
    public static MethodHandle scalbln$handle() {
        return scalbln.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double scalbln(double _X, long _Y)
     * }
     */
    public static MemorySegment scalbln$address() {
        return scalbln.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double scalbln(double _X, long _Y)
     * }
     */
    public static double scalbln(double _X, int _Y) {
        var mh$ = scalbln.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbln", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("scalbn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double scalbn(double _X, int _Y)
     * }
     */
    public static FunctionDescriptor scalbn$descriptor() {
        return scalbn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double scalbn(double _X, int _Y)
     * }
     */
    public static MethodHandle scalbn$handle() {
        return scalbn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double scalbn(double _X, int _Y)
     * }
     */
    public static MemorySegment scalbn$address() {
        return scalbn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double scalbn(double _X, int _Y)
     * }
     */
    public static double scalbn(double _X, int _Y) {
        var mh$ = scalbn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbn", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tgamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("tgamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double tgamma(double _X)
     * }
     */
    public static FunctionDescriptor tgamma$descriptor() {
        return tgamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double tgamma(double _X)
     * }
     */
    public static MethodHandle tgamma$handle() {
        return tgamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double tgamma(double _X)
     * }
     */
    public static MemorySegment tgamma$address() {
        return tgamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double tgamma(double _X)
     * }
     */
    public static double tgamma(double _X) {
        var mh$ = tgamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tgamma", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class trunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("trunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double trunc(double _X)
     * }
     */
    public static FunctionDescriptor trunc$descriptor() {
        return trunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double trunc(double _X)
     * }
     */
    public static MethodHandle trunc$handle() {
        return trunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double trunc(double _X)
     * }
     */
    public static MemorySegment trunc$address() {
        return trunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double trunc(double _X)
     * }
     */
    public static double trunc(double _X) {
        var mh$ = trunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("trunc", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _j0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_j0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _j0(double _X)
     * }
     */
    public static FunctionDescriptor _j0$descriptor() {
        return _j0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _j0(double _X)
     * }
     */
    public static MethodHandle _j0$handle() {
        return _j0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _j0(double _X)
     * }
     */
    public static MemorySegment _j0$address() {
        return _j0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _j0(double _X)
     * }
     */
    public static double _j0(double _X) {
        var mh$ = _j0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_j0", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _j1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_j1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _j1(double _X)
     * }
     */
    public static FunctionDescriptor _j1$descriptor() {
        return _j1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _j1(double _X)
     * }
     */
    public static MethodHandle _j1$handle() {
        return _j1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _j1(double _X)
     * }
     */
    public static MemorySegment _j1$address() {
        return _j1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _j1(double _X)
     * }
     */
    public static double _j1(double _X) {
        var mh$ = _j1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_j1", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _jn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_INT,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_jn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _jn(int _X, double _Y)
     * }
     */
    public static FunctionDescriptor _jn$descriptor() {
        return _jn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _jn(int _X, double _Y)
     * }
     */
    public static MethodHandle _jn$handle() {
        return _jn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _jn(int _X, double _Y)
     * }
     */
    public static MemorySegment _jn$address() {
        return _jn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _jn(int _X, double _Y)
     * }
     */
    public static double _jn(int _X, double _Y) {
        var mh$ = _jn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_jn", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _y0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_y0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _y0(double _X)
     * }
     */
    public static FunctionDescriptor _y0$descriptor() {
        return _y0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _y0(double _X)
     * }
     */
    public static MethodHandle _y0$handle() {
        return _y0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _y0(double _X)
     * }
     */
    public static MemorySegment _y0$address() {
        return _y0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _y0(double _X)
     * }
     */
    public static double _y0(double _X) {
        var mh$ = _y0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_y0", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _y1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_y1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _y1(double _X)
     * }
     */
    public static FunctionDescriptor _y1$descriptor() {
        return _y1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _y1(double _X)
     * }
     */
    public static MethodHandle _y1$handle() {
        return _y1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _y1(double _X)
     * }
     */
    public static MemorySegment _y1$address() {
        return _y1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _y1(double _X)
     * }
     */
    public static double _y1(double _X) {
        var mh$ = _y1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_y1", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _yn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_INT,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_yn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _yn(int _X, double _Y)
     * }
     */
    public static FunctionDescriptor _yn$descriptor() {
        return _yn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _yn(int _X, double _Y)
     * }
     */
    public static MethodHandle _yn$handle() {
        return _yn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double _yn(int _X, double _Y)
     * }
     */
    public static MemorySegment _yn$address() {
        return _yn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double _yn(int _X, double _Y)
     * }
     */
    public static double _yn(int _X, double _Y) {
        var mh$ = _yn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_yn", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acoshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("acoshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float acoshf(float _X)
     * }
     */
    public static FunctionDescriptor acoshf$descriptor() {
        return acoshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float acoshf(float _X)
     * }
     */
    public static MethodHandle acoshf$handle() {
        return acoshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float acoshf(float _X)
     * }
     */
    public static MemorySegment acoshf$address() {
        return acoshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float acoshf(float _X)
     * }
     */
    public static float acoshf(float _X) {
        var mh$ = acoshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acoshf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("asinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float asinhf(float _X)
     * }
     */
    public static FunctionDescriptor asinhf$descriptor() {
        return asinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float asinhf(float _X)
     * }
     */
    public static MethodHandle asinhf$handle() {
        return asinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float asinhf(float _X)
     * }
     */
    public static MemorySegment asinhf$address() {
        return asinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float asinhf(float _X)
     * }
     */
    public static float asinhf(float _X) {
        var mh$ = asinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinhf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("atanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float atanhf(float _X)
     * }
     */
    public static FunctionDescriptor atanhf$descriptor() {
        return atanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float atanhf(float _X)
     * }
     */
    public static MethodHandle atanhf$handle() {
        return atanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float atanhf(float _X)
     * }
     */
    public static MemorySegment atanhf$address() {
        return atanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float atanhf(float _X)
     * }
     */
    public static float atanhf(float _X) {
        var mh$ = atanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanhf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cbrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("cbrtf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cbrtf(float _X)
     * }
     */
    public static FunctionDescriptor cbrtf$descriptor() {
        return cbrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cbrtf(float _X)
     * }
     */
    public static MethodHandle cbrtf$handle() {
        return cbrtf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cbrtf(float _X)
     * }
     */
    public static MemorySegment cbrtf$address() {
        return cbrtf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cbrtf(float _X)
     * }
     */
    public static float cbrtf(float _X) {
        var mh$ = cbrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cbrtf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _chgsignf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_chgsignf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _chgsignf(float _X)
     * }
     */
    public static FunctionDescriptor _chgsignf$descriptor() {
        return _chgsignf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _chgsignf(float _X)
     * }
     */
    public static MethodHandle _chgsignf$handle() {
        return _chgsignf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _chgsignf(float _X)
     * }
     */
    public static MemorySegment _chgsignf$address() {
        return _chgsignf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _chgsignf(float _X)
     * }
     */
    public static float _chgsignf(float _X) {
        var mh$ = _chgsignf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_chgsignf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class copysignf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("copysignf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float copysignf(float _Number, float _Sign)
     * }
     */
    public static FunctionDescriptor copysignf$descriptor() {
        return copysignf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float copysignf(float _Number, float _Sign)
     * }
     */
    public static MethodHandle copysignf$handle() {
        return copysignf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float copysignf(float _Number, float _Sign)
     * }
     */
    public static MemorySegment copysignf$address() {
        return copysignf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float copysignf(float _Number, float _Sign)
     * }
     */
    public static float copysignf(float _Number, float _Sign) {
        var mh$ = copysignf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("copysignf", _Number, _Sign);
            }
            return (float)mh$.invokeExact(_Number, _Sign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _copysignf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_copysignf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _copysignf(float _Number, float _Sign)
     * }
     */
    public static FunctionDescriptor _copysignf$descriptor() {
        return _copysignf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _copysignf(float _Number, float _Sign)
     * }
     */
    public static MethodHandle _copysignf$handle() {
        return _copysignf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _copysignf(float _Number, float _Sign)
     * }
     */
    public static MemorySegment _copysignf$address() {
        return _copysignf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _copysignf(float _Number, float _Sign)
     * }
     */
    public static float _copysignf(float _Number, float _Sign) {
        var mh$ = _copysignf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_copysignf", _Number, _Sign);
            }
            return (float)mh$.invokeExact(_Number, _Sign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("erff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float erff(float _X)
     * }
     */
    public static FunctionDescriptor erff$descriptor() {
        return erff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float erff(float _X)
     * }
     */
    public static MethodHandle erff$handle() {
        return erff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float erff(float _X)
     * }
     */
    public static MemorySegment erff$address() {
        return erff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float erff(float _X)
     * }
     */
    public static float erff(float _X) {
        var mh$ = erff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erff", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erfcf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("erfcf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float erfcf(float _X)
     * }
     */
    public static FunctionDescriptor erfcf$descriptor() {
        return erfcf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float erfcf(float _X)
     * }
     */
    public static MethodHandle erfcf$handle() {
        return erfcf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float erfcf(float _X)
     * }
     */
    public static MemorySegment erfcf$address() {
        return erfcf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float erfcf(float _X)
     * }
     */
    public static float erfcf(float _X) {
        var mh$ = erfcf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erfcf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expm1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("expm1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float expm1f(float _X)
     * }
     */
    public static FunctionDescriptor expm1f$descriptor() {
        return expm1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float expm1f(float _X)
     * }
     */
    public static MethodHandle expm1f$handle() {
        return expm1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float expm1f(float _X)
     * }
     */
    public static MemorySegment expm1f$address() {
        return expm1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float expm1f(float _X)
     * }
     */
    public static float expm1f(float _X) {
        var mh$ = expm1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expm1f", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("exp2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float exp2f(float _X)
     * }
     */
    public static FunctionDescriptor exp2f$descriptor() {
        return exp2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float exp2f(float _X)
     * }
     */
    public static MethodHandle exp2f$handle() {
        return exp2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float exp2f(float _X)
     * }
     */
    public static MemorySegment exp2f$address() {
        return exp2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float exp2f(float _X)
     * }
     */
    public static float exp2f(float _X) {
        var mh$ = exp2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp2f", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdimf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("fdimf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float fdimf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor fdimf$descriptor() {
        return fdimf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float fdimf(float _X, float _Y)
     * }
     */
    public static MethodHandle fdimf$handle() {
        return fdimf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float fdimf(float _X, float _Y)
     * }
     */
    public static MemorySegment fdimf$address() {
        return fdimf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float fdimf(float _X, float _Y)
     * }
     */
    public static float fdimf(float _X, float _Y) {
        var mh$ = fdimf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdimf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("fmaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float fmaf(float _X, float _Y, float _Z)
     * }
     */
    public static FunctionDescriptor fmaf$descriptor() {
        return fmaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float fmaf(float _X, float _Y, float _Z)
     * }
     */
    public static MethodHandle fmaf$handle() {
        return fmaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float fmaf(float _X, float _Y, float _Z)
     * }
     */
    public static MemorySegment fmaf$address() {
        return fmaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float fmaf(float _X, float _Y, float _Z)
     * }
     */
    public static float fmaf(float _X, float _Y, float _Z) {
        var mh$ = fmaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmaf", _X, _Y, _Z);
            }
            return (float)mh$.invokeExact(_X, _Y, _Z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmaxf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("fmaxf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float fmaxf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor fmaxf$descriptor() {
        return fmaxf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float fmaxf(float _X, float _Y)
     * }
     */
    public static MethodHandle fmaxf$handle() {
        return fmaxf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float fmaxf(float _X, float _Y)
     * }
     */
    public static MemorySegment fmaxf$address() {
        return fmaxf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float fmaxf(float _X, float _Y)
     * }
     */
    public static float fmaxf(float _X, float _Y) {
        var mh$ = fmaxf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmaxf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fminf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("fminf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float fminf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor fminf$descriptor() {
        return fminf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float fminf(float _X, float _Y)
     * }
     */
    public static MethodHandle fminf$handle() {
        return fminf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float fminf(float _X, float _Y)
     * }
     */
    public static MemorySegment fminf$address() {
        return fminf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float fminf(float _X, float _Y)
     * }
     */
    public static float fminf(float _X, float _Y) {
        var mh$ = fminf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fminf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _hypotf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_hypotf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _hypotf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor _hypotf$descriptor() {
        return _hypotf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _hypotf(float _X, float _Y)
     * }
     */
    public static MethodHandle _hypotf$handle() {
        return _hypotf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _hypotf(float _X, float _Y)
     * }
     */
    public static MemorySegment _hypotf$address() {
        return _hypotf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _hypotf(float _X, float _Y)
     * }
     */
    public static float _hypotf(float _X, float _Y) {
        var mh$ = _hypotf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_hypotf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilogbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("ilogbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ilogbf(float _X)
     * }
     */
    public static FunctionDescriptor ilogbf$descriptor() {
        return ilogbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ilogbf(float _X)
     * }
     */
    public static MethodHandle ilogbf$handle() {
        return ilogbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ilogbf(float _X)
     * }
     */
    public static MemorySegment ilogbf$address() {
        return ilogbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ilogbf(float _X)
     * }
     */
    public static int ilogbf(float _X) {
        var mh$ = ilogbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilogbf", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("lgammaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float lgammaf(float _X)
     * }
     */
    public static FunctionDescriptor lgammaf$descriptor() {
        return lgammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float lgammaf(float _X)
     * }
     */
    public static MethodHandle lgammaf$handle() {
        return lgammaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float lgammaf(float _X)
     * }
     */
    public static MemorySegment lgammaf$address() {
        return lgammaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float lgammaf(float _X)
     * }
     */
    public static float lgammaf(float _X) {
        var mh$ = lgammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgammaf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llrintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("llrintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llrintf(float _X)
     * }
     */
    public static FunctionDescriptor llrintf$descriptor() {
        return llrintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llrintf(float _X)
     * }
     */
    public static MethodHandle llrintf$handle() {
        return llrintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llrintf(float _X)
     * }
     */
    public static MemorySegment llrintf$address() {
        return llrintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llrintf(float _X)
     * }
     */
    public static long llrintf(float _X) {
        var mh$ = llrintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llrintf", _X);
            }
            return (long)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llroundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("llroundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llroundf(float _X)
     * }
     */
    public static FunctionDescriptor llroundf$descriptor() {
        return llroundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llroundf(float _X)
     * }
     */
    public static MethodHandle llroundf$handle() {
        return llroundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llroundf(float _X)
     * }
     */
    public static MemorySegment llroundf$address() {
        return llroundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llroundf(float _X)
     * }
     */
    public static long llroundf(float _X) {
        var mh$ = llroundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llroundf", _X);
            }
            return (long)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log1pf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("log1pf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float log1pf(float _X)
     * }
     */
    public static FunctionDescriptor log1pf$descriptor() {
        return log1pf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float log1pf(float _X)
     * }
     */
    public static MethodHandle log1pf$handle() {
        return log1pf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float log1pf(float _X)
     * }
     */
    public static MemorySegment log1pf$address() {
        return log1pf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float log1pf(float _X)
     * }
     */
    public static float log1pf(float _X) {
        var mh$ = log1pf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log1pf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("log2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float log2f(float _X)
     * }
     */
    public static FunctionDescriptor log2f$descriptor() {
        return log2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float log2f(float _X)
     * }
     */
    public static MethodHandle log2f$handle() {
        return log2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float log2f(float _X)
     * }
     */
    public static MemorySegment log2f$address() {
        return log2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float log2f(float _X)
     * }
     */
    public static float log2f(float _X) {
        var mh$ = log2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log2f", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("logbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float logbf(float _X)
     * }
     */
    public static FunctionDescriptor logbf$descriptor() {
        return logbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float logbf(float _X)
     * }
     */
    public static MethodHandle logbf$handle() {
        return logbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float logbf(float _X)
     * }
     */
    public static MemorySegment logbf$address() {
        return logbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float logbf(float _X)
     * }
     */
    public static float logbf(float _X) {
        var mh$ = logbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logbf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("lrintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lrintf(float _X)
     * }
     */
    public static FunctionDescriptor lrintf$descriptor() {
        return lrintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lrintf(float _X)
     * }
     */
    public static MethodHandle lrintf$handle() {
        return lrintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lrintf(float _X)
     * }
     */
    public static MemorySegment lrintf$address() {
        return lrintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lrintf(float _X)
     * }
     */
    public static int lrintf(float _X) {
        var mh$ = lrintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrintf", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lroundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("lroundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lroundf(float _X)
     * }
     */
    public static FunctionDescriptor lroundf$descriptor() {
        return lroundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lroundf(float _X)
     * }
     */
    public static MethodHandle lroundf$handle() {
        return lroundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lroundf(float _X)
     * }
     */
    public static MemorySegment lroundf$address() {
        return lroundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lroundf(float _X)
     * }
     */
    public static int lroundf(float _X) {
        var mh$ = lroundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lroundf", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("nanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float nanf(const char *_X)
     * }
     */
    public static FunctionDescriptor nanf$descriptor() {
        return nanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float nanf(const char *_X)
     * }
     */
    public static MethodHandle nanf$handle() {
        return nanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float nanf(const char *_X)
     * }
     */
    public static MemorySegment nanf$address() {
        return nanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float nanf(const char *_X)
     * }
     */
    public static float nanf(MemorySegment _X) {
        var mh$ = nanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nanf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nearbyintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("nearbyintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float nearbyintf(float _X)
     * }
     */
    public static FunctionDescriptor nearbyintf$descriptor() {
        return nearbyintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float nearbyintf(float _X)
     * }
     */
    public static MethodHandle nearbyintf$handle() {
        return nearbyintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float nearbyintf(float _X)
     * }
     */
    public static MemorySegment nearbyintf$address() {
        return nearbyintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float nearbyintf(float _X)
     * }
     */
    public static float nearbyintf(float _X) {
        var mh$ = nearbyintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nearbyintf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nextafterf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("nextafterf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float nextafterf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor nextafterf$descriptor() {
        return nextafterf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float nextafterf(float _X, float _Y)
     * }
     */
    public static MethodHandle nextafterf$handle() {
        return nextafterf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float nextafterf(float _X, float _Y)
     * }
     */
    public static MemorySegment nextafterf$address() {
        return nextafterf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float nextafterf(float _X, float _Y)
     * }
     */
    public static float nextafterf(float _X, float _Y) {
        var mh$ = nextafterf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nextafterf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nexttowardf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("nexttowardf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float nexttowardf(float _X, long double _Y)
     * }
     */
    public static FunctionDescriptor nexttowardf$descriptor() {
        return nexttowardf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float nexttowardf(float _X, long double _Y)
     * }
     */
    public static MethodHandle nexttowardf$handle() {
        return nexttowardf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float nexttowardf(float _X, long double _Y)
     * }
     */
    public static MemorySegment nexttowardf$address() {
        return nexttowardf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float nexttowardf(float _X, long double _Y)
     * }
     */
    public static float nexttowardf(float _X, double _Y) {
        var mh$ = nexttowardf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nexttowardf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remainderf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("remainderf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float remainderf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor remainderf$descriptor() {
        return remainderf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float remainderf(float _X, float _Y)
     * }
     */
    public static MethodHandle remainderf$handle() {
        return remainderf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float remainderf(float _X, float _Y)
     * }
     */
    public static MemorySegment remainderf$address() {
        return remainderf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float remainderf(float _X, float _Y)
     * }
     */
    public static float remainderf(float _X, float _Y) {
        var mh$ = remainderf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remainderf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remquof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("remquof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float remquof(float _X, float _Y, int *_Z)
     * }
     */
    public static FunctionDescriptor remquof$descriptor() {
        return remquof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float remquof(float _X, float _Y, int *_Z)
     * }
     */
    public static MethodHandle remquof$handle() {
        return remquof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float remquof(float _X, float _Y, int *_Z)
     * }
     */
    public static MemorySegment remquof$address() {
        return remquof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float remquof(float _X, float _Y, int *_Z)
     * }
     */
    public static float remquof(float _X, float _Y, MemorySegment _Z) {
        var mh$ = remquof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remquof", _X, _Y, _Z);
            }
            return (float)mh$.invokeExact(_X, _Y, _Z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("rintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float rintf(float _X)
     * }
     */
    public static FunctionDescriptor rintf$descriptor() {
        return rintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float rintf(float _X)
     * }
     */
    public static MethodHandle rintf$handle() {
        return rintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float rintf(float _X)
     * }
     */
    public static MemorySegment rintf$address() {
        return rintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float rintf(float _X)
     * }
     */
    public static float rintf(float _X) {
        var mh$ = rintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rintf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class roundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("roundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float roundf(float _X)
     * }
     */
    public static FunctionDescriptor roundf$descriptor() {
        return roundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float roundf(float _X)
     * }
     */
    public static MethodHandle roundf$handle() {
        return roundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float roundf(float _X)
     * }
     */
    public static MemorySegment roundf$address() {
        return roundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float roundf(float _X)
     * }
     */
    public static float roundf(float _X) {
        var mh$ = roundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("roundf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalblnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT,
            Cubiomes.C_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("scalblnf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float scalblnf(float _X, long _Y)
     * }
     */
    public static FunctionDescriptor scalblnf$descriptor() {
        return scalblnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float scalblnf(float _X, long _Y)
     * }
     */
    public static MethodHandle scalblnf$handle() {
        return scalblnf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float scalblnf(float _X, long _Y)
     * }
     */
    public static MemorySegment scalblnf$address() {
        return scalblnf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float scalblnf(float _X, long _Y)
     * }
     */
    public static float scalblnf(float _X, int _Y) {
        var mh$ = scalblnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalblnf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("scalbnf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float scalbnf(float _X, int _Y)
     * }
     */
    public static FunctionDescriptor scalbnf$descriptor() {
        return scalbnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float scalbnf(float _X, int _Y)
     * }
     */
    public static MethodHandle scalbnf$handle() {
        return scalbnf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float scalbnf(float _X, int _Y)
     * }
     */
    public static MemorySegment scalbnf$address() {
        return scalbnf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float scalbnf(float _X, int _Y)
     * }
     */
    public static float scalbnf(float _X, int _Y) {
        var mh$ = scalbnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbnf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tgammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("tgammaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float tgammaf(float _X)
     * }
     */
    public static FunctionDescriptor tgammaf$descriptor() {
        return tgammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float tgammaf(float _X)
     * }
     */
    public static MethodHandle tgammaf$handle() {
        return tgammaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float tgammaf(float _X)
     * }
     */
    public static MemorySegment tgammaf$address() {
        return tgammaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float tgammaf(float _X)
     * }
     */
    public static float tgammaf(float _X) {
        var mh$ = tgammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tgammaf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class truncf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("truncf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float truncf(float _X)
     * }
     */
    public static FunctionDescriptor truncf$descriptor() {
        return truncf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float truncf(float _X)
     * }
     */
    public static MethodHandle truncf$handle() {
        return truncf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float truncf(float _X)
     * }
     */
    public static MemorySegment truncf$address() {
        return truncf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float truncf(float _X)
     * }
     */
    public static float truncf(float _X) {
        var mh$ = truncf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("truncf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _logbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_logbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _logbf(float _X)
     * }
     */
    public static FunctionDescriptor _logbf$descriptor() {
        return _logbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _logbf(float _X)
     * }
     */
    public static MethodHandle _logbf$handle() {
        return _logbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _logbf(float _X)
     * }
     */
    public static MemorySegment _logbf$address() {
        return _logbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _logbf(float _X)
     * }
     */
    public static float _logbf(float _X) {
        var mh$ = _logbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_logbf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _nextafterf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_nextafterf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _nextafterf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor _nextafterf$descriptor() {
        return _nextafterf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _nextafterf(float _X, float _Y)
     * }
     */
    public static MethodHandle _nextafterf$handle() {
        return _nextafterf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float _nextafterf(float _X, float _Y)
     * }
     */
    public static MemorySegment _nextafterf$address() {
        return _nextafterf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float _nextafterf(float _X, float _Y)
     * }
     */
    public static float _nextafterf(float _X, float _Y) {
        var mh$ = _nextafterf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_nextafterf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _finitef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_finitef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _finitef(float _X)
     * }
     */
    public static FunctionDescriptor _finitef$descriptor() {
        return _finitef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _finitef(float _X)
     * }
     */
    public static MethodHandle _finitef$handle() {
        return _finitef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _finitef(float _X)
     * }
     */
    public static MemorySegment _finitef$address() {
        return _finitef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _finitef(float _X)
     * }
     */
    public static int _finitef(float _X) {
        var mh$ = _finitef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_finitef", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _isnanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_isnanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _isnanf(float _X)
     * }
     */
    public static FunctionDescriptor _isnanf$descriptor() {
        return _isnanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _isnanf(float _X)
     * }
     */
    public static MethodHandle _isnanf$handle() {
        return _isnanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _isnanf(float _X)
     * }
     */
    public static MemorySegment _isnanf$address() {
        return _isnanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _isnanf(float _X)
     * }
     */
    public static int _isnanf(float _X) {
        var mh$ = _isnanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_isnanf", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fpclassf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_fpclassf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fpclassf(float _X)
     * }
     */
    public static FunctionDescriptor _fpclassf$descriptor() {
        return _fpclassf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fpclassf(float _X)
     * }
     */
    public static MethodHandle _fpclassf$handle() {
        return _fpclassf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fpclassf(float _X)
     * }
     */
    public static MemorySegment _fpclassf$address() {
        return _fpclassf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fpclassf(float _X)
     * }
     */
    public static int _fpclassf(float _X) {
        var mh$ = _fpclassf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fpclassf", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_FMA3_enable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_set_FMA3_enable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _set_FMA3_enable(int _Flag)
     * }
     */
    public static FunctionDescriptor _set_FMA3_enable$descriptor() {
        return _set_FMA3_enable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _set_FMA3_enable(int _Flag)
     * }
     */
    public static MethodHandle _set_FMA3_enable$handle() {
        return _set_FMA3_enable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _set_FMA3_enable(int _Flag)
     * }
     */
    public static MemorySegment _set_FMA3_enable$address() {
        return _set_FMA3_enable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _set_FMA3_enable(int _Flag)
     * }
     */
    public static int _set_FMA3_enable(int _Flag) {
        var mh$ = _set_FMA3_enable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_FMA3_enable", _Flag);
            }
            return (int)mh$.invokeExact(_Flag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_FMA3_enable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT    );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("_get_FMA3_enable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _get_FMA3_enable()
     * }
     */
    public static FunctionDescriptor _get_FMA3_enable$descriptor() {
        return _get_FMA3_enable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _get_FMA3_enable()
     * }
     */
    public static MethodHandle _get_FMA3_enable$handle() {
        return _get_FMA3_enable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _get_FMA3_enable()
     * }
     */
    public static MemorySegment _get_FMA3_enable$address() {
        return _get_FMA3_enable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _get_FMA3_enable()
     * }
     */
    public static int _get_FMA3_enable() {
        var mh$ = _get_FMA3_enable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_FMA3_enable");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("acosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float acosf(float _X)
     * }
     */
    public static FunctionDescriptor acosf$descriptor() {
        return acosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float acosf(float _X)
     * }
     */
    public static MethodHandle acosf$handle() {
        return acosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float acosf(float _X)
     * }
     */
    public static MemorySegment acosf$address() {
        return acosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float acosf(float _X)
     * }
     */
    public static float acosf(float _X) {
        var mh$ = acosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acosf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("asinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float asinf(float _X)
     * }
     */
    public static FunctionDescriptor asinf$descriptor() {
        return asinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float asinf(float _X)
     * }
     */
    public static MethodHandle asinf$handle() {
        return asinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float asinf(float _X)
     * }
     */
    public static MemorySegment asinf$address() {
        return asinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float asinf(float _X)
     * }
     */
    public static float asinf(float _X) {
        var mh$ = asinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atan2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("atan2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float atan2f(float _Y, float _X)
     * }
     */
    public static FunctionDescriptor atan2f$descriptor() {
        return atan2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float atan2f(float _Y, float _X)
     * }
     */
    public static MethodHandle atan2f$handle() {
        return atan2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float atan2f(float _Y, float _X)
     * }
     */
    public static MemorySegment atan2f$address() {
        return atan2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float atan2f(float _Y, float _X)
     * }
     */
    public static float atan2f(float _Y, float _X) {
        var mh$ = atan2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atan2f", _Y, _X);
            }
            return (float)mh$.invokeExact(_Y, _X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("atanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float atanf(float _X)
     * }
     */
    public static FunctionDescriptor atanf$descriptor() {
        return atanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float atanf(float _X)
     * }
     */
    public static MethodHandle atanf$handle() {
        return atanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float atanf(float _X)
     * }
     */
    public static MemorySegment atanf$address() {
        return atanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float atanf(float _X)
     * }
     */
    public static float atanf(float _X) {
        var mh$ = atanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ceilf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("ceilf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float ceilf(float _X)
     * }
     */
    public static FunctionDescriptor ceilf$descriptor() {
        return ceilf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float ceilf(float _X)
     * }
     */
    public static MethodHandle ceilf$handle() {
        return ceilf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float ceilf(float _X)
     * }
     */
    public static MemorySegment ceilf$address() {
        return ceilf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float ceilf(float _X)
     * }
     */
    public static float ceilf(float _X) {
        var mh$ = ceilf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ceilf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("cosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float cosf(float _X)
     * }
     */
    public static FunctionDescriptor cosf$descriptor() {
        return cosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float cosf(float _X)
     * }
     */
    public static MethodHandle cosf$handle() {
        return cosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float cosf(float _X)
     * }
     */
    public static MemorySegment cosf$address() {
        return cosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float cosf(float _X)
     * }
     */
    public static float cosf(float _X) {
        var mh$ = cosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cosf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class coshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("coshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float coshf(float _X)
     * }
     */
    public static FunctionDescriptor coshf$descriptor() {
        return coshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float coshf(float _X)
     * }
     */
    public static MethodHandle coshf$handle() {
        return coshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float coshf(float _X)
     * }
     */
    public static MemorySegment coshf$address() {
        return coshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float coshf(float _X)
     * }
     */
    public static float coshf(float _X) {
        var mh$ = coshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("coshf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("expf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float expf(float _X)
     * }
     */
    public static FunctionDescriptor expf$descriptor() {
        return expf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float expf(float _X)
     * }
     */
    public static MethodHandle expf$handle() {
        return expf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float expf(float _X)
     * }
     */
    public static MemorySegment expf$address() {
        return expf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float expf(float _X)
     * }
     */
    public static float expf(float _X) {
        var mh$ = expf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class floorf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("floorf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float floorf(float _X)
     * }
     */
    public static FunctionDescriptor floorf$descriptor() {
        return floorf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float floorf(float _X)
     * }
     */
    public static MethodHandle floorf$handle() {
        return floorf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float floorf(float _X)
     * }
     */
    public static MemorySegment floorf$address() {
        return floorf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float floorf(float _X)
     * }
     */
    public static float floorf(float _X) {
        var mh$ = floorf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("floorf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmodf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("fmodf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float fmodf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor fmodf$descriptor() {
        return fmodf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float fmodf(float _X, float _Y)
     * }
     */
    public static MethodHandle fmodf$handle() {
        return fmodf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float fmodf(float _X, float _Y)
     * }
     */
    public static MemorySegment fmodf$address() {
        return fmodf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float fmodf(float _X, float _Y)
     * }
     */
    public static float fmodf(float _X, float _Y) {
        var mh$ = fmodf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmodf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log10f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("log10f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float log10f(float _X)
     * }
     */
    public static FunctionDescriptor log10f$descriptor() {
        return log10f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float log10f(float _X)
     * }
     */
    public static MethodHandle log10f$handle() {
        return log10f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float log10f(float _X)
     * }
     */
    public static MemorySegment log10f$address() {
        return log10f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float log10f(float _X)
     * }
     */
    public static float log10f(float _X) {
        var mh$ = log10f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log10f", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("logf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float logf(float _X)
     * }
     */
    public static FunctionDescriptor logf$descriptor() {
        return logf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float logf(float _X)
     * }
     */
    public static MethodHandle logf$handle() {
        return logf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float logf(float _X)
     * }
     */
    public static MemorySegment logf$address() {
        return logf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float logf(float _X)
     * }
     */
    public static float logf(float _X) {
        var mh$ = logf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class modff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("modff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float modff(float _X, float *_Y)
     * }
     */
    public static FunctionDescriptor modff$descriptor() {
        return modff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float modff(float _X, float *_Y)
     * }
     */
    public static MethodHandle modff$handle() {
        return modff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float modff(float _X, float *_Y)
     * }
     */
    public static MemorySegment modff$address() {
        return modff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float modff(float _X, float *_Y)
     * }
     */
    public static float modff(float _X, MemorySegment _Y) {
        var mh$ = modff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("modff", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class powf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("powf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float powf(float _X, float _Y)
     * }
     */
    public static FunctionDescriptor powf$descriptor() {
        return powf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float powf(float _X, float _Y)
     * }
     */
    public static MethodHandle powf$handle() {
        return powf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float powf(float _X, float _Y)
     * }
     */
    public static MemorySegment powf$address() {
        return powf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float powf(float _X, float _Y)
     * }
     */
    public static float powf(float _X, float _Y) {
        var mh$ = powf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("powf", _X, _Y);
            }
            return (float)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("sinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float sinf(float _X)
     * }
     */
    public static FunctionDescriptor sinf$descriptor() {
        return sinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float sinf(float _X)
     * }
     */
    public static MethodHandle sinf$handle() {
        return sinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float sinf(float _X)
     * }
     */
    public static MemorySegment sinf$address() {
        return sinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float sinf(float _X)
     * }
     */
    public static float sinf(float _X) {
        var mh$ = sinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("sinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float sinhf(float _X)
     * }
     */
    public static FunctionDescriptor sinhf$descriptor() {
        return sinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float sinhf(float _X)
     * }
     */
    public static MethodHandle sinhf$handle() {
        return sinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float sinhf(float _X)
     * }
     */
    public static MemorySegment sinhf$address() {
        return sinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float sinhf(float _X)
     * }
     */
    public static float sinhf(float _X) {
        var mh$ = sinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinhf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sqrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("sqrtf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float sqrtf(float _X)
     * }
     */
    public static FunctionDescriptor sqrtf$descriptor() {
        return sqrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float sqrtf(float _X)
     * }
     */
    public static MethodHandle sqrtf$handle() {
        return sqrtf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float sqrtf(float _X)
     * }
     */
    public static MemorySegment sqrtf$address() {
        return sqrtf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float sqrtf(float _X)
     * }
     */
    public static float sqrtf(float _X) {
        var mh$ = sqrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sqrtf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("tanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float tanf(float _X)
     * }
     */
    public static FunctionDescriptor tanf$descriptor() {
        return tanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float tanf(float _X)
     * }
     */
    public static MethodHandle tanf$handle() {
        return tanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float tanf(float _X)
     * }
     */
    public static MemorySegment tanf$address() {
        return tanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float tanf(float _X)
     * }
     */
    public static float tanf(float _X) {
        var mh$ = tanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_FLOAT,
            Cubiomes.C_FLOAT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("tanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float tanhf(float _X)
     * }
     */
    public static FunctionDescriptor tanhf$descriptor() {
        return tanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float tanhf(float _X)
     * }
     */
    public static MethodHandle tanhf$handle() {
        return tanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float tanhf(float _X)
     * }
     */
    public static MemorySegment tanhf$address() {
        return tanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float tanhf(float _X)
     * }
     */
    public static float tanhf(float _X) {
        var mh$ = tanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanhf", _X);
            }
            return (float)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acoshl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("acoshl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double acoshl(long double _X)
     * }
     */
    public static FunctionDescriptor acoshl$descriptor() {
        return acoshl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double acoshl(long double _X)
     * }
     */
    public static MethodHandle acoshl$handle() {
        return acoshl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double acoshl(long double _X)
     * }
     */
    public static MemorySegment acoshl$address() {
        return acoshl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double acoshl(long double _X)
     * }
     */
    public static double acoshl(double _X) {
        var mh$ = acoshl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acoshl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinhl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("asinhl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double asinhl(long double _X)
     * }
     */
    public static FunctionDescriptor asinhl$descriptor() {
        return asinhl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double asinhl(long double _X)
     * }
     */
    public static MethodHandle asinhl$handle() {
        return asinhl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double asinhl(long double _X)
     * }
     */
    public static MemorySegment asinhl$address() {
        return asinhl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double asinhl(long double _X)
     * }
     */
    public static double asinhl(double _X) {
        var mh$ = asinhl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinhl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanhl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("atanhl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double atanhl(long double _X)
     * }
     */
    public static FunctionDescriptor atanhl$descriptor() {
        return atanhl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double atanhl(long double _X)
     * }
     */
    public static MethodHandle atanhl$handle() {
        return atanhl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double atanhl(long double _X)
     * }
     */
    public static MemorySegment atanhl$address() {
        return atanhl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double atanhl(long double _X)
     * }
     */
    public static double atanhl(double _X) {
        var mh$ = atanhl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanhl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cbrtl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("cbrtl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double cbrtl(long double _X)
     * }
     */
    public static FunctionDescriptor cbrtl$descriptor() {
        return cbrtl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double cbrtl(long double _X)
     * }
     */
    public static MethodHandle cbrtl$handle() {
        return cbrtl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double cbrtl(long double _X)
     * }
     */
    public static MemorySegment cbrtl$address() {
        return cbrtl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double cbrtl(long double _X)
     * }
     */
    public static double cbrtl(double _X) {
        var mh$ = cbrtl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cbrtl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class copysignl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("copysignl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double copysignl(long double _Number, long double _Sign)
     * }
     */
    public static FunctionDescriptor copysignl$descriptor() {
        return copysignl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double copysignl(long double _Number, long double _Sign)
     * }
     */
    public static MethodHandle copysignl$handle() {
        return copysignl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double copysignl(long double _Number, long double _Sign)
     * }
     */
    public static MemorySegment copysignl$address() {
        return copysignl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double copysignl(long double _Number, long double _Sign)
     * }
     */
    public static double copysignl(double _Number, double _Sign) {
        var mh$ = copysignl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("copysignl", _Number, _Sign);
            }
            return (double)mh$.invokeExact(_Number, _Sign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erfl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("erfl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double erfl(long double _X)
     * }
     */
    public static FunctionDescriptor erfl$descriptor() {
        return erfl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double erfl(long double _X)
     * }
     */
    public static MethodHandle erfl$handle() {
        return erfl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double erfl(long double _X)
     * }
     */
    public static MemorySegment erfl$address() {
        return erfl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double erfl(long double _X)
     * }
     */
    public static double erfl(double _X) {
        var mh$ = erfl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erfl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erfcl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("erfcl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double erfcl(long double _X)
     * }
     */
    public static FunctionDescriptor erfcl$descriptor() {
        return erfcl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double erfcl(long double _X)
     * }
     */
    public static MethodHandle erfcl$handle() {
        return erfcl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double erfcl(long double _X)
     * }
     */
    public static MemorySegment erfcl$address() {
        return erfcl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double erfcl(long double _X)
     * }
     */
    public static double erfcl(double _X) {
        var mh$ = erfcl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erfcl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp2l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("exp2l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double exp2l(long double _X)
     * }
     */
    public static FunctionDescriptor exp2l$descriptor() {
        return exp2l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double exp2l(long double _X)
     * }
     */
    public static MethodHandle exp2l$handle() {
        return exp2l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double exp2l(long double _X)
     * }
     */
    public static MemorySegment exp2l$address() {
        return exp2l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double exp2l(long double _X)
     * }
     */
    public static double exp2l(double _X) {
        var mh$ = exp2l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp2l", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expm1l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("expm1l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double expm1l(long double _X)
     * }
     */
    public static FunctionDescriptor expm1l$descriptor() {
        return expm1l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double expm1l(long double _X)
     * }
     */
    public static MethodHandle expm1l$handle() {
        return expm1l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double expm1l(long double _X)
     * }
     */
    public static MemorySegment expm1l$address() {
        return expm1l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double expm1l(long double _X)
     * }
     */
    public static double expm1l(double _X) {
        var mh$ = expm1l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expm1l", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdiml {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("fdiml");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double fdiml(long double _X, long double _Y)
     * }
     */
    public static FunctionDescriptor fdiml$descriptor() {
        return fdiml.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double fdiml(long double _X, long double _Y)
     * }
     */
    public static MethodHandle fdiml$handle() {
        return fdiml.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double fdiml(long double _X, long double _Y)
     * }
     */
    public static MemorySegment fdiml$address() {
        return fdiml.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double fdiml(long double _X, long double _Y)
     * }
     */
    public static double fdiml(double _X, double _Y) {
        var mh$ = fdiml.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdiml", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("fmal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double fmal(long double _X, long double _Y, long double _Z)
     * }
     */
    public static FunctionDescriptor fmal$descriptor() {
        return fmal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double fmal(long double _X, long double _Y, long double _Z)
     * }
     */
    public static MethodHandle fmal$handle() {
        return fmal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double fmal(long double _X, long double _Y, long double _Z)
     * }
     */
    public static MemorySegment fmal$address() {
        return fmal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double fmal(long double _X, long double _Y, long double _Z)
     * }
     */
    public static double fmal(double _X, double _Y, double _Z) {
        var mh$ = fmal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmal", _X, _Y, _Z);
            }
            return (double)mh$.invokeExact(_X, _Y, _Z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmaxl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("fmaxl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double fmaxl(long double _X, long double _Y)
     * }
     */
    public static FunctionDescriptor fmaxl$descriptor() {
        return fmaxl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double fmaxl(long double _X, long double _Y)
     * }
     */
    public static MethodHandle fmaxl$handle() {
        return fmaxl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double fmaxl(long double _X, long double _Y)
     * }
     */
    public static MemorySegment fmaxl$address() {
        return fmaxl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double fmaxl(long double _X, long double _Y)
     * }
     */
    public static double fmaxl(double _X, double _Y) {
        var mh$ = fmaxl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmaxl", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fminl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("fminl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double fminl(long double _X, long double _Y)
     * }
     */
    public static FunctionDescriptor fminl$descriptor() {
        return fminl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double fminl(long double _X, long double _Y)
     * }
     */
    public static MethodHandle fminl$handle() {
        return fminl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double fminl(long double _X, long double _Y)
     * }
     */
    public static MemorySegment fminl$address() {
        return fminl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double fminl(long double _X, long double _Y)
     * }
     */
    public static double fminl(double _X, double _Y) {
        var mh$ = fminl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fminl", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilogbl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("ilogbl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ilogbl(long double _X)
     * }
     */
    public static FunctionDescriptor ilogbl$descriptor() {
        return ilogbl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ilogbl(long double _X)
     * }
     */
    public static MethodHandle ilogbl$handle() {
        return ilogbl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ilogbl(long double _X)
     * }
     */
    public static MemorySegment ilogbl$address() {
        return ilogbl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ilogbl(long double _X)
     * }
     */
    public static int ilogbl(double _X) {
        var mh$ = ilogbl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilogbl", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgammal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("lgammal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double lgammal(long double _X)
     * }
     */
    public static FunctionDescriptor lgammal$descriptor() {
        return lgammal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double lgammal(long double _X)
     * }
     */
    public static MethodHandle lgammal$handle() {
        return lgammal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double lgammal(long double _X)
     * }
     */
    public static MemorySegment lgammal$address() {
        return lgammal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double lgammal(long double _X)
     * }
     */
    public static double lgammal(double _X) {
        var mh$ = lgammal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgammal", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llrintl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("llrintl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llrintl(long double _X)
     * }
     */
    public static FunctionDescriptor llrintl$descriptor() {
        return llrintl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llrintl(long double _X)
     * }
     */
    public static MethodHandle llrintl$handle() {
        return llrintl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llrintl(long double _X)
     * }
     */
    public static MemorySegment llrintl$address() {
        return llrintl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llrintl(long double _X)
     * }
     */
    public static long llrintl(double _X) {
        var mh$ = llrintl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llrintl", _X);
            }
            return (long)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llroundl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_LONG,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("llroundl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llroundl(long double _X)
     * }
     */
    public static FunctionDescriptor llroundl$descriptor() {
        return llroundl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llroundl(long double _X)
     * }
     */
    public static MethodHandle llroundl$handle() {
        return llroundl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llroundl(long double _X)
     * }
     */
    public static MemorySegment llroundl$address() {
        return llroundl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llroundl(long double _X)
     * }
     */
    public static long llroundl(double _X) {
        var mh$ = llroundl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llroundl", _X);
            }
            return (long)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log1pl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("log1pl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double log1pl(long double _X)
     * }
     */
    public static FunctionDescriptor log1pl$descriptor() {
        return log1pl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double log1pl(long double _X)
     * }
     */
    public static MethodHandle log1pl$handle() {
        return log1pl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double log1pl(long double _X)
     * }
     */
    public static MemorySegment log1pl$address() {
        return log1pl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double log1pl(long double _X)
     * }
     */
    public static double log1pl(double _X) {
        var mh$ = log1pl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log1pl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log2l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("log2l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double log2l(long double _X)
     * }
     */
    public static FunctionDescriptor log2l$descriptor() {
        return log2l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double log2l(long double _X)
     * }
     */
    public static MethodHandle log2l$handle() {
        return log2l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double log2l(long double _X)
     * }
     */
    public static MemorySegment log2l$address() {
        return log2l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double log2l(long double _X)
     * }
     */
    public static double log2l(double _X) {
        var mh$ = log2l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log2l", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logbl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("logbl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double logbl(long double _X)
     * }
     */
    public static FunctionDescriptor logbl$descriptor() {
        return logbl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double logbl(long double _X)
     * }
     */
    public static MethodHandle logbl$handle() {
        return logbl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double logbl(long double _X)
     * }
     */
    public static MemorySegment logbl$address() {
        return logbl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double logbl(long double _X)
     * }
     */
    public static double logbl(double _X) {
        var mh$ = logbl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logbl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrintl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("lrintl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lrintl(long double _X)
     * }
     */
    public static FunctionDescriptor lrintl$descriptor() {
        return lrintl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lrintl(long double _X)
     * }
     */
    public static MethodHandle lrintl$handle() {
        return lrintl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lrintl(long double _X)
     * }
     */
    public static MemorySegment lrintl$address() {
        return lrintl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lrintl(long double _X)
     * }
     */
    public static int lrintl(double _X) {
        var mh$ = lrintl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrintl", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lroundl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("lroundl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lroundl(long double _X)
     * }
     */
    public static FunctionDescriptor lroundl$descriptor() {
        return lroundl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lroundl(long double _X)
     * }
     */
    public static MethodHandle lroundl$handle() {
        return lroundl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lroundl(long double _X)
     * }
     */
    public static MemorySegment lroundl$address() {
        return lroundl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lroundl(long double _X)
     * }
     */
    public static int lroundl(double _X) {
        var mh$ = lroundl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lroundl", _X);
            }
            return (int)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nanl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("nanl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double nanl(const char *_X)
     * }
     */
    public static FunctionDescriptor nanl$descriptor() {
        return nanl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double nanl(const char *_X)
     * }
     */
    public static MethodHandle nanl$handle() {
        return nanl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double nanl(const char *_X)
     * }
     */
    public static MemorySegment nanl$address() {
        return nanl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double nanl(const char *_X)
     * }
     */
    public static double nanl(MemorySegment _X) {
        var mh$ = nanl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nanl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nearbyintl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("nearbyintl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double nearbyintl(long double _X)
     * }
     */
    public static FunctionDescriptor nearbyintl$descriptor() {
        return nearbyintl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double nearbyintl(long double _X)
     * }
     */
    public static MethodHandle nearbyintl$handle() {
        return nearbyintl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double nearbyintl(long double _X)
     * }
     */
    public static MemorySegment nearbyintl$address() {
        return nearbyintl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double nearbyintl(long double _X)
     * }
     */
    public static double nearbyintl(double _X) {
        var mh$ = nearbyintl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nearbyintl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nextafterl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("nextafterl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double nextafterl(long double _X, long double _Y)
     * }
     */
    public static FunctionDescriptor nextafterl$descriptor() {
        return nextafterl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double nextafterl(long double _X, long double _Y)
     * }
     */
    public static MethodHandle nextafterl$handle() {
        return nextafterl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double nextafterl(long double _X, long double _Y)
     * }
     */
    public static MemorySegment nextafterl$address() {
        return nextafterl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double nextafterl(long double _X, long double _Y)
     * }
     */
    public static double nextafterl(double _X, double _Y) {
        var mh$ = nextafterl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nextafterl", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nexttowardl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("nexttowardl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double nexttowardl(long double _X, long double _Y)
     * }
     */
    public static FunctionDescriptor nexttowardl$descriptor() {
        return nexttowardl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double nexttowardl(long double _X, long double _Y)
     * }
     */
    public static MethodHandle nexttowardl$handle() {
        return nexttowardl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double nexttowardl(long double _X, long double _Y)
     * }
     */
    public static MemorySegment nexttowardl$address() {
        return nexttowardl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double nexttowardl(long double _X, long double _Y)
     * }
     */
    public static double nexttowardl(double _X, double _Y) {
        var mh$ = nexttowardl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nexttowardl", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remainderl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("remainderl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double remainderl(long double _X, long double _Y)
     * }
     */
    public static FunctionDescriptor remainderl$descriptor() {
        return remainderl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double remainderl(long double _X, long double _Y)
     * }
     */
    public static MethodHandle remainderl$handle() {
        return remainderl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double remainderl(long double _X, long double _Y)
     * }
     */
    public static MemorySegment remainderl$address() {
        return remainderl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double remainderl(long double _X, long double _Y)
     * }
     */
    public static double remainderl(double _X, double _Y) {
        var mh$ = remainderl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remainderl", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remquol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("remquol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double remquol(long double _X, long double _Y, int *_Z)
     * }
     */
    public static FunctionDescriptor remquol$descriptor() {
        return remquol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double remquol(long double _X, long double _Y, int *_Z)
     * }
     */
    public static MethodHandle remquol$handle() {
        return remquol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double remquol(long double _X, long double _Y, int *_Z)
     * }
     */
    public static MemorySegment remquol$address() {
        return remquol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double remquol(long double _X, long double _Y, int *_Z)
     * }
     */
    public static double remquol(double _X, double _Y, MemorySegment _Z) {
        var mh$ = remquol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remquol", _X, _Y, _Z);
            }
            return (double)mh$.invokeExact(_X, _Y, _Z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rintl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("rintl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double rintl(long double _X)
     * }
     */
    public static FunctionDescriptor rintl$descriptor() {
        return rintl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double rintl(long double _X)
     * }
     */
    public static MethodHandle rintl$handle() {
        return rintl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double rintl(long double _X)
     * }
     */
    public static MemorySegment rintl$address() {
        return rintl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double rintl(long double _X)
     * }
     */
    public static double rintl(double _X) {
        var mh$ = rintl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rintl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class roundl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("roundl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double roundl(long double _X)
     * }
     */
    public static FunctionDescriptor roundl$descriptor() {
        return roundl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double roundl(long double _X)
     * }
     */
    public static MethodHandle roundl$handle() {
        return roundl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double roundl(long double _X)
     * }
     */
    public static MemorySegment roundl$address() {
        return roundl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double roundl(long double _X)
     * }
     */
    public static double roundl(double _X) {
        var mh$ = roundl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("roundl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalblnl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("scalblnl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double scalblnl(long double _X, long _Y)
     * }
     */
    public static FunctionDescriptor scalblnl$descriptor() {
        return scalblnl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double scalblnl(long double _X, long _Y)
     * }
     */
    public static MethodHandle scalblnl$handle() {
        return scalblnl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double scalblnl(long double _X, long _Y)
     * }
     */
    public static MemorySegment scalblnl$address() {
        return scalblnl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double scalblnl(long double _X, long _Y)
     * }
     */
    public static double scalblnl(double _X, int _Y) {
        var mh$ = scalblnl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalblnl", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbnl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("scalbnl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double scalbnl(long double _X, int _Y)
     * }
     */
    public static FunctionDescriptor scalbnl$descriptor() {
        return scalbnl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double scalbnl(long double _X, int _Y)
     * }
     */
    public static MethodHandle scalbnl$handle() {
        return scalbnl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double scalbnl(long double _X, int _Y)
     * }
     */
    public static MemorySegment scalbnl$address() {
        return scalbnl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double scalbnl(long double _X, int _Y)
     * }
     */
    public static double scalbnl(double _X, int _Y) {
        var mh$ = scalbnl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbnl", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tgammal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("tgammal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double tgammal(long double _X)
     * }
     */
    public static FunctionDescriptor tgammal$descriptor() {
        return tgammal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double tgammal(long double _X)
     * }
     */
    public static MethodHandle tgammal$handle() {
        return tgammal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double tgammal(long double _X)
     * }
     */
    public static MemorySegment tgammal$address() {
        return tgammal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double tgammal(long double _X)
     * }
     */
    public static double tgammal(double _X) {
        var mh$ = tgammal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tgammal", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class truncl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_LONG_DOUBLE,
            Cubiomes.C_LONG_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("truncl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double truncl(long double _X)
     * }
     */
    public static FunctionDescriptor truncl$descriptor() {
        return truncl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double truncl(long double _X)
     * }
     */
    public static MethodHandle truncl$handle() {
        return truncl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long double truncl(long double _X)
     * }
     */
    public static MemorySegment truncl$address() {
        return truncl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long double truncl(long double _X)
     * }
     */
    public static double truncl(double _X) {
        var mh$ = truncl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("truncl", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HUGE$constants {
        public static final OfDouble LAYOUT = Cubiomes.C_DOUBLE;
        public static final MemorySegment SEGMENT = Cubiomes.findOrThrow("HUGE").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern double HUGE
     * }
     */
    public static OfDouble HUGE$layout() {
        return HUGE$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern double HUGE
     * }
     */
    public static MemorySegment HUGE$segment() {
        return HUGE$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern double HUGE
     * }
     */
    public static double HUGE() {
        return HUGE$constants.SEGMENT.get(HUGE$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern double HUGE
     * }
     */
    public static void HUGE(double varValue) {
        HUGE$constants.SEGMENT.set(HUGE$constants.LAYOUT, 0L, varValue);
    }

    private static class j0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("j0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double j0(double _X)
     * }
     */
    public static FunctionDescriptor j0$descriptor() {
        return j0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double j0(double _X)
     * }
     */
    public static MethodHandle j0$handle() {
        return j0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double j0(double _X)
     * }
     */
    public static MemorySegment j0$address() {
        return j0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double j0(double _X)
     * }
     */
    public static double j0(double _X) {
        var mh$ = j0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("j0", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class j1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("j1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double j1(double _X)
     * }
     */
    public static FunctionDescriptor j1$descriptor() {
        return j1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double j1(double _X)
     * }
     */
    public static MethodHandle j1$handle() {
        return j1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double j1(double _X)
     * }
     */
    public static MemorySegment j1$address() {
        return j1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double j1(double _X)
     * }
     */
    public static double j1(double _X) {
        var mh$ = j1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("j1", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_INT,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("jn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double jn(int _X, double _Y)
     * }
     */
    public static FunctionDescriptor jn$descriptor() {
        return jn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double jn(int _X, double _Y)
     * }
     */
    public static MethodHandle jn$handle() {
        return jn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double jn(int _X, double _Y)
     * }
     */
    public static MemorySegment jn$address() {
        return jn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double jn(int _X, double _Y)
     * }
     */
    public static double jn(int _X, double _Y) {
        var mh$ = jn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jn", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class y0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("y0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double y0(double _X)
     * }
     */
    public static FunctionDescriptor y0$descriptor() {
        return y0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double y0(double _X)
     * }
     */
    public static MethodHandle y0$handle() {
        return y0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double y0(double _X)
     * }
     */
    public static MemorySegment y0$address() {
        return y0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double y0(double _X)
     * }
     */
    public static double y0(double _X) {
        var mh$ = y0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("y0", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class y1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("y1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double y1(double _X)
     * }
     */
    public static FunctionDescriptor y1$descriptor() {
        return y1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double y1(double _X)
     * }
     */
    public static MethodHandle y1$handle() {
        return y1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double y1(double _X)
     * }
     */
    public static MemorySegment y1$address() {
        return y1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double y1(double _X)
     * }
     */
    public static double y1(double _X) {
        var mh$ = y1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("y1", _X);
            }
            return (double)mh$.invokeExact(_X);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class yn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_INT,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("yn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double yn(int _X, double _Y)
     * }
     */
    public static FunctionDescriptor yn$descriptor() {
        return yn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double yn(int _X, double _Y)
     * }
     */
    public static MethodHandle yn$handle() {
        return yn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double yn(int _X, double _Y)
     * }
     */
    public static MemorySegment yn$address() {
        return yn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double yn(int _X, double _Y)
     * }
     */
    public static double yn(int _X, double _Y) {
        var mh$ = yn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("yn", _X, _Y);
            }
            return (double)mh$.invokeExact(_X, _Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class perlinInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("perlinInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void perlinInit(PerlinNoise *noise, uint64_t *seed)
     * }
     */
    public static FunctionDescriptor perlinInit$descriptor() {
        return perlinInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void perlinInit(PerlinNoise *noise, uint64_t *seed)
     * }
     */
    public static MethodHandle perlinInit$handle() {
        return perlinInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void perlinInit(PerlinNoise *noise, uint64_t *seed)
     * }
     */
    public static MemorySegment perlinInit$address() {
        return perlinInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void perlinInit(PerlinNoise *noise, uint64_t *seed)
     * }
     */
    public static void perlinInit(MemorySegment noise, MemorySegment seed) {
        var mh$ = perlinInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("perlinInit", noise, seed);
            }
            mh$.invokeExact(noise, seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xPerlinInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("xPerlinInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void xPerlinInit(PerlinNoise *noise, Xoroshiro *xr)
     * }
     */
    public static FunctionDescriptor xPerlinInit$descriptor() {
        return xPerlinInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void xPerlinInit(PerlinNoise *noise, Xoroshiro *xr)
     * }
     */
    public static MethodHandle xPerlinInit$handle() {
        return xPerlinInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void xPerlinInit(PerlinNoise *noise, Xoroshiro *xr)
     * }
     */
    public static MemorySegment xPerlinInit$address() {
        return xPerlinInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void xPerlinInit(PerlinNoise *noise, Xoroshiro *xr)
     * }
     */
    public static void xPerlinInit(MemorySegment noise, MemorySegment xr) {
        var mh$ = xPerlinInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xPerlinInit", noise, xr);
            }
            mh$.invokeExact(noise, xr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class samplePerlin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("samplePerlin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double samplePerlin(const PerlinNoise *noise, double x, double y, double z, double yamp, double ymin)
     * }
     */
    public static FunctionDescriptor samplePerlin$descriptor() {
        return samplePerlin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double samplePerlin(const PerlinNoise *noise, double x, double y, double z, double yamp, double ymin)
     * }
     */
    public static MethodHandle samplePerlin$handle() {
        return samplePerlin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double samplePerlin(const PerlinNoise *noise, double x, double y, double z, double yamp, double ymin)
     * }
     */
    public static MemorySegment samplePerlin$address() {
        return samplePerlin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double samplePerlin(const PerlinNoise *noise, double x, double y, double z, double yamp, double ymin)
     * }
     */
    public static double samplePerlin(MemorySegment noise, double x, double y, double z, double yamp, double ymin) {
        var mh$ = samplePerlin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("samplePerlin", noise, x, y, z, yamp, ymin);
            }
            return (double)mh$.invokeExact(noise, x, y, z, yamp, ymin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sampleSimplex2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("sampleSimplex2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sampleSimplex2D(const PerlinNoise *noise, double x, double y)
     * }
     */
    public static FunctionDescriptor sampleSimplex2D$descriptor() {
        return sampleSimplex2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sampleSimplex2D(const PerlinNoise *noise, double x, double y)
     * }
     */
    public static MethodHandle sampleSimplex2D$handle() {
        return sampleSimplex2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sampleSimplex2D(const PerlinNoise *noise, double x, double y)
     * }
     */
    public static MemorySegment sampleSimplex2D$address() {
        return sampleSimplex2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sampleSimplex2D(const PerlinNoise *noise, double x, double y)
     * }
     */
    public static double sampleSimplex2D(MemorySegment noise, double x, double y) {
        var mh$ = sampleSimplex2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sampleSimplex2D", noise, x, y);
            }
            return (double)mh$.invokeExact(noise, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class octaveInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("octaveInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void octaveInit(OctaveNoise *noise, uint64_t *seed, PerlinNoise *octaves, int omin, int len)
     * }
     */
    public static FunctionDescriptor octaveInit$descriptor() {
        return octaveInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void octaveInit(OctaveNoise *noise, uint64_t *seed, PerlinNoise *octaves, int omin, int len)
     * }
     */
    public static MethodHandle octaveInit$handle() {
        return octaveInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void octaveInit(OctaveNoise *noise, uint64_t *seed, PerlinNoise *octaves, int omin, int len)
     * }
     */
    public static MemorySegment octaveInit$address() {
        return octaveInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void octaveInit(OctaveNoise *noise, uint64_t *seed, PerlinNoise *octaves, int omin, int len)
     * }
     */
    public static void octaveInit(MemorySegment noise, MemorySegment seed, MemorySegment octaves, int omin, int len) {
        var mh$ = octaveInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("octaveInit", noise, seed, octaves, omin, len);
            }
            mh$.invokeExact(noise, seed, octaves, omin, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class octaveInitBeta {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("octaveInitBeta");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void octaveInitBeta(OctaveNoise *noise, uint64_t *seed, PerlinNoise *octaves, int octcnt, double lac, double lacMul, double persist, double persistMul)
     * }
     */
    public static FunctionDescriptor octaveInitBeta$descriptor() {
        return octaveInitBeta.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void octaveInitBeta(OctaveNoise *noise, uint64_t *seed, PerlinNoise *octaves, int octcnt, double lac, double lacMul, double persist, double persistMul)
     * }
     */
    public static MethodHandle octaveInitBeta$handle() {
        return octaveInitBeta.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void octaveInitBeta(OctaveNoise *noise, uint64_t *seed, PerlinNoise *octaves, int octcnt, double lac, double lacMul, double persist, double persistMul)
     * }
     */
    public static MemorySegment octaveInitBeta$address() {
        return octaveInitBeta.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void octaveInitBeta(OctaveNoise *noise, uint64_t *seed, PerlinNoise *octaves, int octcnt, double lac, double lacMul, double persist, double persistMul)
     * }
     */
    public static void octaveInitBeta(MemorySegment noise, MemorySegment seed, MemorySegment octaves, int octcnt, double lac, double lacMul, double persist, double persistMul) {
        var mh$ = octaveInitBeta.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("octaveInitBeta", noise, seed, octaves, octcnt, lac, lacMul, persist, persistMul);
            }
            mh$.invokeExact(noise, seed, octaves, octcnt, lac, lacMul, persist, persistMul);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xOctaveInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("xOctaveInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xOctaveInit(OctaveNoise *noise, Xoroshiro *xr, PerlinNoise *octaves, const double *amplitudes, int omin, int len, int nmax)
     * }
     */
    public static FunctionDescriptor xOctaveInit$descriptor() {
        return xOctaveInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xOctaveInit(OctaveNoise *noise, Xoroshiro *xr, PerlinNoise *octaves, const double *amplitudes, int omin, int len, int nmax)
     * }
     */
    public static MethodHandle xOctaveInit$handle() {
        return xOctaveInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xOctaveInit(OctaveNoise *noise, Xoroshiro *xr, PerlinNoise *octaves, const double *amplitudes, int omin, int len, int nmax)
     * }
     */
    public static MemorySegment xOctaveInit$address() {
        return xOctaveInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xOctaveInit(OctaveNoise *noise, Xoroshiro *xr, PerlinNoise *octaves, const double *amplitudes, int omin, int len, int nmax)
     * }
     */
    public static int xOctaveInit(MemorySegment noise, MemorySegment xr, MemorySegment octaves, MemorySegment amplitudes, int omin, int len, int nmax) {
        var mh$ = xOctaveInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xOctaveInit", noise, xr, octaves, amplitudes, omin, len, nmax);
            }
            return (int)mh$.invokeExact(noise, xr, octaves, amplitudes, omin, len, nmax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sampleOctave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("sampleOctave");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sampleOctave(const OctaveNoise *noise, double x, double y, double z)
     * }
     */
    public static FunctionDescriptor sampleOctave$descriptor() {
        return sampleOctave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sampleOctave(const OctaveNoise *noise, double x, double y, double z)
     * }
     */
    public static MethodHandle sampleOctave$handle() {
        return sampleOctave.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sampleOctave(const OctaveNoise *noise, double x, double y, double z)
     * }
     */
    public static MemorySegment sampleOctave$address() {
        return sampleOctave.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sampleOctave(const OctaveNoise *noise, double x, double y, double z)
     * }
     */
    public static double sampleOctave(MemorySegment noise, double x, double y, double z) {
        var mh$ = sampleOctave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sampleOctave", noise, x, y, z);
            }
            return (double)mh$.invokeExact(noise, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sampleOctaveAmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("sampleOctaveAmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sampleOctaveAmp(const OctaveNoise *noise, double x, double y, double z, double yamp, double ymin, int ydefault)
     * }
     */
    public static FunctionDescriptor sampleOctaveAmp$descriptor() {
        return sampleOctaveAmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sampleOctaveAmp(const OctaveNoise *noise, double x, double y, double z, double yamp, double ymin, int ydefault)
     * }
     */
    public static MethodHandle sampleOctaveAmp$handle() {
        return sampleOctaveAmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sampleOctaveAmp(const OctaveNoise *noise, double x, double y, double z, double yamp, double ymin, int ydefault)
     * }
     */
    public static MemorySegment sampleOctaveAmp$address() {
        return sampleOctaveAmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sampleOctaveAmp(const OctaveNoise *noise, double x, double y, double z, double yamp, double ymin, int ydefault)
     * }
     */
    public static double sampleOctaveAmp(MemorySegment noise, double x, double y, double z, double yamp, double ymin, int ydefault) {
        var mh$ = sampleOctaveAmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sampleOctaveAmp", noise, x, y, z, yamp, ymin, ydefault);
            }
            return (double)mh$.invokeExact(noise, x, y, z, yamp, ymin, ydefault);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sampleOctave2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("sampleOctave2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sampleOctave2D(const OctaveNoise *noise, double x, double z)
     * }
     */
    public static FunctionDescriptor sampleOctave2D$descriptor() {
        return sampleOctave2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sampleOctave2D(const OctaveNoise *noise, double x, double z)
     * }
     */
    public static MethodHandle sampleOctave2D$handle() {
        return sampleOctave2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sampleOctave2D(const OctaveNoise *noise, double x, double z)
     * }
     */
    public static MemorySegment sampleOctave2D$address() {
        return sampleOctave2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sampleOctave2D(const OctaveNoise *noise, double x, double z)
     * }
     */
    public static double sampleOctave2D(MemorySegment noise, double x, double z) {
        var mh$ = sampleOctave2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sampleOctave2D", noise, x, z);
            }
            return (double)mh$.invokeExact(noise, x, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sampleOctaveBeta17Biome {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("sampleOctaveBeta17Biome");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sampleOctaveBeta17Biome(const OctaveNoise *noise, double x, double z)
     * }
     */
    public static FunctionDescriptor sampleOctaveBeta17Biome$descriptor() {
        return sampleOctaveBeta17Biome.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sampleOctaveBeta17Biome(const OctaveNoise *noise, double x, double z)
     * }
     */
    public static MethodHandle sampleOctaveBeta17Biome$handle() {
        return sampleOctaveBeta17Biome.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sampleOctaveBeta17Biome(const OctaveNoise *noise, double x, double z)
     * }
     */
    public static MemorySegment sampleOctaveBeta17Biome$address() {
        return sampleOctaveBeta17Biome.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sampleOctaveBeta17Biome(const OctaveNoise *noise, double x, double z)
     * }
     */
    public static double sampleOctaveBeta17Biome(MemorySegment noise, double x, double z) {
        var mh$ = sampleOctaveBeta17Biome.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sampleOctaveBeta17Biome", noise, x, z);
            }
            return (double)mh$.invokeExact(noise, x, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sampleOctaveBeta17Terrain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_INT,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("sampleOctaveBeta17Terrain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sampleOctaveBeta17Terrain(const OctaveNoise *noise, double *v, double x, double z, int yLacFlag, double lacmin)
     * }
     */
    public static FunctionDescriptor sampleOctaveBeta17Terrain$descriptor() {
        return sampleOctaveBeta17Terrain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sampleOctaveBeta17Terrain(const OctaveNoise *noise, double *v, double x, double z, int yLacFlag, double lacmin)
     * }
     */
    public static MethodHandle sampleOctaveBeta17Terrain$handle() {
        return sampleOctaveBeta17Terrain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sampleOctaveBeta17Terrain(const OctaveNoise *noise, double *v, double x, double z, int yLacFlag, double lacmin)
     * }
     */
    public static MemorySegment sampleOctaveBeta17Terrain$address() {
        return sampleOctaveBeta17Terrain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sampleOctaveBeta17Terrain(const OctaveNoise *noise, double *v, double x, double z, int yLacFlag, double lacmin)
     * }
     */
    public static void sampleOctaveBeta17Terrain(MemorySegment noise, MemorySegment v, double x, double z, int yLacFlag, double lacmin) {
        var mh$ = sampleOctaveBeta17Terrain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sampleOctaveBeta17Terrain", noise, v, x, z, yLacFlag, lacmin);
            }
            mh$.invokeExact(noise, v, x, z, yLacFlag, lacmin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class doublePerlinInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("doublePerlinInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void doublePerlinInit(DoublePerlinNoise *noise, uint64_t *seed, PerlinNoise *octavesA, PerlinNoise *octavesB, int omin, int len)
     * }
     */
    public static FunctionDescriptor doublePerlinInit$descriptor() {
        return doublePerlinInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void doublePerlinInit(DoublePerlinNoise *noise, uint64_t *seed, PerlinNoise *octavesA, PerlinNoise *octavesB, int omin, int len)
     * }
     */
    public static MethodHandle doublePerlinInit$handle() {
        return doublePerlinInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void doublePerlinInit(DoublePerlinNoise *noise, uint64_t *seed, PerlinNoise *octavesA, PerlinNoise *octavesB, int omin, int len)
     * }
     */
    public static MemorySegment doublePerlinInit$address() {
        return doublePerlinInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void doublePerlinInit(DoublePerlinNoise *noise, uint64_t *seed, PerlinNoise *octavesA, PerlinNoise *octavesB, int omin, int len)
     * }
     */
    public static void doublePerlinInit(MemorySegment noise, MemorySegment seed, MemorySegment octavesA, MemorySegment octavesB, int omin, int len) {
        var mh$ = doublePerlinInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("doublePerlinInit", noise, seed, octavesA, octavesB, omin, len);
            }
            mh$.invokeExact(noise, seed, octavesA, octavesB, omin, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xDoublePerlinInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("xDoublePerlinInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xDoublePerlinInit(DoublePerlinNoise *noise, Xoroshiro *xr, PerlinNoise *octaves, const double *amplitudes, int omin, int len, int nmax)
     * }
     */
    public static FunctionDescriptor xDoublePerlinInit$descriptor() {
        return xDoublePerlinInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xDoublePerlinInit(DoublePerlinNoise *noise, Xoroshiro *xr, PerlinNoise *octaves, const double *amplitudes, int omin, int len, int nmax)
     * }
     */
    public static MethodHandle xDoublePerlinInit$handle() {
        return xDoublePerlinInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xDoublePerlinInit(DoublePerlinNoise *noise, Xoroshiro *xr, PerlinNoise *octaves, const double *amplitudes, int omin, int len, int nmax)
     * }
     */
    public static MemorySegment xDoublePerlinInit$address() {
        return xDoublePerlinInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xDoublePerlinInit(DoublePerlinNoise *noise, Xoroshiro *xr, PerlinNoise *octaves, const double *amplitudes, int omin, int len, int nmax)
     * }
     */
    public static int xDoublePerlinInit(MemorySegment noise, MemorySegment xr, MemorySegment octaves, MemorySegment amplitudes, int omin, int len, int nmax) {
        var mh$ = xDoublePerlinInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xDoublePerlinInit", noise, xr, octaves, amplitudes, omin, len, nmax);
            }
            return (int)mh$.invokeExact(noise, xr, octaves, amplitudes, omin, len, nmax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sampleDoublePerlin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_DOUBLE,
            Cubiomes.C_POINTER,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE,
            Cubiomes.C_DOUBLE
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("sampleDoublePerlin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double sampleDoublePerlin(const DoublePerlinNoise *noise, double x, double y, double z)
     * }
     */
    public static FunctionDescriptor sampleDoublePerlin$descriptor() {
        return sampleDoublePerlin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double sampleDoublePerlin(const DoublePerlinNoise *noise, double x, double y, double z)
     * }
     */
    public static MethodHandle sampleDoublePerlin$handle() {
        return sampleDoublePerlin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double sampleDoublePerlin(const DoublePerlinNoise *noise, double x, double y, double z)
     * }
     */
    public static MemorySegment sampleDoublePerlin$address() {
        return sampleDoublePerlin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double sampleDoublePerlin(const DoublePerlinNoise *noise, double x, double y, double z)
     * }
     */
    public static double sampleDoublePerlin(MemorySegment noise, double x, double y, double z) {
        var mh$ = sampleDoublePerlin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sampleDoublePerlin", noise, x, y, z);
            }
            return (double)mh$.invokeExact(noise, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int MC_UNDEF = (int)0L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_UNDEF = 0
     * }
     */
    public static int MC_UNDEF() {
        return MC_UNDEF;
    }
    private static final int MC_B1_7 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_B1_7 = 1
     * }
     */
    public static int MC_B1_7() {
        return MC_B1_7;
    }
    private static final int MC_B1_8 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_B1_8 = 2
     * }
     */
    public static int MC_B1_8() {
        return MC_B1_8;
    }
    private static final int MC_1_0_0 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_0_0 = 3
     * }
     */
    public static int MC_1_0_0() {
        return MC_1_0_0;
    }
    private static final int MC_1_0 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_0 = 3
     * }
     */
    public static int MC_1_0() {
        return MC_1_0;
    }
    private static final int MC_1_1_0 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_1_0 = 4
     * }
     */
    public static int MC_1_1_0() {
        return MC_1_1_0;
    }
    private static final int MC_1_1 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_1 = 4
     * }
     */
    public static int MC_1_1() {
        return MC_1_1;
    }
    private static final int MC_1_2_5 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_2_5 = 5
     * }
     */
    public static int MC_1_2_5() {
        return MC_1_2_5;
    }
    private static final int MC_1_2 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_2 = 5
     * }
     */
    public static int MC_1_2() {
        return MC_1_2;
    }
    private static final int MC_1_3_2 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_3_2 = 6
     * }
     */
    public static int MC_1_3_2() {
        return MC_1_3_2;
    }
    private static final int MC_1_3 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_3 = 6
     * }
     */
    public static int MC_1_3() {
        return MC_1_3;
    }
    private static final int MC_1_4_7 = (int)7L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_4_7 = 7
     * }
     */
    public static int MC_1_4_7() {
        return MC_1_4_7;
    }
    private static final int MC_1_4 = (int)7L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_4 = 7
     * }
     */
    public static int MC_1_4() {
        return MC_1_4;
    }
    private static final int MC_1_5_2 = (int)8L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_5_2 = 8
     * }
     */
    public static int MC_1_5_2() {
        return MC_1_5_2;
    }
    private static final int MC_1_5 = (int)8L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_5 = 8
     * }
     */
    public static int MC_1_5() {
        return MC_1_5;
    }
    private static final int MC_1_6_4 = (int)9L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_6_4 = 9
     * }
     */
    public static int MC_1_6_4() {
        return MC_1_6_4;
    }
    private static final int MC_1_6 = (int)9L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_6 = 9
     * }
     */
    public static int MC_1_6() {
        return MC_1_6;
    }
    private static final int MC_1_7_10 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_7_10 = 10
     * }
     */
    public static int MC_1_7_10() {
        return MC_1_7_10;
    }
    private static final int MC_1_7 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_7 = 10
     * }
     */
    public static int MC_1_7() {
        return MC_1_7;
    }
    private static final int MC_1_8_9 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_8_9 = 11
     * }
     */
    public static int MC_1_8_9() {
        return MC_1_8_9;
    }
    private static final int MC_1_8 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_8 = 11
     * }
     */
    public static int MC_1_8() {
        return MC_1_8;
    }
    private static final int MC_1_9_4 = (int)12L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_9_4 = 12
     * }
     */
    public static int MC_1_9_4() {
        return MC_1_9_4;
    }
    private static final int MC_1_9 = (int)12L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_9 = 12
     * }
     */
    public static int MC_1_9() {
        return MC_1_9;
    }
    private static final int MC_1_10_2 = (int)13L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_10_2 = 13
     * }
     */
    public static int MC_1_10_2() {
        return MC_1_10_2;
    }
    private static final int MC_1_10 = (int)13L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_10 = 13
     * }
     */
    public static int MC_1_10() {
        return MC_1_10;
    }
    private static final int MC_1_11_2 = (int)14L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_11_2 = 14
     * }
     */
    public static int MC_1_11_2() {
        return MC_1_11_2;
    }
    private static final int MC_1_11 = (int)14L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_11 = 14
     * }
     */
    public static int MC_1_11() {
        return MC_1_11;
    }
    private static final int MC_1_12_2 = (int)15L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_12_2 = 15
     * }
     */
    public static int MC_1_12_2() {
        return MC_1_12_2;
    }
    private static final int MC_1_12 = (int)15L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_12 = 15
     * }
     */
    public static int MC_1_12() {
        return MC_1_12;
    }
    private static final int MC_1_13_2 = (int)16L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_13_2 = 16
     * }
     */
    public static int MC_1_13_2() {
        return MC_1_13_2;
    }
    private static final int MC_1_13 = (int)16L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_13 = 16
     * }
     */
    public static int MC_1_13() {
        return MC_1_13;
    }
    private static final int MC_1_14_4 = (int)17L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_14_4 = 17
     * }
     */
    public static int MC_1_14_4() {
        return MC_1_14_4;
    }
    private static final int MC_1_14 = (int)17L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_14 = 17
     * }
     */
    public static int MC_1_14() {
        return MC_1_14;
    }
    private static final int MC_1_15_2 = (int)18L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_15_2 = 18
     * }
     */
    public static int MC_1_15_2() {
        return MC_1_15_2;
    }
    private static final int MC_1_15 = (int)18L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_15 = 18
     * }
     */
    public static int MC_1_15() {
        return MC_1_15;
    }
    private static final int MC_1_16_1 = (int)19L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_16_1 = 19
     * }
     */
    public static int MC_1_16_1() {
        return MC_1_16_1;
    }
    private static final int MC_1_16_5 = (int)20L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_16_5 = 20
     * }
     */
    public static int MC_1_16_5() {
        return MC_1_16_5;
    }
    private static final int MC_1_16 = (int)20L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_16 = 20
     * }
     */
    public static int MC_1_16() {
        return MC_1_16;
    }
    private static final int MC_1_17_1 = (int)21L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_17_1 = 21
     * }
     */
    public static int MC_1_17_1() {
        return MC_1_17_1;
    }
    private static final int MC_1_17 = (int)21L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_17 = 21
     * }
     */
    public static int MC_1_17() {
        return MC_1_17;
    }
    private static final int MC_1_18_2 = (int)22L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_18_2 = 22
     * }
     */
    public static int MC_1_18_2() {
        return MC_1_18_2;
    }
    private static final int MC_1_18 = (int)22L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_18 = 22
     * }
     */
    public static int MC_1_18() {
        return MC_1_18;
    }
    private static final int MC_1_19_2 = (int)23L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_19_2 = 23
     * }
     */
    public static int MC_1_19_2() {
        return MC_1_19_2;
    }
    private static final int MC_1_19_4 = (int)24L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_19_4 = 24
     * }
     */
    public static int MC_1_19_4() {
        return MC_1_19_4;
    }
    private static final int MC_1_19 = (int)24L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_19 = 24
     * }
     */
    public static int MC_1_19() {
        return MC_1_19;
    }
    private static final int MC_1_20_6 = (int)25L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_20_6 = 25
     * }
     */
    public static int MC_1_20_6() {
        return MC_1_20_6;
    }
    private static final int MC_1_20 = (int)25L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_20 = 25
     * }
     */
    public static int MC_1_20() {
        return MC_1_20;
    }
    private static final int MC_1_21_1 = (int)26L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_21_1 = 26
     * }
     */
    public static int MC_1_21_1() {
        return MC_1_21_1;
    }
    private static final int MC_1_21_3 = (int)27L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_21_3 = 27
     * }
     */
    public static int MC_1_21_3() {
        return MC_1_21_3;
    }
    private static final int MC_1_21_WD = (int)28L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_21_WD = 28
     * }
     */
    public static int MC_1_21_WD() {
        return MC_1_21_WD;
    }
    private static final int MC_1_21 = (int)28L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_1_21 = 28
     * }
     */
    public static int MC_1_21() {
        return MC_1_21;
    }
    private static final int MC_NEWEST = (int)28L;
    /**
     * {@snippet lang=c :
     * enum MCVersion.MC_NEWEST = 28
     * }
     */
    public static int MC_NEWEST() {
        return MC_NEWEST;
    }
    private static final int DIM_NETHER = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum Dimension.DIM_NETHER = -1
     * }
     */
    public static int DIM_NETHER() {
        return DIM_NETHER;
    }
    private static final int DIM_OVERWORLD = (int)0L;
    /**
     * {@snippet lang=c :
     * enum Dimension.DIM_OVERWORLD = 0
     * }
     */
    public static int DIM_OVERWORLD() {
        return DIM_OVERWORLD;
    }
    private static final int DIM_END = (int)1L;
    /**
     * {@snippet lang=c :
     * enum Dimension.DIM_END = 1
     * }
     */
    public static int DIM_END() {
        return DIM_END;
    }
    private static final int DIM_UNDEF = (int)1000L;
    /**
     * {@snippet lang=c :
     * enum Dimension.DIM_UNDEF = 1000
     * }
     */
    public static int DIM_UNDEF() {
        return DIM_UNDEF;
    }
    private static final int none = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.none = -1
     * }
     */
    public static int none() {
        return none;
    }
    private static final int ocean = (int)0L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.ocean = 0
     * }
     */
    public static int ocean() {
        return ocean;
    }
    private static final int plains = (int)1L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.plains = 1
     * }
     */
    public static int plains() {
        return plains;
    }
    private static final int desert = (int)2L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.desert = 2
     * }
     */
    public static int desert() {
        return desert;
    }
    private static final int mountains = (int)3L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.mountains = 3
     * }
     */
    public static int mountains() {
        return mountains;
    }
    private static final int extremeHills = (int)3L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.extremeHills = 3
     * }
     */
    public static int extremeHills() {
        return extremeHills;
    }
    private static final int forest = (int)4L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.forest = 4
     * }
     */
    public static int forest() {
        return forest;
    }
    private static final int taiga = (int)5L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.taiga = 5
     * }
     */
    public static int taiga() {
        return taiga;
    }
    private static final int swamp = (int)6L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.swamp = 6
     * }
     */
    public static int swamp() {
        return swamp;
    }
    private static final int swampland = (int)6L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.swampland = 6
     * }
     */
    public static int swampland() {
        return swampland;
    }
    private static final int river = (int)7L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.river = 7
     * }
     */
    public static int river() {
        return river;
    }
    private static final int nether_wastes = (int)8L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.nether_wastes = 8
     * }
     */
    public static int nether_wastes() {
        return nether_wastes;
    }
    private static final int hell = (int)8L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.hell = 8
     * }
     */
    public static int hell() {
        return hell;
    }
    private static final int the_end = (int)9L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.the_end = 9
     * }
     */
    public static int the_end() {
        return the_end;
    }
    private static final int sky = (int)9L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.sky = 9
     * }
     */
    public static int sky() {
        return sky;
    }
    private static final int frozen_ocean = (int)10L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.frozen_ocean = 10
     * }
     */
    public static int frozen_ocean() {
        return frozen_ocean;
    }
    private static final int frozenOcean = (int)10L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.frozenOcean = 10
     * }
     */
    public static int frozenOcean() {
        return frozenOcean;
    }
    private static final int frozen_river = (int)11L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.frozen_river = 11
     * }
     */
    public static int frozen_river() {
        return frozen_river;
    }
    private static final int frozenRiver = (int)11L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.frozenRiver = 11
     * }
     */
    public static int frozenRiver() {
        return frozenRiver;
    }
    private static final int snowy_tundra = (int)12L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.snowy_tundra = 12
     * }
     */
    public static int snowy_tundra() {
        return snowy_tundra;
    }
    private static final int icePlains = (int)12L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.icePlains = 12
     * }
     */
    public static int icePlains() {
        return icePlains;
    }
    private static final int snowy_mountains = (int)13L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.snowy_mountains = 13
     * }
     */
    public static int snowy_mountains() {
        return snowy_mountains;
    }
    private static final int iceMountains = (int)13L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.iceMountains = 13
     * }
     */
    public static int iceMountains() {
        return iceMountains;
    }
    private static final int mushroom_fields = (int)14L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.mushroom_fields = 14
     * }
     */
    public static int mushroom_fields() {
        return mushroom_fields;
    }
    private static final int mushroomIsland = (int)14L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.mushroomIsland = 14
     * }
     */
    public static int mushroomIsland() {
        return mushroomIsland;
    }
    private static final int mushroom_field_shore = (int)15L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.mushroom_field_shore = 15
     * }
     */
    public static int mushroom_field_shore() {
        return mushroom_field_shore;
    }
    private static final int mushroomIslandShore = (int)15L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.mushroomIslandShore = 15
     * }
     */
    public static int mushroomIslandShore() {
        return mushroomIslandShore;
    }
    private static final int beach = (int)16L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.beach = 16
     * }
     */
    public static int beach() {
        return beach;
    }
    private static final int desert_hills = (int)17L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.desert_hills = 17
     * }
     */
    public static int desert_hills() {
        return desert_hills;
    }
    private static final int desertHills = (int)17L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.desertHills = 17
     * }
     */
    public static int desertHills() {
        return desertHills;
    }
    private static final int wooded_hills = (int)18L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.wooded_hills = 18
     * }
     */
    public static int wooded_hills() {
        return wooded_hills;
    }
    private static final int forestHills = (int)18L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.forestHills = 18
     * }
     */
    public static int forestHills() {
        return forestHills;
    }
    private static final int taiga_hills = (int)19L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.taiga_hills = 19
     * }
     */
    public static int taiga_hills() {
        return taiga_hills;
    }
    private static final int taigaHills = (int)19L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.taigaHills = 19
     * }
     */
    public static int taigaHills() {
        return taigaHills;
    }
    private static final int mountain_edge = (int)20L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.mountain_edge = 20
     * }
     */
    public static int mountain_edge() {
        return mountain_edge;
    }
    private static final int extremeHillsEdge = (int)20L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.extremeHillsEdge = 20
     * }
     */
    public static int extremeHillsEdge() {
        return extremeHillsEdge;
    }
    private static final int jungle = (int)21L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.jungle = 21
     * }
     */
    public static int jungle() {
        return jungle;
    }
    private static final int jungle_hills = (int)22L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.jungle_hills = 22
     * }
     */
    public static int jungle_hills() {
        return jungle_hills;
    }
    private static final int jungleHills = (int)22L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.jungleHills = 22
     * }
     */
    public static int jungleHills() {
        return jungleHills;
    }
    private static final int jungle_edge = (int)23L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.jungle_edge = 23
     * }
     */
    public static int jungle_edge() {
        return jungle_edge;
    }
    private static final int jungleEdge = (int)23L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.jungleEdge = 23
     * }
     */
    public static int jungleEdge() {
        return jungleEdge;
    }
    private static final int deep_ocean = (int)24L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.deep_ocean = 24
     * }
     */
    public static int deep_ocean() {
        return deep_ocean;
    }
    private static final int deepOcean = (int)24L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.deepOcean = 24
     * }
     */
    public static int deepOcean() {
        return deepOcean;
    }
    private static final int stone_shore = (int)25L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.stone_shore = 25
     * }
     */
    public static int stone_shore() {
        return stone_shore;
    }
    private static final int stoneBeach = (int)25L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.stoneBeach = 25
     * }
     */
    public static int stoneBeach() {
        return stoneBeach;
    }
    private static final int snowy_beach = (int)26L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.snowy_beach = 26
     * }
     */
    public static int snowy_beach() {
        return snowy_beach;
    }
    private static final int coldBeach = (int)26L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.coldBeach = 26
     * }
     */
    public static int coldBeach() {
        return coldBeach;
    }
    private static final int birch_forest = (int)27L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.birch_forest = 27
     * }
     */
    public static int birch_forest() {
        return birch_forest;
    }
    private static final int birchForest = (int)27L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.birchForest = 27
     * }
     */
    public static int birchForest() {
        return birchForest;
    }
    private static final int birch_forest_hills = (int)28L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.birch_forest_hills = 28
     * }
     */
    public static int birch_forest_hills() {
        return birch_forest_hills;
    }
    private static final int birchForestHills = (int)28L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.birchForestHills = 28
     * }
     */
    public static int birchForestHills() {
        return birchForestHills;
    }
    private static final int dark_forest = (int)29L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.dark_forest = 29
     * }
     */
    public static int dark_forest() {
        return dark_forest;
    }
    private static final int roofedForest = (int)29L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.roofedForest = 29
     * }
     */
    public static int roofedForest() {
        return roofedForest;
    }
    private static final int snowy_taiga = (int)30L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.snowy_taiga = 30
     * }
     */
    public static int snowy_taiga() {
        return snowy_taiga;
    }
    private static final int coldTaiga = (int)30L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.coldTaiga = 30
     * }
     */
    public static int coldTaiga() {
        return coldTaiga;
    }
    private static final int snowy_taiga_hills = (int)31L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.snowy_taiga_hills = 31
     * }
     */
    public static int snowy_taiga_hills() {
        return snowy_taiga_hills;
    }
    private static final int coldTaigaHills = (int)31L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.coldTaigaHills = 31
     * }
     */
    public static int coldTaigaHills() {
        return coldTaigaHills;
    }
    private static final int giant_tree_taiga = (int)32L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.giant_tree_taiga = 32
     * }
     */
    public static int giant_tree_taiga() {
        return giant_tree_taiga;
    }
    private static final int megaTaiga = (int)32L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.megaTaiga = 32
     * }
     */
    public static int megaTaiga() {
        return megaTaiga;
    }
    private static final int giant_tree_taiga_hills = (int)33L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.giant_tree_taiga_hills = 33
     * }
     */
    public static int giant_tree_taiga_hills() {
        return giant_tree_taiga_hills;
    }
    private static final int megaTaigaHills = (int)33L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.megaTaigaHills = 33
     * }
     */
    public static int megaTaigaHills() {
        return megaTaigaHills;
    }
    private static final int wooded_mountains = (int)34L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.wooded_mountains = 34
     * }
     */
    public static int wooded_mountains() {
        return wooded_mountains;
    }
    private static final int extremeHillsPlus = (int)34L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.extremeHillsPlus = 34
     * }
     */
    public static int extremeHillsPlus() {
        return extremeHillsPlus;
    }
    private static final int savanna = (int)35L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.savanna = 35
     * }
     */
    public static int savanna() {
        return savanna;
    }
    private static final int savanna_plateau = (int)36L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.savanna_plateau = 36
     * }
     */
    public static int savanna_plateau() {
        return savanna_plateau;
    }
    private static final int savannaPlateau = (int)36L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.savannaPlateau = 36
     * }
     */
    public static int savannaPlateau() {
        return savannaPlateau;
    }
    private static final int badlands = (int)37L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.badlands = 37
     * }
     */
    public static int badlands() {
        return badlands;
    }
    private static final int mesa = (int)37L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.mesa = 37
     * }
     */
    public static int mesa() {
        return mesa;
    }
    private static final int wooded_badlands_plateau = (int)38L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.wooded_badlands_plateau = 38
     * }
     */
    public static int wooded_badlands_plateau() {
        return wooded_badlands_plateau;
    }
    private static final int mesaPlateau_F = (int)38L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.mesaPlateau_F = 38
     * }
     */
    public static int mesaPlateau_F() {
        return mesaPlateau_F;
    }
    private static final int badlands_plateau = (int)39L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.badlands_plateau = 39
     * }
     */
    public static int badlands_plateau() {
        return badlands_plateau;
    }
    private static final int mesaPlateau = (int)39L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.mesaPlateau = 39
     * }
     */
    public static int mesaPlateau() {
        return mesaPlateau;
    }
    private static final int small_end_islands = (int)40L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.small_end_islands = 40
     * }
     */
    public static int small_end_islands() {
        return small_end_islands;
    }
    private static final int end_midlands = (int)41L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.end_midlands = 41
     * }
     */
    public static int end_midlands() {
        return end_midlands;
    }
    private static final int end_highlands = (int)42L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.end_highlands = 42
     * }
     */
    public static int end_highlands() {
        return end_highlands;
    }
    private static final int end_barrens = (int)43L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.end_barrens = 43
     * }
     */
    public static int end_barrens() {
        return end_barrens;
    }
    private static final int warm_ocean = (int)44L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.warm_ocean = 44
     * }
     */
    public static int warm_ocean() {
        return warm_ocean;
    }
    private static final int warmOcean = (int)44L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.warmOcean = 44
     * }
     */
    public static int warmOcean() {
        return warmOcean;
    }
    private static final int lukewarm_ocean = (int)45L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.lukewarm_ocean = 45
     * }
     */
    public static int lukewarm_ocean() {
        return lukewarm_ocean;
    }
    private static final int lukewarmOcean = (int)45L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.lukewarmOcean = 45
     * }
     */
    public static int lukewarmOcean() {
        return lukewarmOcean;
    }
    private static final int cold_ocean = (int)46L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.cold_ocean = 46
     * }
     */
    public static int cold_ocean() {
        return cold_ocean;
    }
    private static final int coldOcean = (int)46L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.coldOcean = 46
     * }
     */
    public static int coldOcean() {
        return coldOcean;
    }
    private static final int deep_warm_ocean = (int)47L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.deep_warm_ocean = 47
     * }
     */
    public static int deep_warm_ocean() {
        return deep_warm_ocean;
    }
    private static final int warmDeepOcean = (int)47L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.warmDeepOcean = 47
     * }
     */
    public static int warmDeepOcean() {
        return warmDeepOcean;
    }
    private static final int deep_lukewarm_ocean = (int)48L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.deep_lukewarm_ocean = 48
     * }
     */
    public static int deep_lukewarm_ocean() {
        return deep_lukewarm_ocean;
    }
    private static final int lukewarmDeepOcean = (int)48L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.lukewarmDeepOcean = 48
     * }
     */
    public static int lukewarmDeepOcean() {
        return lukewarmDeepOcean;
    }
    private static final int deep_cold_ocean = (int)49L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.deep_cold_ocean = 49
     * }
     */
    public static int deep_cold_ocean() {
        return deep_cold_ocean;
    }
    private static final int coldDeepOcean = (int)49L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.coldDeepOcean = 49
     * }
     */
    public static int coldDeepOcean() {
        return coldDeepOcean;
    }
    private static final int deep_frozen_ocean = (int)50L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.deep_frozen_ocean = 50
     * }
     */
    public static int deep_frozen_ocean() {
        return deep_frozen_ocean;
    }
    private static final int frozenDeepOcean = (int)50L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.frozenDeepOcean = 50
     * }
     */
    public static int frozenDeepOcean() {
        return frozenDeepOcean;
    }
    private static final int seasonal_forest = (int)51L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.seasonal_forest = 51
     * }
     */
    public static int seasonal_forest() {
        return seasonal_forest;
    }
    private static final int rainforest = (int)52L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.rainforest = 52
     * }
     */
    public static int rainforest() {
        return rainforest;
    }
    private static final int shrubland = (int)53L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.shrubland = 53
     * }
     */
    public static int shrubland() {
        return shrubland;
    }
    private static final int the_void = (int)127L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.the_void = 127
     * }
     */
    public static int the_void() {
        return the_void;
    }
    private static final int sunflower_plains = (int)129L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.sunflower_plains = 129
     * }
     */
    public static int sunflower_plains() {
        return sunflower_plains;
    }
    private static final int desert_lakes = (int)130L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.desert_lakes = 130
     * }
     */
    public static int desert_lakes() {
        return desert_lakes;
    }
    private static final int gravelly_mountains = (int)131L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.gravelly_mountains = 131
     * }
     */
    public static int gravelly_mountains() {
        return gravelly_mountains;
    }
    private static final int flower_forest = (int)132L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.flower_forest = 132
     * }
     */
    public static int flower_forest() {
        return flower_forest;
    }
    private static final int taiga_mountains = (int)133L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.taiga_mountains = 133
     * }
     */
    public static int taiga_mountains() {
        return taiga_mountains;
    }
    private static final int swamp_hills = (int)134L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.swamp_hills = 134
     * }
     */
    public static int swamp_hills() {
        return swamp_hills;
    }
    private static final int ice_spikes = (int)140L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.ice_spikes = 140
     * }
     */
    public static int ice_spikes() {
        return ice_spikes;
    }
    private static final int modified_jungle = (int)149L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.modified_jungle = 149
     * }
     */
    public static int modified_jungle() {
        return modified_jungle;
    }
    private static final int modified_jungle_edge = (int)151L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.modified_jungle_edge = 151
     * }
     */
    public static int modified_jungle_edge() {
        return modified_jungle_edge;
    }
    private static final int tall_birch_forest = (int)155L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.tall_birch_forest = 155
     * }
     */
    public static int tall_birch_forest() {
        return tall_birch_forest;
    }
    private static final int tall_birch_hills = (int)156L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.tall_birch_hills = 156
     * }
     */
    public static int tall_birch_hills() {
        return tall_birch_hills;
    }
    private static final int dark_forest_hills = (int)157L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.dark_forest_hills = 157
     * }
     */
    public static int dark_forest_hills() {
        return dark_forest_hills;
    }
    private static final int snowy_taiga_mountains = (int)158L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.snowy_taiga_mountains = 158
     * }
     */
    public static int snowy_taiga_mountains() {
        return snowy_taiga_mountains;
    }
    private static final int giant_spruce_taiga = (int)160L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.giant_spruce_taiga = 160
     * }
     */
    public static int giant_spruce_taiga() {
        return giant_spruce_taiga;
    }
    private static final int giant_spruce_taiga_hills = (int)161L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.giant_spruce_taiga_hills = 161
     * }
     */
    public static int giant_spruce_taiga_hills() {
        return giant_spruce_taiga_hills;
    }
    private static final int modified_gravelly_mountains = (int)162L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.modified_gravelly_mountains = 162
     * }
     */
    public static int modified_gravelly_mountains() {
        return modified_gravelly_mountains;
    }
    private static final int shattered_savanna = (int)163L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.shattered_savanna = 163
     * }
     */
    public static int shattered_savanna() {
        return shattered_savanna;
    }
    private static final int shattered_savanna_plateau = (int)164L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.shattered_savanna_plateau = 164
     * }
     */
    public static int shattered_savanna_plateau() {
        return shattered_savanna_plateau;
    }
    private static final int eroded_badlands = (int)165L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.eroded_badlands = 165
     * }
     */
    public static int eroded_badlands() {
        return eroded_badlands;
    }
    private static final int modified_wooded_badlands_plateau = (int)166L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.modified_wooded_badlands_plateau = 166
     * }
     */
    public static int modified_wooded_badlands_plateau() {
        return modified_wooded_badlands_plateau;
    }
    private static final int modified_badlands_plateau = (int)167L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.modified_badlands_plateau = 167
     * }
     */
    public static int modified_badlands_plateau() {
        return modified_badlands_plateau;
    }
    private static final int bamboo_jungle = (int)168L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.bamboo_jungle = 168
     * }
     */
    public static int bamboo_jungle() {
        return bamboo_jungle;
    }
    private static final int bamboo_jungle_hills = (int)169L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.bamboo_jungle_hills = 169
     * }
     */
    public static int bamboo_jungle_hills() {
        return bamboo_jungle_hills;
    }
    private static final int soul_sand_valley = (int)170L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.soul_sand_valley = 170
     * }
     */
    public static int soul_sand_valley() {
        return soul_sand_valley;
    }
    private static final int crimson_forest = (int)171L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.crimson_forest = 171
     * }
     */
    public static int crimson_forest() {
        return crimson_forest;
    }
    private static final int warped_forest = (int)172L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.warped_forest = 172
     * }
     */
    public static int warped_forest() {
        return warped_forest;
    }
    private static final int basalt_deltas = (int)173L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.basalt_deltas = 173
     * }
     */
    public static int basalt_deltas() {
        return basalt_deltas;
    }
    private static final int dripstone_caves = (int)174L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.dripstone_caves = 174
     * }
     */
    public static int dripstone_caves() {
        return dripstone_caves;
    }
    private static final int lush_caves = (int)175L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.lush_caves = 175
     * }
     */
    public static int lush_caves() {
        return lush_caves;
    }
    private static final int meadow = (int)177L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.meadow = 177
     * }
     */
    public static int meadow() {
        return meadow;
    }
    private static final int grove = (int)178L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.grove = 178
     * }
     */
    public static int grove() {
        return grove;
    }
    private static final int snowy_slopes = (int)179L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.snowy_slopes = 179
     * }
     */
    public static int snowy_slopes() {
        return snowy_slopes;
    }
    private static final int jagged_peaks = (int)180L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.jagged_peaks = 180
     * }
     */
    public static int jagged_peaks() {
        return jagged_peaks;
    }
    private static final int frozen_peaks = (int)181L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.frozen_peaks = 181
     * }
     */
    public static int frozen_peaks() {
        return frozen_peaks;
    }
    private static final int stony_peaks = (int)182L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.stony_peaks = 182
     * }
     */
    public static int stony_peaks() {
        return stony_peaks;
    }
    private static final int old_growth_birch_forest = (int)155L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.old_growth_birch_forest = 155
     * }
     */
    public static int old_growth_birch_forest() {
        return old_growth_birch_forest;
    }
    private static final int old_growth_pine_taiga = (int)32L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.old_growth_pine_taiga = 32
     * }
     */
    public static int old_growth_pine_taiga() {
        return old_growth_pine_taiga;
    }
    private static final int old_growth_spruce_taiga = (int)160L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.old_growth_spruce_taiga = 160
     * }
     */
    public static int old_growth_spruce_taiga() {
        return old_growth_spruce_taiga;
    }
    private static final int snowy_plains = (int)12L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.snowy_plains = 12
     * }
     */
    public static int snowy_plains() {
        return snowy_plains;
    }
    private static final int sparse_jungle = (int)23L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.sparse_jungle = 23
     * }
     */
    public static int sparse_jungle() {
        return sparse_jungle;
    }
    private static final int stony_shore = (int)25L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.stony_shore = 25
     * }
     */
    public static int stony_shore() {
        return stony_shore;
    }
    private static final int windswept_hills = (int)3L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.windswept_hills = 3
     * }
     */
    public static int windswept_hills() {
        return windswept_hills;
    }
    private static final int windswept_forest = (int)34L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.windswept_forest = 34
     * }
     */
    public static int windswept_forest() {
        return windswept_forest;
    }
    private static final int windswept_gravelly_hills = (int)131L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.windswept_gravelly_hills = 131
     * }
     */
    public static int windswept_gravelly_hills() {
        return windswept_gravelly_hills;
    }
    private static final int windswept_savanna = (int)163L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.windswept_savanna = 163
     * }
     */
    public static int windswept_savanna() {
        return windswept_savanna;
    }
    private static final int wooded_badlands = (int)38L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.wooded_badlands = 38
     * }
     */
    public static int wooded_badlands() {
        return wooded_badlands;
    }
    private static final int deep_dark = (int)183L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.deep_dark = 183
     * }
     */
    public static int deep_dark() {
        return deep_dark;
    }
    private static final int mangrove_swamp = (int)184L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.mangrove_swamp = 184
     * }
     */
    public static int mangrove_swamp() {
        return mangrove_swamp;
    }
    private static final int cherry_grove = (int)185L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.cherry_grove = 185
     * }
     */
    public static int cherry_grove() {
        return cherry_grove;
    }
    private static final int pale_garden = (int)186L;
    /**
     * {@snippet lang=c :
     * enum BiomeID.pale_garden = 186
     * }
     */
    public static int pale_garden() {
        return pale_garden;
    }

    private static class biomeExists {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("biomeExists");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int biomeExists(int mc, int id)
     * }
     */
    public static FunctionDescriptor biomeExists$descriptor() {
        return biomeExists.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int biomeExists(int mc, int id)
     * }
     */
    public static MethodHandle biomeExists$handle() {
        return biomeExists.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int biomeExists(int mc, int id)
     * }
     */
    public static MemorySegment biomeExists$address() {
        return biomeExists.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int biomeExists(int mc, int id)
     * }
     */
    public static int biomeExists(int mc, int id) {
        var mh$ = biomeExists.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("biomeExists", mc, id);
            }
            return (int)mh$.invokeExact(mc, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isOverworld {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("isOverworld");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isOverworld(int mc, int id)
     * }
     */
    public static FunctionDescriptor isOverworld$descriptor() {
        return isOverworld.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isOverworld(int mc, int id)
     * }
     */
    public static MethodHandle isOverworld$handle() {
        return isOverworld.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isOverworld(int mc, int id)
     * }
     */
    public static MemorySegment isOverworld$address() {
        return isOverworld.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isOverworld(int mc, int id)
     * }
     */
    public static int isOverworld(int mc, int id) {
        var mh$ = isOverworld.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isOverworld", mc, id);
            }
            return (int)mh$.invokeExact(mc, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getDimension {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("getDimension");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getDimension(int id)
     * }
     */
    public static FunctionDescriptor getDimension$descriptor() {
        return getDimension.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getDimension(int id)
     * }
     */
    public static MethodHandle getDimension$handle() {
        return getDimension.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getDimension(int id)
     * }
     */
    public static MemorySegment getDimension$address() {
        return getDimension.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getDimension(int id)
     * }
     */
    public static int getDimension(int id) {
        var mh$ = getDimension.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getDimension", id);
            }
            return (int)mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getMutated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("getMutated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getMutated(int mc, int id)
     * }
     */
    public static FunctionDescriptor getMutated$descriptor() {
        return getMutated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getMutated(int mc, int id)
     * }
     */
    public static MethodHandle getMutated$handle() {
        return getMutated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getMutated(int mc, int id)
     * }
     */
    public static MemorySegment getMutated$address() {
        return getMutated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getMutated(int mc, int id)
     * }
     */
    public static int getMutated(int mc, int id) {
        var mh$ = getMutated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getMutated", mc, id);
            }
            return (int)mh$.invokeExact(mc, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getCategory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("getCategory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getCategory(int mc, int id)
     * }
     */
    public static FunctionDescriptor getCategory$descriptor() {
        return getCategory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getCategory(int mc, int id)
     * }
     */
    public static MethodHandle getCategory$handle() {
        return getCategory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getCategory(int mc, int id)
     * }
     */
    public static MemorySegment getCategory$address() {
        return getCategory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getCategory(int mc, int id)
     * }
     */
    public static int getCategory(int mc, int id) {
        var mh$ = getCategory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getCategory", mc, id);
            }
            return (int)mh$.invokeExact(mc, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class areSimilar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("areSimilar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int areSimilar(int mc, int id1, int id2)
     * }
     */
    public static FunctionDescriptor areSimilar$descriptor() {
        return areSimilar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int areSimilar(int mc, int id1, int id2)
     * }
     */
    public static MethodHandle areSimilar$handle() {
        return areSimilar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int areSimilar(int mc, int id1, int id2)
     * }
     */
    public static MemorySegment areSimilar$address() {
        return areSimilar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int areSimilar(int mc, int id1, int id2)
     * }
     */
    public static int areSimilar(int mc, int id1, int id2) {
        var mh$ = areSimilar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("areSimilar", mc, id1, id2);
            }
            return (int)mh$.invokeExact(mc, id1, id2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isMesa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("isMesa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isMesa(int id)
     * }
     */
    public static FunctionDescriptor isMesa$descriptor() {
        return isMesa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isMesa(int id)
     * }
     */
    public static MethodHandle isMesa$handle() {
        return isMesa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isMesa(int id)
     * }
     */
    public static MemorySegment isMesa$address() {
        return isMesa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isMesa(int id)
     * }
     */
    public static int isMesa(int id) {
        var mh$ = isMesa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isMesa", id);
            }
            return (int)mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isShallowOcean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("isShallowOcean");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isShallowOcean(int id)
     * }
     */
    public static FunctionDescriptor isShallowOcean$descriptor() {
        return isShallowOcean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isShallowOcean(int id)
     * }
     */
    public static MethodHandle isShallowOcean$handle() {
        return isShallowOcean.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isShallowOcean(int id)
     * }
     */
    public static MemorySegment isShallowOcean$address() {
        return isShallowOcean.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isShallowOcean(int id)
     * }
     */
    public static int isShallowOcean(int id) {
        var mh$ = isShallowOcean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isShallowOcean", id);
            }
            return (int)mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isDeepOcean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("isDeepOcean");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isDeepOcean(int id)
     * }
     */
    public static FunctionDescriptor isDeepOcean$descriptor() {
        return isDeepOcean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isDeepOcean(int id)
     * }
     */
    public static MethodHandle isDeepOcean$handle() {
        return isDeepOcean.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isDeepOcean(int id)
     * }
     */
    public static MemorySegment isDeepOcean$address() {
        return isDeepOcean.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isDeepOcean(int id)
     * }
     */
    public static int isDeepOcean(int id) {
        var mh$ = isDeepOcean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isDeepOcean", id);
            }
            return (int)mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isOceanic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("isOceanic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isOceanic(int id)
     * }
     */
    public static FunctionDescriptor isOceanic$descriptor() {
        return isOceanic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isOceanic(int id)
     * }
     */
    public static MethodHandle isOceanic$handle() {
        return isOceanic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isOceanic(int id)
     * }
     */
    public static MemorySegment isOceanic$address() {
        return isOceanic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isOceanic(int id)
     * }
     */
    public static int isOceanic(int id) {
        var mh$ = isOceanic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isOceanic", id);
            }
            return (int)mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isSnowy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("isSnowy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isSnowy(int id)
     * }
     */
    public static FunctionDescriptor isSnowy$descriptor() {
        return isSnowy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isSnowy(int id)
     * }
     */
    public static MethodHandle isSnowy$handle() {
        return isSnowy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isSnowy(int id)
     * }
     */
    public static MemorySegment isSnowy$address() {
        return isSnowy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isSnowy(int id)
     * }
     */
    public static int isSnowy(int id) {
        var mh$ = isSnowy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isSnowy", id);
            }
            return (int)mh$.invokeExact(id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int Oceanic = (int)0L;
    /**
     * {@snippet lang=c :
     * enum BiomeTempCategory.Oceanic = 0
     * }
     */
    public static int Oceanic() {
        return Oceanic;
    }
    private static final int Warm = (int)1L;
    /**
     * {@snippet lang=c :
     * enum BiomeTempCategory.Warm = 1
     * }
     */
    public static int Warm() {
        return Warm;
    }
    private static final int Lush = (int)2L;
    /**
     * {@snippet lang=c :
     * enum BiomeTempCategory.Lush = 2
     * }
     */
    public static int Lush() {
        return Lush;
    }
    private static final int Cold = (int)3L;
    /**
     * {@snippet lang=c :
     * enum BiomeTempCategory.Cold = 3
     * }
     */
    public static int Cold() {
        return Cold;
    }
    private static final int Freezing = (int)4L;
    /**
     * {@snippet lang=c :
     * enum BiomeTempCategory.Freezing = 4
     * }
     */
    public static int Freezing() {
        return Freezing;
    }
    private static final int Special = (int)5L;
    /**
     * {@snippet lang=c :
     * enum BiomeTempCategory.Special = 5
     * }
     */
    public static int Special() {
        return Special;
    }
    private static final int L_CONTINENT_4096 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_CONTINENT_4096 = 0
     * }
     */
    public static int L_CONTINENT_4096() {
        return L_CONTINENT_4096;
    }
    private static final int L_ISLAND_4096 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ISLAND_4096 = 0
     * }
     */
    public static int L_ISLAND_4096() {
        return L_ISLAND_4096;
    }
    private static final int L_ZOOM_4096 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_4096 = 1
     * }
     */
    public static int L_ZOOM_4096() {
        return L_ZOOM_4096;
    }
    private static final int L_LAND_4096 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_LAND_4096 = 2
     * }
     */
    public static int L_LAND_4096() {
        return L_LAND_4096;
    }
    private static final int L_ZOOM_2048 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_2048 = 3
     * }
     */
    public static int L_ZOOM_2048() {
        return L_ZOOM_2048;
    }
    private static final int L_LAND_2048 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_LAND_2048 = 4
     * }
     */
    public static int L_LAND_2048() {
        return L_LAND_2048;
    }
    private static final int L_ADD_ISLAND_2048 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ADD_ISLAND_2048 = 4
     * }
     */
    public static int L_ADD_ISLAND_2048() {
        return L_ADD_ISLAND_2048;
    }
    private static final int L_ZOOM_1024 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_1024 = 5
     * }
     */
    public static int L_ZOOM_1024() {
        return L_ZOOM_1024;
    }
    private static final int L_LAND_1024_A = (int)6L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_LAND_1024_A = 6
     * }
     */
    public static int L_LAND_1024_A() {
        return L_LAND_1024_A;
    }
    private static final int L_ADD_ISLAND_1024A = (int)6L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ADD_ISLAND_1024A = 6
     * }
     */
    public static int L_ADD_ISLAND_1024A() {
        return L_ADD_ISLAND_1024A;
    }
    private static final int L_LAND_1024_B = (int)7L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_LAND_1024_B = 7
     * }
     */
    public static int L_LAND_1024_B() {
        return L_LAND_1024_B;
    }
    private static final int L_ADD_ISLAND_1024B = (int)7L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ADD_ISLAND_1024B = 7
     * }
     */
    public static int L_ADD_ISLAND_1024B() {
        return L_ADD_ISLAND_1024B;
    }
    private static final int L_LAND_1024_C = (int)8L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_LAND_1024_C = 8
     * }
     */
    public static int L_LAND_1024_C() {
        return L_LAND_1024_C;
    }
    private static final int L_ADD_ISLAND_1024C = (int)8L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ADD_ISLAND_1024C = 8
     * }
     */
    public static int L_ADD_ISLAND_1024C() {
        return L_ADD_ISLAND_1024C;
    }
    private static final int L_ISLAND_1024 = (int)9L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ISLAND_1024 = 9
     * }
     */
    public static int L_ISLAND_1024() {
        return L_ISLAND_1024;
    }
    private static final int L_REMOVE_OCEAN_1024 = (int)9L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_REMOVE_OCEAN_1024 = 9
     * }
     */
    public static int L_REMOVE_OCEAN_1024() {
        return L_REMOVE_OCEAN_1024;
    }
    private static final int L_SNOW_1024 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_SNOW_1024 = 10
     * }
     */
    public static int L_SNOW_1024() {
        return L_SNOW_1024;
    }
    private static final int L_ADD_SNOW_1024 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ADD_SNOW_1024 = 10
     * }
     */
    public static int L_ADD_SNOW_1024() {
        return L_ADD_SNOW_1024;
    }
    private static final int L_LAND_1024_D = (int)11L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_LAND_1024_D = 11
     * }
     */
    public static int L_LAND_1024_D() {
        return L_LAND_1024_D;
    }
    private static final int L_ADD_ISLAND_1024D = (int)11L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ADD_ISLAND_1024D = 11
     * }
     */
    public static int L_ADD_ISLAND_1024D() {
        return L_ADD_ISLAND_1024D;
    }
    private static final int L_COOL_1024 = (int)12L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_COOL_1024 = 12
     * }
     */
    public static int L_COOL_1024() {
        return L_COOL_1024;
    }
    private static final int L_COOL_WARM_1024 = (int)12L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_COOL_WARM_1024 = 12
     * }
     */
    public static int L_COOL_WARM_1024() {
        return L_COOL_WARM_1024;
    }
    private static final int L_HEAT_1024 = (int)13L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_HEAT_1024 = 13
     * }
     */
    public static int L_HEAT_1024() {
        return L_HEAT_1024;
    }
    private static final int L_HEAT_ICE_1024 = (int)13L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_HEAT_ICE_1024 = 13
     * }
     */
    public static int L_HEAT_ICE_1024() {
        return L_HEAT_ICE_1024;
    }
    private static final int L_SPECIAL_1024 = (int)14L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_SPECIAL_1024 = 14
     * }
     */
    public static int L_SPECIAL_1024() {
        return L_SPECIAL_1024;
    }
    private static final int L_ZOOM_512 = (int)15L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_512 = 15
     * }
     */
    public static int L_ZOOM_512() {
        return L_ZOOM_512;
    }
    private static final int L_LAND_512 = (int)16L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_LAND_512 = 16
     * }
     */
    public static int L_LAND_512() {
        return L_LAND_512;
    }
    private static final int L_ZOOM_256 = (int)17L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_256 = 17
     * }
     */
    public static int L_ZOOM_256() {
        return L_ZOOM_256;
    }
    private static final int L_LAND_256 = (int)18L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_LAND_256 = 18
     * }
     */
    public static int L_LAND_256() {
        return L_LAND_256;
    }
    private static final int L_ADD_ISLAND_256 = (int)18L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ADD_ISLAND_256 = 18
     * }
     */
    public static int L_ADD_ISLAND_256() {
        return L_ADD_ISLAND_256;
    }
    private static final int L_MUSHROOM_256 = (int)19L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_MUSHROOM_256 = 19
     * }
     */
    public static int L_MUSHROOM_256() {
        return L_MUSHROOM_256;
    }
    private static final int L_ADD_MUSHROOM_256 = (int)19L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ADD_MUSHROOM_256 = 19
     * }
     */
    public static int L_ADD_MUSHROOM_256() {
        return L_ADD_MUSHROOM_256;
    }
    private static final int L_DEEP_OCEAN_256 = (int)20L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_DEEP_OCEAN_256 = 20
     * }
     */
    public static int L_DEEP_OCEAN_256() {
        return L_DEEP_OCEAN_256;
    }
    private static final int L_BIOME_256 = (int)21L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_BIOME_256 = 21
     * }
     */
    public static int L_BIOME_256() {
        return L_BIOME_256;
    }
    private static final int L_BAMBOO_256 = (int)22L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_BAMBOO_256 = 22
     * }
     */
    public static int L_BAMBOO_256() {
        return L_BAMBOO_256;
    }
    private static final int L14_BAMBOO_256 = (int)22L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L14_BAMBOO_256 = 22
     * }
     */
    public static int L14_BAMBOO_256() {
        return L14_BAMBOO_256;
    }
    private static final int L_ZOOM_128 = (int)23L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_128 = 23
     * }
     */
    public static int L_ZOOM_128() {
        return L_ZOOM_128;
    }
    private static final int L_ZOOM_64 = (int)24L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_64 = 24
     * }
     */
    public static int L_ZOOM_64() {
        return L_ZOOM_64;
    }
    private static final int L_BIOME_EDGE_64 = (int)25L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_BIOME_EDGE_64 = 25
     * }
     */
    public static int L_BIOME_EDGE_64() {
        return L_BIOME_EDGE_64;
    }
    private static final int L_NOISE_256 = (int)26L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_NOISE_256 = 26
     * }
     */
    public static int L_NOISE_256() {
        return L_NOISE_256;
    }
    private static final int L_RIVER_INIT_256 = (int)26L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_RIVER_INIT_256 = 26
     * }
     */
    public static int L_RIVER_INIT_256() {
        return L_RIVER_INIT_256;
    }
    private static final int L_ZOOM_128_HILLS = (int)27L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_128_HILLS = 27
     * }
     */
    public static int L_ZOOM_128_HILLS() {
        return L_ZOOM_128_HILLS;
    }
    private static final int L_ZOOM_64_HILLS = (int)28L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_64_HILLS = 28
     * }
     */
    public static int L_ZOOM_64_HILLS() {
        return L_ZOOM_64_HILLS;
    }
    private static final int L_HILLS_64 = (int)29L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_HILLS_64 = 29
     * }
     */
    public static int L_HILLS_64() {
        return L_HILLS_64;
    }
    private static final int L_SUNFLOWER_64 = (int)30L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_SUNFLOWER_64 = 30
     * }
     */
    public static int L_SUNFLOWER_64() {
        return L_SUNFLOWER_64;
    }
    private static final int L_RARE_BIOME_64 = (int)30L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_RARE_BIOME_64 = 30
     * }
     */
    public static int L_RARE_BIOME_64() {
        return L_RARE_BIOME_64;
    }
    private static final int L_ZOOM_32 = (int)31L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_32 = 31
     * }
     */
    public static int L_ZOOM_32() {
        return L_ZOOM_32;
    }
    private static final int L_LAND_32 = (int)32L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_LAND_32 = 32
     * }
     */
    public static int L_LAND_32() {
        return L_LAND_32;
    }
    private static final int L_ADD_ISLAND_32 = (int)32L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ADD_ISLAND_32 = 32
     * }
     */
    public static int L_ADD_ISLAND_32() {
        return L_ADD_ISLAND_32;
    }
    private static final int L_ZOOM_16 = (int)33L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_16 = 33
     * }
     */
    public static int L_ZOOM_16() {
        return L_ZOOM_16;
    }
    private static final int L_SHORE_16 = (int)34L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_SHORE_16 = 34
     * }
     */
    public static int L_SHORE_16() {
        return L_SHORE_16;
    }
    private static final int L_SWAMP_RIVER_16 = (int)35L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_SWAMP_RIVER_16 = 35
     * }
     */
    public static int L_SWAMP_RIVER_16() {
        return L_SWAMP_RIVER_16;
    }
    private static final int L_ZOOM_8 = (int)36L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_8 = 36
     * }
     */
    public static int L_ZOOM_8() {
        return L_ZOOM_8;
    }
    private static final int L_ZOOM_4 = (int)37L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_4 = 37
     * }
     */
    public static int L_ZOOM_4() {
        return L_ZOOM_4;
    }
    private static final int L_SMOOTH_4 = (int)38L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_SMOOTH_4 = 38
     * }
     */
    public static int L_SMOOTH_4() {
        return L_SMOOTH_4;
    }
    private static final int L_ZOOM_128_RIVER = (int)39L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_128_RIVER = 39
     * }
     */
    public static int L_ZOOM_128_RIVER() {
        return L_ZOOM_128_RIVER;
    }
    private static final int L_ZOOM_64_RIVER = (int)40L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_64_RIVER = 40
     * }
     */
    public static int L_ZOOM_64_RIVER() {
        return L_ZOOM_64_RIVER;
    }
    private static final int L_ZOOM_32_RIVER = (int)41L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_32_RIVER = 41
     * }
     */
    public static int L_ZOOM_32_RIVER() {
        return L_ZOOM_32_RIVER;
    }
    private static final int L_ZOOM_16_RIVER = (int)42L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_16_RIVER = 42
     * }
     */
    public static int L_ZOOM_16_RIVER() {
        return L_ZOOM_16_RIVER;
    }
    private static final int L_ZOOM_8_RIVER = (int)43L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_8_RIVER = 43
     * }
     */
    public static int L_ZOOM_8_RIVER() {
        return L_ZOOM_8_RIVER;
    }
    private static final int L_ZOOM_4_RIVER = (int)44L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_4_RIVER = 44
     * }
     */
    public static int L_ZOOM_4_RIVER() {
        return L_ZOOM_4_RIVER;
    }
    private static final int L_RIVER_4 = (int)45L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_RIVER_4 = 45
     * }
     */
    public static int L_RIVER_4() {
        return L_RIVER_4;
    }
    private static final int L_SMOOTH_4_RIVER = (int)46L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_SMOOTH_4_RIVER = 46
     * }
     */
    public static int L_SMOOTH_4_RIVER() {
        return L_SMOOTH_4_RIVER;
    }
    private static final int L_RIVER_MIX_4 = (int)47L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_RIVER_MIX_4 = 47
     * }
     */
    public static int L_RIVER_MIX_4() {
        return L_RIVER_MIX_4;
    }
    private static final int L_OCEAN_TEMP_256 = (int)48L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_OCEAN_TEMP_256 = 48
     * }
     */
    public static int L_OCEAN_TEMP_256() {
        return L_OCEAN_TEMP_256;
    }
    private static final int L13_OCEAN_TEMP_256 = (int)48L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L13_OCEAN_TEMP_256 = 48
     * }
     */
    public static int L13_OCEAN_TEMP_256() {
        return L13_OCEAN_TEMP_256;
    }
    private static final int L_ZOOM_128_OCEAN = (int)49L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_128_OCEAN = 49
     * }
     */
    public static int L_ZOOM_128_OCEAN() {
        return L_ZOOM_128_OCEAN;
    }
    private static final int L13_ZOOM_128 = (int)49L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L13_ZOOM_128 = 49
     * }
     */
    public static int L13_ZOOM_128() {
        return L13_ZOOM_128;
    }
    private static final int L_ZOOM_64_OCEAN = (int)50L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_64_OCEAN = 50
     * }
     */
    public static int L_ZOOM_64_OCEAN() {
        return L_ZOOM_64_OCEAN;
    }
    private static final int L13_ZOOM_64 = (int)50L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L13_ZOOM_64 = 50
     * }
     */
    public static int L13_ZOOM_64() {
        return L13_ZOOM_64;
    }
    private static final int L_ZOOM_32_OCEAN = (int)51L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_32_OCEAN = 51
     * }
     */
    public static int L_ZOOM_32_OCEAN() {
        return L_ZOOM_32_OCEAN;
    }
    private static final int L13_ZOOM_32 = (int)51L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L13_ZOOM_32 = 51
     * }
     */
    public static int L13_ZOOM_32() {
        return L13_ZOOM_32;
    }
    private static final int L_ZOOM_16_OCEAN = (int)52L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_16_OCEAN = 52
     * }
     */
    public static int L_ZOOM_16_OCEAN() {
        return L_ZOOM_16_OCEAN;
    }
    private static final int L13_ZOOM_16 = (int)52L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L13_ZOOM_16 = 52
     * }
     */
    public static int L13_ZOOM_16() {
        return L13_ZOOM_16;
    }
    private static final int L_ZOOM_8_OCEAN = (int)53L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_8_OCEAN = 53
     * }
     */
    public static int L_ZOOM_8_OCEAN() {
        return L_ZOOM_8_OCEAN;
    }
    private static final int L13_ZOOM_8 = (int)53L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L13_ZOOM_8 = 53
     * }
     */
    public static int L13_ZOOM_8() {
        return L13_ZOOM_8;
    }
    private static final int L_ZOOM_4_OCEAN = (int)54L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_4_OCEAN = 54
     * }
     */
    public static int L_ZOOM_4_OCEAN() {
        return L_ZOOM_4_OCEAN;
    }
    private static final int L13_ZOOM_4 = (int)54L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L13_ZOOM_4 = 54
     * }
     */
    public static int L13_ZOOM_4() {
        return L13_ZOOM_4;
    }
    private static final int L_OCEAN_MIX_4 = (int)55L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_OCEAN_MIX_4 = 55
     * }
     */
    public static int L_OCEAN_MIX_4() {
        return L_OCEAN_MIX_4;
    }
    private static final int L13_OCEAN_MIX_4 = (int)55L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L13_OCEAN_MIX_4 = 55
     * }
     */
    public static int L13_OCEAN_MIX_4() {
        return L13_OCEAN_MIX_4;
    }
    private static final int L_VORONOI_1 = (int)56L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_VORONOI_1 = 56
     * }
     */
    public static int L_VORONOI_1() {
        return L_VORONOI_1;
    }
    private static final int L_VORONOI_ZOOM_1 = (int)56L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_VORONOI_ZOOM_1 = 56
     * }
     */
    public static int L_VORONOI_ZOOM_1() {
        return L_VORONOI_ZOOM_1;
    }
    private static final int L_ZOOM_LARGE_A = (int)57L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_LARGE_A = 57
     * }
     */
    public static int L_ZOOM_LARGE_A() {
        return L_ZOOM_LARGE_A;
    }
    private static final int L_ZOOM_LARGE_B = (int)58L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_LARGE_B = 58
     * }
     */
    public static int L_ZOOM_LARGE_B() {
        return L_ZOOM_LARGE_B;
    }
    private static final int L_ZOOM_L_RIVER_A = (int)59L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_L_RIVER_A = 59
     * }
     */
    public static int L_ZOOM_L_RIVER_A() {
        return L_ZOOM_L_RIVER_A;
    }
    private static final int L_ZOOM_L_RIVER_B = (int)60L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_ZOOM_L_RIVER_B = 60
     * }
     */
    public static int L_ZOOM_L_RIVER_B() {
        return L_ZOOM_L_RIVER_B;
    }
    private static final int L_NUM = (int)61L;
    /**
     * {@snippet lang=c :
     * enum LayerId.L_NUM = 61
     * }
     */
    public static int L_NUM() {
        return L_NUM;
    }

    private static class setLayerSeed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Cubiomes.C_POINTER,
            Cubiomes.C_LONG_LONG
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("setLayerSeed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setLayerSeed(Layer *layer, uint64_t worldSeed)
     * }
     */
    public static FunctionDescriptor setLayerSeed$descriptor() {
        return setLayerSeed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setLayerSeed(Layer *layer, uint64_t worldSeed)
     * }
     */
    public static MethodHandle setLayerSeed$handle() {
        return setLayerSeed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setLayerSeed(Layer *layer, uint64_t worldSeed)
     * }
     */
    public static MemorySegment setLayerSeed$address() {
        return setLayerSeed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setLayerSeed(Layer *layer, uint64_t worldSeed)
     * }
     */
    public static void setLayerSeed(MemorySegment layer, long worldSeed) {
        var mh$ = setLayerSeed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setLayerSeed", layer, worldSeed);
            }
            mh$.invokeExact(layer, worldSeed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapContinent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("mapContinent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapContinent(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapContinent$descriptor() {
        return mapContinent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapContinent(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapContinent$handle() {
        return mapContinent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapContinent(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapContinent$address() {
        return mapContinent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapContinent(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapContinent(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapContinent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapContinent", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapZoomFuzzy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("mapZoomFuzzy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapZoomFuzzy(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapZoomFuzzy$descriptor() {
        return mapZoomFuzzy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapZoomFuzzy(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapZoomFuzzy$handle() {
        return mapZoomFuzzy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapZoomFuzzy(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapZoomFuzzy$address() {
        return mapZoomFuzzy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapZoomFuzzy(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapZoomFuzzy(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapZoomFuzzy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapZoomFuzzy", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapZoom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("mapZoom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapZoom(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapZoom$descriptor() {
        return mapZoom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapZoom(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapZoom$handle() {
        return mapZoom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapZoom(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapZoom$address() {
        return mapZoom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapZoom(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapZoom(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapZoom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapZoom", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapLand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("mapLand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapLand(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapLand$descriptor() {
        return mapLand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapLand(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapLand$handle() {
        return mapLand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapLand(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapLand$address() {
        return mapLand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapLand(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapLand(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapLand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapLand", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapLand16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("mapLand16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapLand16(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapLand16$descriptor() {
        return mapLand16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapLand16(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapLand16$handle() {
        return mapLand16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapLand16(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapLand16$address() {
        return mapLand16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapLand16(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapLand16(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapLand16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapLand16", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapLandB18 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("mapLandB18");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapLandB18(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapLandB18$descriptor() {
        return mapLandB18.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapLandB18(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapLandB18$handle() {
        return mapLandB18.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapLandB18(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapLandB18$address() {
        return mapLandB18.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapLandB18(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapLandB18(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapLandB18.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapLandB18", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapIsland {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("mapIsland");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapIsland(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapIsland$descriptor() {
        return mapIsland.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapIsland(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapIsland$handle() {
        return mapIsland.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapIsland(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapIsland$address() {
        return mapIsland.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapIsland(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapIsland(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapIsland.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapIsland", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapSnow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("mapSnow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapSnow(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapSnow$descriptor() {
        return mapSnow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapSnow(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapSnow$handle() {
        return mapSnow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapSnow(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapSnow$address() {
        return mapSnow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapSnow(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapSnow(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapSnow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapSnow", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapSnow16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("mapSnow16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapSnow16(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapSnow16$descriptor() {
        return mapSnow16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapSnow16(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapSnow16$handle() {
        return mapSnow16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapSnow16(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapSnow16$address() {
        return mapSnow16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapSnow16(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapSnow16(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapSnow16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapSnow16", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapCool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("mapCool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapCool(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapCool$descriptor() {
        return mapCool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapCool(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapCool$handle() {
        return mapCool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapCool(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapCool$address() {
        return mapCool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapCool(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapCool(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapCool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapCool", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapHeat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("mapHeat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapHeat(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapHeat$descriptor() {
        return mapHeat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapHeat(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapHeat$handle() {
        return mapHeat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapHeat(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapHeat$address() {
        return mapHeat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapHeat(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapHeat(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapHeat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapHeat", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapSpecial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("mapSpecial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapSpecial(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapSpecial$descriptor() {
        return mapSpecial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapSpecial(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapSpecial$handle() {
        return mapSpecial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapSpecial(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapSpecial$address() {
        return mapSpecial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapSpecial(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapSpecial(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapSpecial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapSpecial", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapMushroom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("mapMushroom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapMushroom(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapMushroom$descriptor() {
        return mapMushroom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapMushroom(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapMushroom$handle() {
        return mapMushroom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapMushroom(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapMushroom$address() {
        return mapMushroom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapMushroom(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapMushroom(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapMushroom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapMushroom", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapDeepOcean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("mapDeepOcean");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapDeepOcean(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapDeepOcean$descriptor() {
        return mapDeepOcean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapDeepOcean(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapDeepOcean$handle() {
        return mapDeepOcean.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapDeepOcean(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapDeepOcean$address() {
        return mapDeepOcean.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapDeepOcean(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapDeepOcean(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapDeepOcean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapDeepOcean", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapBiome {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("mapBiome");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapBiome(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapBiome$descriptor() {
        return mapBiome.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapBiome(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapBiome$handle() {
        return mapBiome.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapBiome(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapBiome$address() {
        return mapBiome.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapBiome(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapBiome(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapBiome.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapBiome", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapBamboo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("mapBamboo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapBamboo(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapBamboo$descriptor() {
        return mapBamboo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapBamboo(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapBamboo$handle() {
        return mapBamboo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapBamboo(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapBamboo$address() {
        return mapBamboo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapBamboo(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapBamboo(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapBamboo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapBamboo", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapNoise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("mapNoise");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapNoise(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapNoise$descriptor() {
        return mapNoise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapNoise(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapNoise$handle() {
        return mapNoise.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapNoise(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapNoise$address() {
        return mapNoise.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapNoise(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapNoise(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapNoise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapNoise", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapBiomeEdge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("mapBiomeEdge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapBiomeEdge(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapBiomeEdge$descriptor() {
        return mapBiomeEdge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapBiomeEdge(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapBiomeEdge$handle() {
        return mapBiomeEdge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapBiomeEdge(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapBiomeEdge$address() {
        return mapBiomeEdge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapBiomeEdge(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapBiomeEdge(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapBiomeEdge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapBiomeEdge", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapHills {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("mapHills");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapHills(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapHills$descriptor() {
        return mapHills.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapHills(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapHills$handle() {
        return mapHills.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapHills(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapHills$address() {
        return mapHills.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapHills(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapHills(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapHills.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapHills", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapRiver {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("mapRiver");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapRiver(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapRiver$descriptor() {
        return mapRiver.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapRiver(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapRiver$handle() {
        return mapRiver.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapRiver(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapRiver$address() {
        return mapRiver.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapRiver(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapRiver(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapRiver.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapRiver", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapSmooth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("mapSmooth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapSmooth(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapSmooth$descriptor() {
        return mapSmooth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapSmooth(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapSmooth$handle() {
        return mapSmooth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapSmooth(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapSmooth$address() {
        return mapSmooth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapSmooth(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapSmooth(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapSmooth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapSmooth", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapSunflower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("mapSunflower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapSunflower(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapSunflower$descriptor() {
        return mapSunflower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapSunflower(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapSunflower$handle() {
        return mapSunflower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapSunflower(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapSunflower$address() {
        return mapSunflower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapSunflower(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapSunflower(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapSunflower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapSunflower", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapShore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("mapShore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapShore(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapShore$descriptor() {
        return mapShore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapShore(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapShore$handle() {
        return mapShore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapShore(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapShore$address() {
        return mapShore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapShore(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapShore(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapShore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapShore", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapSwampRiver {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("mapSwampRiver");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapSwampRiver(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapSwampRiver$descriptor() {
        return mapSwampRiver.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapSwampRiver(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapSwampRiver$handle() {
        return mapSwampRiver.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapSwampRiver(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapSwampRiver$address() {
        return mapSwampRiver.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapSwampRiver(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapSwampRiver(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapSwampRiver.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapSwampRiver", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapRiverMix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("mapRiverMix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapRiverMix(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapRiverMix$descriptor() {
        return mapRiverMix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapRiverMix(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapRiverMix$handle() {
        return mapRiverMix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapRiverMix(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapRiverMix$address() {
        return mapRiverMix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapRiverMix(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapRiverMix(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapRiverMix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapRiverMix", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapOceanTemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("mapOceanTemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapOceanTemp(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapOceanTemp$descriptor() {
        return mapOceanTemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapOceanTemp(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapOceanTemp$handle() {
        return mapOceanTemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapOceanTemp(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapOceanTemp$address() {
        return mapOceanTemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapOceanTemp(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapOceanTemp(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapOceanTemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapOceanTemp", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapOceanMix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("mapOceanMix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapOceanMix(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapOceanMix$descriptor() {
        return mapOceanMix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapOceanMix(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapOceanMix$handle() {
        return mapOceanMix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapOceanMix(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapOceanMix$address() {
        return mapOceanMix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapOceanMix(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapOceanMix(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapOceanMix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapOceanMix", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapVoronoi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("mapVoronoi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapVoronoi(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapVoronoi$descriptor() {
        return mapVoronoi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapVoronoi(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapVoronoi$handle() {
        return mapVoronoi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapVoronoi(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapVoronoi$address() {
        return mapVoronoi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapVoronoi(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapVoronoi(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapVoronoi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapVoronoi", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mapVoronoi114 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Cubiomes.C_INT,
            Cubiomes.C_POINTER,
            Cubiomes.C_POINTER,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT,
            Cubiomes.C_INT
        );

        public static final MemorySegment ADDR = Cubiomes.findOrThrow("mapVoronoi114");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mapVoronoi114(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static FunctionDescriptor mapVoronoi114$descriptor() {
        return mapVoronoi114.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mapVoronoi114(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MethodHandle mapVoronoi114$handle() {
        return mapVoronoi114.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mapVoronoi114(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static MemorySegment mapVoronoi114$address() {
        return mapVoronoi114.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mapVoronoi114(const struct Layer *, int *, int, int, int, int)
     * }
     */
    public static int mapVoronoi114(MemorySegment x0, MemorySegment x1, int x2, int x3, int x4, int x5) {
        var mh$ = mapVoronoi114.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mapVoronoi114", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

